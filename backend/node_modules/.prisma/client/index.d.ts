
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Household
 * 
 */
export type Household = $Result.DefaultSelection<Prisma.$HouseholdPayload>
/**
 * Model HouseholdMember
 * 
 */
export type HouseholdMember = $Result.DefaultSelection<Prisma.$HouseholdMemberPayload>
/**
 * Model Institution
 * 
 */
export type Institution = $Result.DefaultSelection<Prisma.$InstitutionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Merchant
 * 
 */
export type Merchant = $Result.DefaultSelection<Prisma.$MerchantPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TransactionTag
 * 
 */
export type TransactionTag = $Result.DefaultSelection<Prisma.$TransactionTagPayload>
/**
 * Model TransactionSplit
 * 
 */
export type TransactionSplit = $Result.DefaultSelection<Prisma.$TransactionSplitPayload>
/**
 * Model LedgerEntry
 * 
 */
export type LedgerEntry = $Result.DefaultSelection<Prisma.$LedgerEntryPayload>
/**
 * Model Debt
 * 
 */
export type Debt = $Result.DefaultSelection<Prisma.$DebtPayload>
/**
 * Model DebtPayment
 * 
 */
export type DebtPayment = $Result.DefaultSelection<Prisma.$DebtPaymentPayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model BudgetCategory
 * 
 */
export type BudgetCategory = $Result.DefaultSelection<Prisma.$BudgetCategoryPayload>
/**
 * Model WishlistItem
 * 
 */
export type WishlistItem = $Result.DefaultSelection<Prisma.$WishlistItemPayload>
/**
 * Model PriceHistory
 * 
 */
export type PriceHistory = $Result.DefaultSelection<Prisma.$PriceHistoryPayload>
/**
 * Model GratitudeEntry
 * 
 */
export type GratitudeEntry = $Result.DefaultSelection<Prisma.$GratitudeEntryPayload>
/**
 * Model ExchangeRate
 * 
 */
export type ExchangeRate = $Result.DefaultSelection<Prisma.$ExchangeRatePayload>
/**
 * Model Passkey
 * 
 */
export type Passkey = $Result.DefaultSelection<Prisma.$PasskeyPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model UserEvent
 * 
 */
export type UserEvent = $Result.DefaultSelection<Prisma.$UserEventPayload>
/**
 * Model SpendingPattern
 * 
 */
export type SpendingPattern = $Result.DefaultSelection<Prisma.$SpendingPatternPayload>
/**
 * Model FinancialInsight
 * 
 */
export type FinancialInsight = $Result.DefaultSelection<Prisma.$FinancialInsightPayload>
/**
 * Model RecurringTransaction
 * 
 */
export type RecurringTransaction = $Result.DefaultSelection<Prisma.$RecurringTransactionPayload>
/**
 * Model RecurringTransactionExecution
 * 
 */
export type RecurringTransactionExecution = $Result.DefaultSelection<Prisma.$RecurringTransactionExecutionPayload>
/**
 * Model DocumentUpload
 * 
 */
export type DocumentUpload = $Result.DefaultSelection<Prisma.$DocumentUploadPayload>
/**
 * Model OcrResult
 * 
 */
export type OcrResult = $Result.DefaultSelection<Prisma.$OcrResultPayload>
/**
 * Model TransactionSuggestion
 * 
 */
export type TransactionSuggestion = $Result.DefaultSelection<Prisma.$TransactionSuggestionPayload>
/**
 * Model ZakatCalculation
 * 
 */
export type ZakatCalculation = $Result.DefaultSelection<Prisma.$ZakatCalculationPayload>
/**
 * Model ZakatAssetBreakdown
 * 
 */
export type ZakatAssetBreakdown = $Result.DefaultSelection<Prisma.$ZakatAssetBreakdownPayload>
/**
 * Model ZakatReminder
 * 
 */
export type ZakatReminder = $Result.DefaultSelection<Prisma.$ZakatReminderPayload>
/**
 * Model ZakatPayment
 * 
 */
export type ZakatPayment = $Result.DefaultSelection<Prisma.$ZakatPaymentPayload>
/**
 * Model ShariaCompliantAccount
 * 
 */
export type ShariaCompliantAccount = $Result.DefaultSelection<Prisma.$ShariaCompliantAccountPayload>
/**
 * Model IslamicFinanceReport
 * 
 */
export type IslamicFinanceReport = $Result.DefaultSelection<Prisma.$IslamicFinanceReportPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationDelivery
 * 
 */
export type NotificationDelivery = $Result.DefaultSelection<Prisma.$NotificationDeliveryPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model PushSubscription
 * 
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const HouseholdRole: {
  ADMIN: 'ADMIN',
  PARTNER: 'PARTNER',
  FINANCE_STAFF: 'FINANCE_STAFF'
};

export type HouseholdRole = (typeof HouseholdRole)[keyof typeof HouseholdRole]


export const InstitutionType: {
  BANK: 'BANK',
  FINTECH: 'FINTECH',
  INVESTMENT: 'INVESTMENT',
  CRYPTO: 'CRYPTO'
};

export type InstitutionType = (typeof InstitutionType)[keyof typeof InstitutionType]


export const AccountType: {
  ASSET: 'ASSET',
  LIABILITY: 'LIABILITY'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const CategoryType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE',
  DEBT: 'DEBT',
  ASSET: 'ASSET',
  LIABILITY: 'LIABILITY',
  INVESTMENT: 'INVESTMENT',
  OTHER: 'OTHER'
};

export type CategoryType = (typeof CategoryType)[keyof typeof CategoryType]


export const LedgerType: {
  DEBIT: 'DEBIT',
  CREDIT: 'CREDIT'
};

export type LedgerType = (typeof LedgerType)[keyof typeof LedgerType]


export const DebtType: {
  PERSONAL: 'PERSONAL',
  CONVENTIONAL: 'CONVENTIONAL',
  ISLAMIC: 'ISLAMIC'
};

export type DebtType = (typeof DebtType)[keyof typeof DebtType]


export const BudgetPeriod: {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY'
};

export type BudgetPeriod = (typeof BudgetPeriod)[keyof typeof BudgetPeriod]


export const GratitudeType: {
  TREAT: 'TREAT',
  HELP: 'HELP',
  GIFT: 'GIFT'
};

export type GratitudeType = (typeof GratitudeType)[keyof typeof GratitudeType]


export const InsightPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type InsightPriority = (typeof InsightPriority)[keyof typeof InsightPriority]


export const RecurrenceFrequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY',
  CUSTOM: 'CUSTOM'
};

export type RecurrenceFrequency = (typeof RecurrenceFrequency)[keyof typeof RecurrenceFrequency]


export const RecurringTransactionStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type RecurringTransactionStatus = (typeof RecurringTransactionStatus)[keyof typeof RecurringTransactionStatus]


export const DocumentType: {
  RECEIPT: 'RECEIPT',
  BANK_STATEMENT: 'BANK_STATEMENT',
  INVOICE: 'INVOICE',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const ProcessingStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REQUIRES_REVIEW: 'REQUIRES_REVIEW'
};

export type ProcessingStatus = (typeof ProcessingStatus)[keyof typeof ProcessingStatus]


export const ZakatAssetType: {
  CASH: 'CASH',
  GOLD: 'GOLD',
  SILVER: 'SILVER',
  BUSINESS_ASSETS: 'BUSINESS_ASSETS',
  INVESTMENT: 'INVESTMENT',
  SAVINGS: 'SAVINGS',
  CRYPTOCURRENCY: 'CRYPTOCURRENCY'
};

export type ZakatAssetType = (typeof ZakatAssetType)[keyof typeof ZakatAssetType]


export const ZakatReminderType: {
  ANNUAL_CALCULATION: 'ANNUAL_CALCULATION',
  PAYMENT_DUE: 'PAYMENT_DUE',
  HAUL_COMPLETION: 'HAUL_COMPLETION',
  NISAB_THRESHOLD_MET: 'NISAB_THRESHOLD_MET'
};

export type ZakatReminderType = (typeof ZakatReminderType)[keyof typeof ZakatReminderType]


export const ShariaComplianceStatus: {
  COMPLIANT: 'COMPLIANT',
  NON_COMPLIANT: 'NON_COMPLIANT',
  UNDER_REVIEW: 'UNDER_REVIEW',
  QUESTIONABLE: 'QUESTIONABLE'
};

export type ShariaComplianceStatus = (typeof ShariaComplianceStatus)[keyof typeof ShariaComplianceStatus]


export const IslamicReportType: {
  ZAKAT_CALCULATION: 'ZAKAT_CALCULATION',
  SHARIA_COMPLIANCE: 'SHARIA_COMPLIANCE',
  ISLAMIC_DEBT_SUMMARY: 'ISLAMIC_DEBT_SUMMARY',
  HALAAL_INCOME_ANALYSIS: 'HALAAL_INCOME_ANALYSIS',
  COMPREHENSIVE: 'COMPREHENSIVE'
};

export type IslamicReportType = (typeof IslamicReportType)[keyof typeof IslamicReportType]


export const NotificationType: {
  BUDGET_EXCEEDED: 'BUDGET_EXCEEDED',
  BUDGET_WARNING: 'BUDGET_WARNING',
  DEBT_PAYMENT_DUE: 'DEBT_PAYMENT_DUE',
  ZAKAT_REMINDER: 'ZAKAT_REMINDER',
  PRICE_ALERT: 'PRICE_ALERT',
  TRANSACTION_CREATED: 'TRANSACTION_CREATED',
  ACCOUNT_BALANCE_LOW: 'ACCOUNT_BALANCE_LOW',
  RECURRING_TRANSACTION_FAILED: 'RECURRING_TRANSACTION_FAILED',
  MONTHLY_REPORT_READY: 'MONTHLY_REPORT_READY',
  SECURITY_ALERT: 'SECURITY_ALERT',
  HOUSEHOLD_INVITATION: 'HOUSEHOLD_INVITATION',
  SYSTEM_MAINTENANCE: 'SYSTEM_MAINTENANCE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationChannel: {
  IN_APP: 'IN_APP',
  EMAIL: 'EMAIL',
  PUSH: 'PUSH'
};

export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel]


export const NotificationPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ',
  FAILED: 'FAILED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]

}

export type HouseholdRole = $Enums.HouseholdRole

export const HouseholdRole: typeof $Enums.HouseholdRole

export type InstitutionType = $Enums.InstitutionType

export const InstitutionType: typeof $Enums.InstitutionType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type CategoryType = $Enums.CategoryType

export const CategoryType: typeof $Enums.CategoryType

export type LedgerType = $Enums.LedgerType

export const LedgerType: typeof $Enums.LedgerType

export type DebtType = $Enums.DebtType

export const DebtType: typeof $Enums.DebtType

export type BudgetPeriod = $Enums.BudgetPeriod

export const BudgetPeriod: typeof $Enums.BudgetPeriod

export type GratitudeType = $Enums.GratitudeType

export const GratitudeType: typeof $Enums.GratitudeType

export type InsightPriority = $Enums.InsightPriority

export const InsightPriority: typeof $Enums.InsightPriority

export type RecurrenceFrequency = $Enums.RecurrenceFrequency

export const RecurrenceFrequency: typeof $Enums.RecurrenceFrequency

export type RecurringTransactionStatus = $Enums.RecurringTransactionStatus

export const RecurringTransactionStatus: typeof $Enums.RecurringTransactionStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type ProcessingStatus = $Enums.ProcessingStatus

export const ProcessingStatus: typeof $Enums.ProcessingStatus

export type ZakatAssetType = $Enums.ZakatAssetType

export const ZakatAssetType: typeof $Enums.ZakatAssetType

export type ZakatReminderType = $Enums.ZakatReminderType

export const ZakatReminderType: typeof $Enums.ZakatReminderType

export type ShariaComplianceStatus = $Enums.ShariaComplianceStatus

export const ShariaComplianceStatus: typeof $Enums.ShariaComplianceStatus

export type IslamicReportType = $Enums.IslamicReportType

export const IslamicReportType: typeof $Enums.IslamicReportType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationChannel = $Enums.NotificationChannel

export const NotificationChannel: typeof $Enums.NotificationChannel

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.household`: Exposes CRUD operations for the **Household** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Households
    * const households = await prisma.household.findMany()
    * ```
    */
  get household(): Prisma.HouseholdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.householdMember`: Exposes CRUD operations for the **HouseholdMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HouseholdMembers
    * const householdMembers = await prisma.householdMember.findMany()
    * ```
    */
  get householdMember(): Prisma.HouseholdMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institution`: Exposes CRUD operations for the **Institution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institution.findMany()
    * ```
    */
  get institution(): Prisma.InstitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchant`: Exposes CRUD operations for the **Merchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchant.findMany()
    * ```
    */
  get merchant(): Prisma.MerchantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionTag`: Exposes CRUD operations for the **TransactionTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionTags
    * const transactionTags = await prisma.transactionTag.findMany()
    * ```
    */
  get transactionTag(): Prisma.TransactionTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionSplit`: Exposes CRUD operations for the **TransactionSplit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionSplits
    * const transactionSplits = await prisma.transactionSplit.findMany()
    * ```
    */
  get transactionSplit(): Prisma.TransactionSplitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ledgerEntry`: Exposes CRUD operations for the **LedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerEntries
    * const ledgerEntries = await prisma.ledgerEntry.findMany()
    * ```
    */
  get ledgerEntry(): Prisma.LedgerEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debt`: Exposes CRUD operations for the **Debt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debts
    * const debts = await prisma.debt.findMany()
    * ```
    */
  get debt(): Prisma.DebtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debtPayment`: Exposes CRUD operations for the **DebtPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DebtPayments
    * const debtPayments = await prisma.debtPayment.findMany()
    * ```
    */
  get debtPayment(): Prisma.DebtPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budgetCategory`: Exposes CRUD operations for the **BudgetCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetCategories
    * const budgetCategories = await prisma.budgetCategory.findMany()
    * ```
    */
  get budgetCategory(): Prisma.BudgetCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlistItem`: Exposes CRUD operations for the **WishlistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishlistItems
    * const wishlistItems = await prisma.wishlistItem.findMany()
    * ```
    */
  get wishlistItem(): Prisma.WishlistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceHistories
    * const priceHistories = await prisma.priceHistory.findMany()
    * ```
    */
  get priceHistory(): Prisma.PriceHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gratitudeEntry`: Exposes CRUD operations for the **GratitudeEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GratitudeEntries
    * const gratitudeEntries = await prisma.gratitudeEntry.findMany()
    * ```
    */
  get gratitudeEntry(): Prisma.GratitudeEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exchangeRate`: Exposes CRUD operations for the **ExchangeRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExchangeRates
    * const exchangeRates = await prisma.exchangeRate.findMany()
    * ```
    */
  get exchangeRate(): Prisma.ExchangeRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passkey`: Exposes CRUD operations for the **Passkey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passkeys
    * const passkeys = await prisma.passkey.findMany()
    * ```
    */
  get passkey(): Prisma.PasskeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userEvent`: Exposes CRUD operations for the **UserEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEvents
    * const userEvents = await prisma.userEvent.findMany()
    * ```
    */
  get userEvent(): Prisma.UserEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spendingPattern`: Exposes CRUD operations for the **SpendingPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpendingPatterns
    * const spendingPatterns = await prisma.spendingPattern.findMany()
    * ```
    */
  get spendingPattern(): Prisma.SpendingPatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialInsight`: Exposes CRUD operations for the **FinancialInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialInsights
    * const financialInsights = await prisma.financialInsight.findMany()
    * ```
    */
  get financialInsight(): Prisma.FinancialInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringTransaction`: Exposes CRUD operations for the **RecurringTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringTransactions
    * const recurringTransactions = await prisma.recurringTransaction.findMany()
    * ```
    */
  get recurringTransaction(): Prisma.RecurringTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringTransactionExecution`: Exposes CRUD operations for the **RecurringTransactionExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringTransactionExecutions
    * const recurringTransactionExecutions = await prisma.recurringTransactionExecution.findMany()
    * ```
    */
  get recurringTransactionExecution(): Prisma.RecurringTransactionExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentUpload`: Exposes CRUD operations for the **DocumentUpload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentUploads
    * const documentUploads = await prisma.documentUpload.findMany()
    * ```
    */
  get documentUpload(): Prisma.DocumentUploadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ocrResult`: Exposes CRUD operations for the **OcrResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OcrResults
    * const ocrResults = await prisma.ocrResult.findMany()
    * ```
    */
  get ocrResult(): Prisma.OcrResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionSuggestion`: Exposes CRUD operations for the **TransactionSuggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionSuggestions
    * const transactionSuggestions = await prisma.transactionSuggestion.findMany()
    * ```
    */
  get transactionSuggestion(): Prisma.TransactionSuggestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zakatCalculation`: Exposes CRUD operations for the **ZakatCalculation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZakatCalculations
    * const zakatCalculations = await prisma.zakatCalculation.findMany()
    * ```
    */
  get zakatCalculation(): Prisma.ZakatCalculationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zakatAssetBreakdown`: Exposes CRUD operations for the **ZakatAssetBreakdown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZakatAssetBreakdowns
    * const zakatAssetBreakdowns = await prisma.zakatAssetBreakdown.findMany()
    * ```
    */
  get zakatAssetBreakdown(): Prisma.ZakatAssetBreakdownDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zakatReminder`: Exposes CRUD operations for the **ZakatReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZakatReminders
    * const zakatReminders = await prisma.zakatReminder.findMany()
    * ```
    */
  get zakatReminder(): Prisma.ZakatReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zakatPayment`: Exposes CRUD operations for the **ZakatPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZakatPayments
    * const zakatPayments = await prisma.zakatPayment.findMany()
    * ```
    */
  get zakatPayment(): Prisma.ZakatPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shariaCompliantAccount`: Exposes CRUD operations for the **ShariaCompliantAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShariaCompliantAccounts
    * const shariaCompliantAccounts = await prisma.shariaCompliantAccount.findMany()
    * ```
    */
  get shariaCompliantAccount(): Prisma.ShariaCompliantAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.islamicFinanceReport`: Exposes CRUD operations for the **IslamicFinanceReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IslamicFinanceReports
    * const islamicFinanceReports = await prisma.islamicFinanceReport.findMany()
    * ```
    */
  get islamicFinanceReport(): Prisma.IslamicFinanceReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationDelivery`: Exposes CRUD operations for the **NotificationDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationDeliveries
    * const notificationDeliveries = await prisma.notificationDelivery.findMany()
    * ```
    */
  get notificationDelivery(): Prisma.NotificationDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Household: 'Household',
    HouseholdMember: 'HouseholdMember',
    Institution: 'Institution',
    Account: 'Account',
    Merchant: 'Merchant',
    Category: 'Category',
    Transaction: 'Transaction',
    TransactionTag: 'TransactionTag',
    TransactionSplit: 'TransactionSplit',
    LedgerEntry: 'LedgerEntry',
    Debt: 'Debt',
    DebtPayment: 'DebtPayment',
    Budget: 'Budget',
    BudgetCategory: 'BudgetCategory',
    WishlistItem: 'WishlistItem',
    PriceHistory: 'PriceHistory',
    GratitudeEntry: 'GratitudeEntry',
    ExchangeRate: 'ExchangeRate',
    Passkey: 'Passkey',
    Session: 'Session',
    UserEvent: 'UserEvent',
    SpendingPattern: 'SpendingPattern',
    FinancialInsight: 'FinancialInsight',
    RecurringTransaction: 'RecurringTransaction',
    RecurringTransactionExecution: 'RecurringTransactionExecution',
    DocumentUpload: 'DocumentUpload',
    OcrResult: 'OcrResult',
    TransactionSuggestion: 'TransactionSuggestion',
    ZakatCalculation: 'ZakatCalculation',
    ZakatAssetBreakdown: 'ZakatAssetBreakdown',
    ZakatReminder: 'ZakatReminder',
    ZakatPayment: 'ZakatPayment',
    ShariaCompliantAccount: 'ShariaCompliantAccount',
    IslamicFinanceReport: 'IslamicFinanceReport',
    Notification: 'Notification',
    NotificationDelivery: 'NotificationDelivery',
    NotificationPreference: 'NotificationPreference',
    PushSubscription: 'PushSubscription',
    EmailTemplate: 'EmailTemplate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "household" | "householdMember" | "institution" | "account" | "merchant" | "category" | "transaction" | "transactionTag" | "transactionSplit" | "ledgerEntry" | "debt" | "debtPayment" | "budget" | "budgetCategory" | "wishlistItem" | "priceHistory" | "gratitudeEntry" | "exchangeRate" | "passkey" | "session" | "userEvent" | "spendingPattern" | "financialInsight" | "recurringTransaction" | "recurringTransactionExecution" | "documentUpload" | "ocrResult" | "transactionSuggestion" | "zakatCalculation" | "zakatAssetBreakdown" | "zakatReminder" | "zakatPayment" | "shariaCompliantAccount" | "islamicFinanceReport" | "notification" | "notificationDelivery" | "notificationPreference" | "pushSubscription" | "emailTemplate"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Household: {
        payload: Prisma.$HouseholdPayload<ExtArgs>
        fields: Prisma.HouseholdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HouseholdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HouseholdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          findFirst: {
            args: Prisma.HouseholdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HouseholdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          findMany: {
            args: Prisma.HouseholdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>[]
          }
          create: {
            args: Prisma.HouseholdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          createMany: {
            args: Prisma.HouseholdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HouseholdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>[]
          }
          delete: {
            args: Prisma.HouseholdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          update: {
            args: Prisma.HouseholdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          deleteMany: {
            args: Prisma.HouseholdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HouseholdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HouseholdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>[]
          }
          upsert: {
            args: Prisma.HouseholdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          aggregate: {
            args: Prisma.HouseholdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHousehold>
          }
          groupBy: {
            args: Prisma.HouseholdGroupByArgs<ExtArgs>
            result: $Utils.Optional<HouseholdGroupByOutputType>[]
          }
          count: {
            args: Prisma.HouseholdCountArgs<ExtArgs>
            result: $Utils.Optional<HouseholdCountAggregateOutputType> | number
          }
        }
      }
      HouseholdMember: {
        payload: Prisma.$HouseholdMemberPayload<ExtArgs>
        fields: Prisma.HouseholdMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HouseholdMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HouseholdMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          findFirst: {
            args: Prisma.HouseholdMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HouseholdMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          findMany: {
            args: Prisma.HouseholdMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>[]
          }
          create: {
            args: Prisma.HouseholdMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          createMany: {
            args: Prisma.HouseholdMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HouseholdMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>[]
          }
          delete: {
            args: Prisma.HouseholdMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          update: {
            args: Prisma.HouseholdMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          deleteMany: {
            args: Prisma.HouseholdMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HouseholdMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HouseholdMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>[]
          }
          upsert: {
            args: Prisma.HouseholdMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          aggregate: {
            args: Prisma.HouseholdMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHouseholdMember>
          }
          groupBy: {
            args: Prisma.HouseholdMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<HouseholdMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.HouseholdMemberCountArgs<ExtArgs>
            result: $Utils.Optional<HouseholdMemberCountAggregateOutputType> | number
          }
        }
      }
      Institution: {
        payload: Prisma.$InstitutionPayload<ExtArgs>
        fields: Prisma.InstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findFirst: {
            args: Prisma.InstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findMany: {
            args: Prisma.InstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          create: {
            args: Prisma.InstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          createMany: {
            args: Prisma.InstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstitutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          delete: {
            args: Prisma.InstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          update: {
            args: Prisma.InstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstitutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          upsert: {
            args: Prisma.InstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          aggregate: {
            args: Prisma.InstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution>
          }
          groupBy: {
            args: Prisma.InstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Merchant: {
        payload: Prisma.$MerchantPayload<ExtArgs>
        fields: Prisma.MerchantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findFirst: {
            args: Prisma.MerchantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findMany: {
            args: Prisma.MerchantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          create: {
            args: Prisma.MerchantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          createMany: {
            args: Prisma.MerchantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          delete: {
            args: Prisma.MerchantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          update: {
            args: Prisma.MerchantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          deleteMany: {
            args: Prisma.MerchantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          upsert: {
            args: Prisma.MerchantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          aggregate: {
            args: Prisma.MerchantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchant>
          }
          groupBy: {
            args: Prisma.MerchantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TransactionTag: {
        payload: Prisma.$TransactionTagPayload<ExtArgs>
        fields: Prisma.TransactionTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          findFirst: {
            args: Prisma.TransactionTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          findMany: {
            args: Prisma.TransactionTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>[]
          }
          create: {
            args: Prisma.TransactionTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          createMany: {
            args: Prisma.TransactionTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>[]
          }
          delete: {
            args: Prisma.TransactionTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          update: {
            args: Prisma.TransactionTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          deleteMany: {
            args: Prisma.TransactionTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>[]
          }
          upsert: {
            args: Prisma.TransactionTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionTagPayload>
          }
          aggregate: {
            args: Prisma.TransactionTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionTag>
          }
          groupBy: {
            args: Prisma.TransactionTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionTagCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionTagCountAggregateOutputType> | number
          }
        }
      }
      TransactionSplit: {
        payload: Prisma.$TransactionSplitPayload<ExtArgs>
        fields: Prisma.TransactionSplitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionSplitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionSplitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>
          }
          findFirst: {
            args: Prisma.TransactionSplitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionSplitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>
          }
          findMany: {
            args: Prisma.TransactionSplitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>[]
          }
          create: {
            args: Prisma.TransactionSplitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>
          }
          createMany: {
            args: Prisma.TransactionSplitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionSplitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>[]
          }
          delete: {
            args: Prisma.TransactionSplitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>
          }
          update: {
            args: Prisma.TransactionSplitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>
          }
          deleteMany: {
            args: Prisma.TransactionSplitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionSplitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionSplitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>[]
          }
          upsert: {
            args: Prisma.TransactionSplitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSplitPayload>
          }
          aggregate: {
            args: Prisma.TransactionSplitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionSplit>
          }
          groupBy: {
            args: Prisma.TransactionSplitGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionSplitGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionSplitCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionSplitCountAggregateOutputType> | number
          }
        }
      }
      LedgerEntry: {
        payload: Prisma.$LedgerEntryPayload<ExtArgs>
        fields: Prisma.LedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.LedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findMany: {
            args: Prisma.LedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          create: {
            args: Prisma.LedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          createMany: {
            args: Prisma.LedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.LedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          update: {
            args: Prisma.LedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.LedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LedgerEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          upsert: {
            args: Prisma.LedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.LedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerEntry>
          }
          groupBy: {
            args: Prisma.LedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      Debt: {
        payload: Prisma.$DebtPayload<ExtArgs>
        fields: Prisma.DebtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          findFirst: {
            args: Prisma.DebtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          findMany: {
            args: Prisma.DebtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>[]
          }
          create: {
            args: Prisma.DebtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          createMany: {
            args: Prisma.DebtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DebtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>[]
          }
          delete: {
            args: Prisma.DebtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          update: {
            args: Prisma.DebtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          deleteMany: {
            args: Prisma.DebtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DebtUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>[]
          }
          upsert: {
            args: Prisma.DebtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPayload>
          }
          aggregate: {
            args: Prisma.DebtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebt>
          }
          groupBy: {
            args: Prisma.DebtGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtCountArgs<ExtArgs>
            result: $Utils.Optional<DebtCountAggregateOutputType> | number
          }
        }
      }
      DebtPayment: {
        payload: Prisma.$DebtPaymentPayload<ExtArgs>
        fields: Prisma.DebtPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          findFirst: {
            args: Prisma.DebtPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          findMany: {
            args: Prisma.DebtPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>[]
          }
          create: {
            args: Prisma.DebtPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          createMany: {
            args: Prisma.DebtPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DebtPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>[]
          }
          delete: {
            args: Prisma.DebtPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          update: {
            args: Prisma.DebtPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          deleteMany: {
            args: Prisma.DebtPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DebtPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>[]
          }
          upsert: {
            args: Prisma.DebtPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtPaymentPayload>
          }
          aggregate: {
            args: Prisma.DebtPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtPayment>
          }
          groupBy: {
            args: Prisma.DebtPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<DebtPaymentCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      BudgetCategory: {
        payload: Prisma.$BudgetCategoryPayload<ExtArgs>
        fields: Prisma.BudgetCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          findFirst: {
            args: Prisma.BudgetCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          findMany: {
            args: Prisma.BudgetCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>[]
          }
          create: {
            args: Prisma.BudgetCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          createMany: {
            args: Prisma.BudgetCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>[]
          }
          delete: {
            args: Prisma.BudgetCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          update: {
            args: Prisma.BudgetCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          deleteMany: {
            args: Prisma.BudgetCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>[]
          }
          upsert: {
            args: Prisma.BudgetCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          aggregate: {
            args: Prisma.BudgetCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetCategory>
          }
          groupBy: {
            args: Prisma.BudgetCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCategoryCountAggregateOutputType> | number
          }
        }
      }
      WishlistItem: {
        payload: Prisma.$WishlistItemPayload<ExtArgs>
        fields: Prisma.WishlistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findFirst: {
            args: Prisma.WishlistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findMany: {
            args: Prisma.WishlistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          create: {
            args: Prisma.WishlistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          createMany: {
            args: Prisma.WishlistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishlistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          delete: {
            args: Prisma.WishlistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          update: {
            args: Prisma.WishlistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          deleteMany: {
            args: Prisma.WishlistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WishlistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          upsert: {
            args: Prisma.WishlistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          aggregate: {
            args: Prisma.WishlistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlistItem>
          }
          groupBy: {
            args: Prisma.WishlistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistItemCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemCountAggregateOutputType> | number
          }
        }
      }
      PriceHistory: {
        payload: Prisma.$PriceHistoryPayload<ExtArgs>
        fields: Prisma.PriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findMany: {
            args: Prisma.PriceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          create: {
            args: Prisma.PriceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          createMany: {
            args: Prisma.PriceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          delete: {
            args: Prisma.PriceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          update: {
            args: Prisma.PriceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PriceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.PriceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceHistory>
          }
          groupBy: {
            args: Prisma.PriceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      GratitudeEntry: {
        payload: Prisma.$GratitudeEntryPayload<ExtArgs>
        fields: Prisma.GratitudeEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GratitudeEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GratitudeEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>
          }
          findFirst: {
            args: Prisma.GratitudeEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GratitudeEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>
          }
          findMany: {
            args: Prisma.GratitudeEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>[]
          }
          create: {
            args: Prisma.GratitudeEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>
          }
          createMany: {
            args: Prisma.GratitudeEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GratitudeEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>[]
          }
          delete: {
            args: Prisma.GratitudeEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>
          }
          update: {
            args: Prisma.GratitudeEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>
          }
          deleteMany: {
            args: Prisma.GratitudeEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GratitudeEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GratitudeEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>[]
          }
          upsert: {
            args: Prisma.GratitudeEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GratitudeEntryPayload>
          }
          aggregate: {
            args: Prisma.GratitudeEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGratitudeEntry>
          }
          groupBy: {
            args: Prisma.GratitudeEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<GratitudeEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.GratitudeEntryCountArgs<ExtArgs>
            result: $Utils.Optional<GratitudeEntryCountAggregateOutputType> | number
          }
        }
      }
      ExchangeRate: {
        payload: Prisma.$ExchangeRatePayload<ExtArgs>
        fields: Prisma.ExchangeRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExchangeRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExchangeRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          findFirst: {
            args: Prisma.ExchangeRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExchangeRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          findMany: {
            args: Prisma.ExchangeRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
          }
          create: {
            args: Prisma.ExchangeRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          createMany: {
            args: Prisma.ExchangeRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExchangeRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
          }
          delete: {
            args: Prisma.ExchangeRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          update: {
            args: Prisma.ExchangeRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          deleteMany: {
            args: Prisma.ExchangeRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExchangeRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExchangeRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
          }
          upsert: {
            args: Prisma.ExchangeRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          aggregate: {
            args: Prisma.ExchangeRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchangeRate>
          }
          groupBy: {
            args: Prisma.ExchangeRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangeRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExchangeRateCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangeRateCountAggregateOutputType> | number
          }
        }
      }
      Passkey: {
        payload: Prisma.$PasskeyPayload<ExtArgs>
        fields: Prisma.PasskeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasskeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasskeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          findFirst: {
            args: Prisma.PasskeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasskeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          findMany: {
            args: Prisma.PasskeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>[]
          }
          create: {
            args: Prisma.PasskeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          createMany: {
            args: Prisma.PasskeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasskeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>[]
          }
          delete: {
            args: Prisma.PasskeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          update: {
            args: Prisma.PasskeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          deleteMany: {
            args: Prisma.PasskeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasskeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasskeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>[]
          }
          upsert: {
            args: Prisma.PasskeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          aggregate: {
            args: Prisma.PasskeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasskey>
          }
          groupBy: {
            args: Prisma.PasskeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasskeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasskeyCountArgs<ExtArgs>
            result: $Utils.Optional<PasskeyCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      UserEvent: {
        payload: Prisma.$UserEventPayload<ExtArgs>
        fields: Prisma.UserEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>
          }
          findFirst: {
            args: Prisma.UserEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>
          }
          findMany: {
            args: Prisma.UserEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>[]
          }
          create: {
            args: Prisma.UserEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>
          }
          createMany: {
            args: Prisma.UserEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>[]
          }
          delete: {
            args: Prisma.UserEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>
          }
          update: {
            args: Prisma.UserEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>
          }
          deleteMany: {
            args: Prisma.UserEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>[]
          }
          upsert: {
            args: Prisma.UserEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEventPayload>
          }
          aggregate: {
            args: Prisma.UserEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserEvent>
          }
          groupBy: {
            args: Prisma.UserEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserEventCountArgs<ExtArgs>
            result: $Utils.Optional<UserEventCountAggregateOutputType> | number
          }
        }
      }
      SpendingPattern: {
        payload: Prisma.$SpendingPatternPayload<ExtArgs>
        fields: Prisma.SpendingPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpendingPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpendingPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>
          }
          findFirst: {
            args: Prisma.SpendingPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpendingPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>
          }
          findMany: {
            args: Prisma.SpendingPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>[]
          }
          create: {
            args: Prisma.SpendingPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>
          }
          createMany: {
            args: Prisma.SpendingPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpendingPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>[]
          }
          delete: {
            args: Prisma.SpendingPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>
          }
          update: {
            args: Prisma.SpendingPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>
          }
          deleteMany: {
            args: Prisma.SpendingPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpendingPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpendingPatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>[]
          }
          upsert: {
            args: Prisma.SpendingPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingPatternPayload>
          }
          aggregate: {
            args: Prisma.SpendingPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpendingPattern>
          }
          groupBy: {
            args: Prisma.SpendingPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpendingPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpendingPatternCountArgs<ExtArgs>
            result: $Utils.Optional<SpendingPatternCountAggregateOutputType> | number
          }
        }
      }
      FinancialInsight: {
        payload: Prisma.$FinancialInsightPayload<ExtArgs>
        fields: Prisma.FinancialInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          findFirst: {
            args: Prisma.FinancialInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          findMany: {
            args: Prisma.FinancialInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>[]
          }
          create: {
            args: Prisma.FinancialInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          createMany: {
            args: Prisma.FinancialInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>[]
          }
          delete: {
            args: Prisma.FinancialInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          update: {
            args: Prisma.FinancialInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          deleteMany: {
            args: Prisma.FinancialInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialInsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>[]
          }
          upsert: {
            args: Prisma.FinancialInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialInsightPayload>
          }
          aggregate: {
            args: Prisma.FinancialInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialInsight>
          }
          groupBy: {
            args: Prisma.FinancialInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialInsightCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialInsightCountAggregateOutputType> | number
          }
        }
      }
      RecurringTransaction: {
        payload: Prisma.$RecurringTransactionPayload<ExtArgs>
        fields: Prisma.RecurringTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>
          }
          findFirst: {
            args: Prisma.RecurringTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>
          }
          findMany: {
            args: Prisma.RecurringTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>[]
          }
          create: {
            args: Prisma.RecurringTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>
          }
          createMany: {
            args: Prisma.RecurringTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>[]
          }
          delete: {
            args: Prisma.RecurringTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>
          }
          update: {
            args: Prisma.RecurringTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>
          }
          deleteMany: {
            args: Prisma.RecurringTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>[]
          }
          upsert: {
            args: Prisma.RecurringTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionPayload>
          }
          aggregate: {
            args: Prisma.RecurringTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringTransaction>
          }
          groupBy: {
            args: Prisma.RecurringTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringTransactionCountAggregateOutputType> | number
          }
        }
      }
      RecurringTransactionExecution: {
        payload: Prisma.$RecurringTransactionExecutionPayload<ExtArgs>
        fields: Prisma.RecurringTransactionExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringTransactionExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringTransactionExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>
          }
          findFirst: {
            args: Prisma.RecurringTransactionExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringTransactionExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>
          }
          findMany: {
            args: Prisma.RecurringTransactionExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>[]
          }
          create: {
            args: Prisma.RecurringTransactionExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>
          }
          createMany: {
            args: Prisma.RecurringTransactionExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringTransactionExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>[]
          }
          delete: {
            args: Prisma.RecurringTransactionExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>
          }
          update: {
            args: Prisma.RecurringTransactionExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>
          }
          deleteMany: {
            args: Prisma.RecurringTransactionExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringTransactionExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringTransactionExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>[]
          }
          upsert: {
            args: Prisma.RecurringTransactionExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringTransactionExecutionPayload>
          }
          aggregate: {
            args: Prisma.RecurringTransactionExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringTransactionExecution>
          }
          groupBy: {
            args: Prisma.RecurringTransactionExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringTransactionExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringTransactionExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringTransactionExecutionCountAggregateOutputType> | number
          }
        }
      }
      DocumentUpload: {
        payload: Prisma.$DocumentUploadPayload<ExtArgs>
        fields: Prisma.DocumentUploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentUploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentUploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>
          }
          findFirst: {
            args: Prisma.DocumentUploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentUploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>
          }
          findMany: {
            args: Prisma.DocumentUploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>[]
          }
          create: {
            args: Prisma.DocumentUploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>
          }
          createMany: {
            args: Prisma.DocumentUploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentUploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>[]
          }
          delete: {
            args: Prisma.DocumentUploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>
          }
          update: {
            args: Prisma.DocumentUploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>
          }
          deleteMany: {
            args: Prisma.DocumentUploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUploadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentUploadPayload>
          }
          aggregate: {
            args: Prisma.DocumentUploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentUpload>
          }
          groupBy: {
            args: Prisma.DocumentUploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentUploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentUploadCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentUploadCountAggregateOutputType> | number
          }
        }
      }
      OcrResult: {
        payload: Prisma.$OcrResultPayload<ExtArgs>
        fields: Prisma.OcrResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OcrResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OcrResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>
          }
          findFirst: {
            args: Prisma.OcrResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OcrResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>
          }
          findMany: {
            args: Prisma.OcrResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>[]
          }
          create: {
            args: Prisma.OcrResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>
          }
          createMany: {
            args: Prisma.OcrResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OcrResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>[]
          }
          delete: {
            args: Prisma.OcrResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>
          }
          update: {
            args: Prisma.OcrResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>
          }
          deleteMany: {
            args: Prisma.OcrResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OcrResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OcrResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>[]
          }
          upsert: {
            args: Prisma.OcrResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcrResultPayload>
          }
          aggregate: {
            args: Prisma.OcrResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOcrResult>
          }
          groupBy: {
            args: Prisma.OcrResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<OcrResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.OcrResultCountArgs<ExtArgs>
            result: $Utils.Optional<OcrResultCountAggregateOutputType> | number
          }
        }
      }
      TransactionSuggestion: {
        payload: Prisma.$TransactionSuggestionPayload<ExtArgs>
        fields: Prisma.TransactionSuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionSuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionSuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>
          }
          findFirst: {
            args: Prisma.TransactionSuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionSuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>
          }
          findMany: {
            args: Prisma.TransactionSuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>[]
          }
          create: {
            args: Prisma.TransactionSuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>
          }
          createMany: {
            args: Prisma.TransactionSuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionSuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>[]
          }
          delete: {
            args: Prisma.TransactionSuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>
          }
          update: {
            args: Prisma.TransactionSuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionSuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionSuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionSuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionSuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionSuggestionPayload>
          }
          aggregate: {
            args: Prisma.TransactionSuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionSuggestion>
          }
          groupBy: {
            args: Prisma.TransactionSuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionSuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionSuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionSuggestionCountAggregateOutputType> | number
          }
        }
      }
      ZakatCalculation: {
        payload: Prisma.$ZakatCalculationPayload<ExtArgs>
        fields: Prisma.ZakatCalculationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZakatCalculationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZakatCalculationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>
          }
          findFirst: {
            args: Prisma.ZakatCalculationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZakatCalculationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>
          }
          findMany: {
            args: Prisma.ZakatCalculationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>[]
          }
          create: {
            args: Prisma.ZakatCalculationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>
          }
          createMany: {
            args: Prisma.ZakatCalculationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZakatCalculationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>[]
          }
          delete: {
            args: Prisma.ZakatCalculationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>
          }
          update: {
            args: Prisma.ZakatCalculationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>
          }
          deleteMany: {
            args: Prisma.ZakatCalculationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZakatCalculationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZakatCalculationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>[]
          }
          upsert: {
            args: Prisma.ZakatCalculationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatCalculationPayload>
          }
          aggregate: {
            args: Prisma.ZakatCalculationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZakatCalculation>
          }
          groupBy: {
            args: Prisma.ZakatCalculationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZakatCalculationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZakatCalculationCountArgs<ExtArgs>
            result: $Utils.Optional<ZakatCalculationCountAggregateOutputType> | number
          }
        }
      }
      ZakatAssetBreakdown: {
        payload: Prisma.$ZakatAssetBreakdownPayload<ExtArgs>
        fields: Prisma.ZakatAssetBreakdownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZakatAssetBreakdownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZakatAssetBreakdownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>
          }
          findFirst: {
            args: Prisma.ZakatAssetBreakdownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZakatAssetBreakdownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>
          }
          findMany: {
            args: Prisma.ZakatAssetBreakdownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>[]
          }
          create: {
            args: Prisma.ZakatAssetBreakdownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>
          }
          createMany: {
            args: Prisma.ZakatAssetBreakdownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZakatAssetBreakdownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>[]
          }
          delete: {
            args: Prisma.ZakatAssetBreakdownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>
          }
          update: {
            args: Prisma.ZakatAssetBreakdownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>
          }
          deleteMany: {
            args: Prisma.ZakatAssetBreakdownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZakatAssetBreakdownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZakatAssetBreakdownUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>[]
          }
          upsert: {
            args: Prisma.ZakatAssetBreakdownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatAssetBreakdownPayload>
          }
          aggregate: {
            args: Prisma.ZakatAssetBreakdownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZakatAssetBreakdown>
          }
          groupBy: {
            args: Prisma.ZakatAssetBreakdownGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZakatAssetBreakdownGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZakatAssetBreakdownCountArgs<ExtArgs>
            result: $Utils.Optional<ZakatAssetBreakdownCountAggregateOutputType> | number
          }
        }
      }
      ZakatReminder: {
        payload: Prisma.$ZakatReminderPayload<ExtArgs>
        fields: Prisma.ZakatReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZakatReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZakatReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>
          }
          findFirst: {
            args: Prisma.ZakatReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZakatReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>
          }
          findMany: {
            args: Prisma.ZakatReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>[]
          }
          create: {
            args: Prisma.ZakatReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>
          }
          createMany: {
            args: Prisma.ZakatReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZakatReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>[]
          }
          delete: {
            args: Prisma.ZakatReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>
          }
          update: {
            args: Prisma.ZakatReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>
          }
          deleteMany: {
            args: Prisma.ZakatReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZakatReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZakatReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>[]
          }
          upsert: {
            args: Prisma.ZakatReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatReminderPayload>
          }
          aggregate: {
            args: Prisma.ZakatReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZakatReminder>
          }
          groupBy: {
            args: Prisma.ZakatReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZakatReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZakatReminderCountArgs<ExtArgs>
            result: $Utils.Optional<ZakatReminderCountAggregateOutputType> | number
          }
        }
      }
      ZakatPayment: {
        payload: Prisma.$ZakatPaymentPayload<ExtArgs>
        fields: Prisma.ZakatPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZakatPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZakatPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>
          }
          findFirst: {
            args: Prisma.ZakatPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZakatPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>
          }
          findMany: {
            args: Prisma.ZakatPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>[]
          }
          create: {
            args: Prisma.ZakatPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>
          }
          createMany: {
            args: Prisma.ZakatPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZakatPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>[]
          }
          delete: {
            args: Prisma.ZakatPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>
          }
          update: {
            args: Prisma.ZakatPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>
          }
          deleteMany: {
            args: Prisma.ZakatPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZakatPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZakatPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>[]
          }
          upsert: {
            args: Prisma.ZakatPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZakatPaymentPayload>
          }
          aggregate: {
            args: Prisma.ZakatPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZakatPayment>
          }
          groupBy: {
            args: Prisma.ZakatPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZakatPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZakatPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<ZakatPaymentCountAggregateOutputType> | number
          }
        }
      }
      ShariaCompliantAccount: {
        payload: Prisma.$ShariaCompliantAccountPayload<ExtArgs>
        fields: Prisma.ShariaCompliantAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShariaCompliantAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShariaCompliantAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>
          }
          findFirst: {
            args: Prisma.ShariaCompliantAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShariaCompliantAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>
          }
          findMany: {
            args: Prisma.ShariaCompliantAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>[]
          }
          create: {
            args: Prisma.ShariaCompliantAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>
          }
          createMany: {
            args: Prisma.ShariaCompliantAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShariaCompliantAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>[]
          }
          delete: {
            args: Prisma.ShariaCompliantAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>
          }
          update: {
            args: Prisma.ShariaCompliantAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>
          }
          deleteMany: {
            args: Prisma.ShariaCompliantAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShariaCompliantAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShariaCompliantAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>[]
          }
          upsert: {
            args: Prisma.ShariaCompliantAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShariaCompliantAccountPayload>
          }
          aggregate: {
            args: Prisma.ShariaCompliantAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShariaCompliantAccount>
          }
          groupBy: {
            args: Prisma.ShariaCompliantAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShariaCompliantAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShariaCompliantAccountCountArgs<ExtArgs>
            result: $Utils.Optional<ShariaCompliantAccountCountAggregateOutputType> | number
          }
        }
      }
      IslamicFinanceReport: {
        payload: Prisma.$IslamicFinanceReportPayload<ExtArgs>
        fields: Prisma.IslamicFinanceReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IslamicFinanceReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IslamicFinanceReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>
          }
          findFirst: {
            args: Prisma.IslamicFinanceReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IslamicFinanceReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>
          }
          findMany: {
            args: Prisma.IslamicFinanceReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>[]
          }
          create: {
            args: Prisma.IslamicFinanceReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>
          }
          createMany: {
            args: Prisma.IslamicFinanceReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IslamicFinanceReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>[]
          }
          delete: {
            args: Prisma.IslamicFinanceReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>
          }
          update: {
            args: Prisma.IslamicFinanceReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>
          }
          deleteMany: {
            args: Prisma.IslamicFinanceReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IslamicFinanceReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IslamicFinanceReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>[]
          }
          upsert: {
            args: Prisma.IslamicFinanceReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IslamicFinanceReportPayload>
          }
          aggregate: {
            args: Prisma.IslamicFinanceReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIslamicFinanceReport>
          }
          groupBy: {
            args: Prisma.IslamicFinanceReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<IslamicFinanceReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.IslamicFinanceReportCountArgs<ExtArgs>
            result: $Utils.Optional<IslamicFinanceReportCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationDelivery: {
        payload: Prisma.$NotificationDeliveryPayload<ExtArgs>
        fields: Prisma.NotificationDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>
          }
          findFirst: {
            args: Prisma.NotificationDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>
          }
          findMany: {
            args: Prisma.NotificationDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>[]
          }
          create: {
            args: Prisma.NotificationDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>
          }
          createMany: {
            args: Prisma.NotificationDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>
          }
          update: {
            args: Prisma.NotificationDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationDeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>[]
          }
          upsert: {
            args: Prisma.NotificationDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDeliveryPayload>
          }
          aggregate: {
            args: Prisma.NotificationDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationDelivery>
          }
          groupBy: {
            args: Prisma.NotificationDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationDeliveryCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    household?: HouseholdOmit
    householdMember?: HouseholdMemberOmit
    institution?: InstitutionOmit
    account?: AccountOmit
    merchant?: MerchantOmit
    category?: CategoryOmit
    transaction?: TransactionOmit
    transactionTag?: TransactionTagOmit
    transactionSplit?: TransactionSplitOmit
    ledgerEntry?: LedgerEntryOmit
    debt?: DebtOmit
    debtPayment?: DebtPaymentOmit
    budget?: BudgetOmit
    budgetCategory?: BudgetCategoryOmit
    wishlistItem?: WishlistItemOmit
    priceHistory?: PriceHistoryOmit
    gratitudeEntry?: GratitudeEntryOmit
    exchangeRate?: ExchangeRateOmit
    passkey?: PasskeyOmit
    session?: SessionOmit
    userEvent?: UserEventOmit
    spendingPattern?: SpendingPatternOmit
    financialInsight?: FinancialInsightOmit
    recurringTransaction?: RecurringTransactionOmit
    recurringTransactionExecution?: RecurringTransactionExecutionOmit
    documentUpload?: DocumentUploadOmit
    ocrResult?: OcrResultOmit
    transactionSuggestion?: TransactionSuggestionOmit
    zakatCalculation?: ZakatCalculationOmit
    zakatAssetBreakdown?: ZakatAssetBreakdownOmit
    zakatReminder?: ZakatReminderOmit
    zakatPayment?: ZakatPaymentOmit
    shariaCompliantAccount?: ShariaCompliantAccountOmit
    islamicFinanceReport?: IslamicFinanceReportOmit
    notification?: NotificationOmit
    notificationDelivery?: NotificationDeliveryOmit
    notificationPreference?: NotificationPreferenceOmit
    pushSubscription?: PushSubscriptionOmit
    emailTemplate?: EmailTemplateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    householdMembers: number
    passkeys: number
    sessions: number
    createdTransactions: number
    createdWishlistItems: number
    createdGratitudeEntries: number
    createdRecurringTransactions: number
    uploadedDocuments: number
    userEvents: number
    shariaReviews: number
    generatedIslamicReports: number
    notifications: number
    pushSubscriptions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    householdMembers?: boolean | UserCountOutputTypeCountHouseholdMembersArgs
    passkeys?: boolean | UserCountOutputTypeCountPasskeysArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    createdTransactions?: boolean | UserCountOutputTypeCountCreatedTransactionsArgs
    createdWishlistItems?: boolean | UserCountOutputTypeCountCreatedWishlistItemsArgs
    createdGratitudeEntries?: boolean | UserCountOutputTypeCountCreatedGratitudeEntriesArgs
    createdRecurringTransactions?: boolean | UserCountOutputTypeCountCreatedRecurringTransactionsArgs
    uploadedDocuments?: boolean | UserCountOutputTypeCountUploadedDocumentsArgs
    userEvents?: boolean | UserCountOutputTypeCountUserEventsArgs
    shariaReviews?: boolean | UserCountOutputTypeCountShariaReviewsArgs
    generatedIslamicReports?: boolean | UserCountOutputTypeCountGeneratedIslamicReportsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    pushSubscriptions?: boolean | UserCountOutputTypeCountPushSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHouseholdMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasskeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasskeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedWishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedGratitudeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GratitudeEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRecurringTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentUploadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShariaReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShariaCompliantAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneratedIslamicReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IslamicFinanceReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }


  /**
   * Count Type HouseholdCountOutputType
   */

  export type HouseholdCountOutputType = {
    members: number
    accounts: number
    transactions: number
    debts: number
    budgets: number
    wishlistItems: number
    gratitudeEntries: number
    categories: number
    recurringTransactions: number
    documentUploads: number
    userEvents: number
    spendingPatterns: number
    financialInsights: number
    zakatCalculations: number
    zakatReminders: number
    zakatPayments: number
    islamicFinanceReports: number
    notifications: number
  }

  export type HouseholdCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | HouseholdCountOutputTypeCountMembersArgs
    accounts?: boolean | HouseholdCountOutputTypeCountAccountsArgs
    transactions?: boolean | HouseholdCountOutputTypeCountTransactionsArgs
    debts?: boolean | HouseholdCountOutputTypeCountDebtsArgs
    budgets?: boolean | HouseholdCountOutputTypeCountBudgetsArgs
    wishlistItems?: boolean | HouseholdCountOutputTypeCountWishlistItemsArgs
    gratitudeEntries?: boolean | HouseholdCountOutputTypeCountGratitudeEntriesArgs
    categories?: boolean | HouseholdCountOutputTypeCountCategoriesArgs
    recurringTransactions?: boolean | HouseholdCountOutputTypeCountRecurringTransactionsArgs
    documentUploads?: boolean | HouseholdCountOutputTypeCountDocumentUploadsArgs
    userEvents?: boolean | HouseholdCountOutputTypeCountUserEventsArgs
    spendingPatterns?: boolean | HouseholdCountOutputTypeCountSpendingPatternsArgs
    financialInsights?: boolean | HouseholdCountOutputTypeCountFinancialInsightsArgs
    zakatCalculations?: boolean | HouseholdCountOutputTypeCountZakatCalculationsArgs
    zakatReminders?: boolean | HouseholdCountOutputTypeCountZakatRemindersArgs
    zakatPayments?: boolean | HouseholdCountOutputTypeCountZakatPaymentsArgs
    islamicFinanceReports?: boolean | HouseholdCountOutputTypeCountIslamicFinanceReportsArgs
    notifications?: boolean | HouseholdCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdCountOutputType
     */
    select?: HouseholdCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdMemberWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountDebtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountWishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountGratitudeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GratitudeEntryWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountRecurringTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountDocumentUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentUploadWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountUserEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEventWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountSpendingPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingPatternWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountFinancialInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialInsightWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountZakatCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatCalculationWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountZakatRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatReminderWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountZakatPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatPaymentWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountIslamicFinanceReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IslamicFinanceReportWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InstitutionCountOutputType
   */

  export type InstitutionCountOutputType = {
    accounts: number
  }

  export type InstitutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | InstitutionCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes
  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionCountOutputType
     */
    select?: InstitutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    transactions: number
    transferTransactions: number
    recurringTransactions: number
    recurringTransferTransactions: number
    ledgerEntries: number
    zakatAssetBreakdown: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AccountCountOutputTypeCountTransactionsArgs
    transferTransactions?: boolean | AccountCountOutputTypeCountTransferTransactionsArgs
    recurringTransactions?: boolean | AccountCountOutputTypeCountRecurringTransactionsArgs
    recurringTransferTransactions?: boolean | AccountCountOutputTypeCountRecurringTransferTransactionsArgs
    ledgerEntries?: boolean | AccountCountOutputTypeCountLedgerEntriesArgs
    zakatAssetBreakdown?: boolean | AccountCountOutputTypeCountZakatAssetBreakdownArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTransferTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountRecurringTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountRecurringTransferTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountZakatAssetBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatAssetBreakdownWhereInput
  }


  /**
   * Count Type MerchantCountOutputType
   */

  export type MerchantCountOutputType = {
    transactions: number
  }

  export type MerchantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | MerchantCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantCountOutputType
     */
    select?: MerchantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    transactions: number
    transactionSplits: number
    budgetCategories: number
    recurringTransactions: number
    gratitudeEntries: number
    transactionSuggestions: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    transactions?: boolean | CategoryCountOutputTypeCountTransactionsArgs
    transactionSplits?: boolean | CategoryCountOutputTypeCountTransactionSplitsArgs
    budgetCategories?: boolean | CategoryCountOutputTypeCountBudgetCategoriesArgs
    recurringTransactions?: boolean | CategoryCountOutputTypeCountRecurringTransactionsArgs
    gratitudeEntries?: boolean | CategoryCountOutputTypeCountGratitudeEntriesArgs
    transactionSuggestions?: boolean | CategoryCountOutputTypeCountTransactionSuggestionsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTransactionSplitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionSplitWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBudgetCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetCategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountRecurringTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountGratitudeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GratitudeEntryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTransactionSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionSuggestionWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    tags: number
    splits: number
    ledgerEntries: number
    recurringTransactionExecutions: number
    gratitudeEntries: number
    createdFromSuggestion: number
    zakatPayments: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | TransactionCountOutputTypeCountTagsArgs
    splits?: boolean | TransactionCountOutputTypeCountSplitsArgs
    ledgerEntries?: boolean | TransactionCountOutputTypeCountLedgerEntriesArgs
    recurringTransactionExecutions?: boolean | TransactionCountOutputTypeCountRecurringTransactionExecutionsArgs
    gratitudeEntries?: boolean | TransactionCountOutputTypeCountGratitudeEntriesArgs
    createdFromSuggestion?: boolean | TransactionCountOutputTypeCountCreatedFromSuggestionArgs
    zakatPayments?: boolean | TransactionCountOutputTypeCountZakatPaymentsArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionTagWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountSplitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionSplitWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountRecurringTransactionExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionExecutionWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountGratitudeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GratitudeEntryWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountCreatedFromSuggestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionSuggestionWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountZakatPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatPaymentWhereInput
  }


  /**
   * Count Type DebtCountOutputType
   */

  export type DebtCountOutputType = {
    payments: number
  }

  export type DebtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | DebtCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtCountOutputType
     */
    select?: DebtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DebtCountOutputType without action
   */
  export type DebtCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtPaymentWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    categories: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | BudgetCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetCategoryWhereInput
  }


  /**
   * Count Type WishlistItemCountOutputType
   */

  export type WishlistItemCountOutputType = {
    priceHistory: number
  }

  export type WishlistItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceHistory?: boolean | WishlistItemCountOutputTypeCountPriceHistoryArgs
  }

  // Custom InputTypes
  /**
   * WishlistItemCountOutputType without action
   */
  export type WishlistItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItemCountOutputType
     */
    select?: WishlistItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WishlistItemCountOutputType without action
   */
  export type WishlistItemCountOutputTypeCountPriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
  }


  /**
   * Count Type RecurringTransactionCountOutputType
   */

  export type RecurringTransactionCountOutputType = {
    executions: number
  }

  export type RecurringTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | RecurringTransactionCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * RecurringTransactionCountOutputType without action
   */
  export type RecurringTransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionCountOutputType
     */
    select?: RecurringTransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecurringTransactionCountOutputType without action
   */
  export type RecurringTransactionCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionExecutionWhereInput
  }


  /**
   * Count Type DocumentUploadCountOutputType
   */

  export type DocumentUploadCountOutputType = {
    ocrResults: number
    transactionSuggestions: number
  }

  export type DocumentUploadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ocrResults?: boolean | DocumentUploadCountOutputTypeCountOcrResultsArgs
    transactionSuggestions?: boolean | DocumentUploadCountOutputTypeCountTransactionSuggestionsArgs
  }

  // Custom InputTypes
  /**
   * DocumentUploadCountOutputType without action
   */
  export type DocumentUploadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUploadCountOutputType
     */
    select?: DocumentUploadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentUploadCountOutputType without action
   */
  export type DocumentUploadCountOutputTypeCountOcrResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OcrResultWhereInput
  }

  /**
   * DocumentUploadCountOutputType without action
   */
  export type DocumentUploadCountOutputTypeCountTransactionSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionSuggestionWhereInput
  }


  /**
   * Count Type OcrResultCountOutputType
   */

  export type OcrResultCountOutputType = {
    transactionSuggestions: number
  }

  export type OcrResultCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionSuggestions?: boolean | OcrResultCountOutputTypeCountTransactionSuggestionsArgs
  }

  // Custom InputTypes
  /**
   * OcrResultCountOutputType without action
   */
  export type OcrResultCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResultCountOutputType
     */
    select?: OcrResultCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OcrResultCountOutputType without action
   */
  export type OcrResultCountOutputTypeCountTransactionSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionSuggestionWhereInput
  }


  /**
   * Count Type ZakatCalculationCountOutputType
   */

  export type ZakatCalculationCountOutputType = {
    assetBreakdown: number
    zakatPayments: number
  }

  export type ZakatCalculationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assetBreakdown?: boolean | ZakatCalculationCountOutputTypeCountAssetBreakdownArgs
    zakatPayments?: boolean | ZakatCalculationCountOutputTypeCountZakatPaymentsArgs
  }

  // Custom InputTypes
  /**
   * ZakatCalculationCountOutputType without action
   */
  export type ZakatCalculationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculationCountOutputType
     */
    select?: ZakatCalculationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZakatCalculationCountOutputType without action
   */
  export type ZakatCalculationCountOutputTypeCountAssetBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatAssetBreakdownWhereInput
  }

  /**
   * ZakatCalculationCountOutputType without action
   */
  export type ZakatCalculationCountOutputTypeCountZakatPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatPaymentWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    deliveries: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | NotificationCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationDeliveryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    avatarUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    avatarUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    avatarUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    name: string
    avatarUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    householdMembers?: boolean | User$householdMembersArgs<ExtArgs>
    passkeys?: boolean | User$passkeysArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    createdTransactions?: boolean | User$createdTransactionsArgs<ExtArgs>
    createdWishlistItems?: boolean | User$createdWishlistItemsArgs<ExtArgs>
    createdGratitudeEntries?: boolean | User$createdGratitudeEntriesArgs<ExtArgs>
    createdRecurringTransactions?: boolean | User$createdRecurringTransactionsArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    userEvents?: boolean | User$userEventsArgs<ExtArgs>
    shariaReviews?: boolean | User$shariaReviewsArgs<ExtArgs>
    generatedIslamicReports?: boolean | User$generatedIslamicReportsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "name" | "avatarUrl" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    householdMembers?: boolean | User$householdMembersArgs<ExtArgs>
    passkeys?: boolean | User$passkeysArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    createdTransactions?: boolean | User$createdTransactionsArgs<ExtArgs>
    createdWishlistItems?: boolean | User$createdWishlistItemsArgs<ExtArgs>
    createdGratitudeEntries?: boolean | User$createdGratitudeEntriesArgs<ExtArgs>
    createdRecurringTransactions?: boolean | User$createdRecurringTransactionsArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    userEvents?: boolean | User$userEventsArgs<ExtArgs>
    shariaReviews?: boolean | User$shariaReviewsArgs<ExtArgs>
    generatedIslamicReports?: boolean | User$generatedIslamicReportsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      householdMembers: Prisma.$HouseholdMemberPayload<ExtArgs>[]
      passkeys: Prisma.$PasskeyPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      createdTransactions: Prisma.$TransactionPayload<ExtArgs>[]
      createdWishlistItems: Prisma.$WishlistItemPayload<ExtArgs>[]
      createdGratitudeEntries: Prisma.$GratitudeEntryPayload<ExtArgs>[]
      createdRecurringTransactions: Prisma.$RecurringTransactionPayload<ExtArgs>[]
      uploadedDocuments: Prisma.$DocumentUploadPayload<ExtArgs>[]
      userEvents: Prisma.$UserEventPayload<ExtArgs>[]
      shariaReviews: Prisma.$ShariaCompliantAccountPayload<ExtArgs>[]
      generatedIslamicReports: Prisma.$IslamicFinanceReportPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      notificationPreferences: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      pushSubscriptions: Prisma.$PushSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      name: string
      avatarUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    householdMembers<T extends User$householdMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$householdMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passkeys<T extends User$passkeysArgs<ExtArgs> = {}>(args?: Subset<T, User$passkeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTransactions<T extends User$createdTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdWishlistItems<T extends User$createdWishlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdWishlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdGratitudeEntries<T extends User$createdGratitudeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdGratitudeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdRecurringTransactions<T extends User$createdRecurringTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRecurringTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedDocuments<T extends User$uploadedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userEvents<T extends User$userEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$userEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shariaReviews<T extends User$shariaReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$shariaReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedIslamicReports<T extends User$generatedIslamicReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$generatedIslamicReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPreferences<T extends User$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferencesArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pushSubscriptions<T extends User$pushSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$pushSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.householdMembers
   */
  export type User$householdMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    where?: HouseholdMemberWhereInput
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    cursor?: HouseholdMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * User.passkeys
   */
  export type User$passkeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    where?: PasskeyWhereInput
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    cursor?: PasskeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.createdTransactions
   */
  export type User$createdTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.createdWishlistItems
   */
  export type User$createdWishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * User.createdGratitudeEntries
   */
  export type User$createdGratitudeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    where?: GratitudeEntryWhereInput
    orderBy?: GratitudeEntryOrderByWithRelationInput | GratitudeEntryOrderByWithRelationInput[]
    cursor?: GratitudeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GratitudeEntryScalarFieldEnum | GratitudeEntryScalarFieldEnum[]
  }

  /**
   * User.createdRecurringTransactions
   */
  export type User$createdRecurringTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    where?: RecurringTransactionWhereInput
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    cursor?: RecurringTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringTransactionScalarFieldEnum | RecurringTransactionScalarFieldEnum[]
  }

  /**
   * User.uploadedDocuments
   */
  export type User$uploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    where?: DocumentUploadWhereInput
    orderBy?: DocumentUploadOrderByWithRelationInput | DocumentUploadOrderByWithRelationInput[]
    cursor?: DocumentUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentUploadScalarFieldEnum | DocumentUploadScalarFieldEnum[]
  }

  /**
   * User.userEvents
   */
  export type User$userEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    where?: UserEventWhereInput
    orderBy?: UserEventOrderByWithRelationInput | UserEventOrderByWithRelationInput[]
    cursor?: UserEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserEventScalarFieldEnum | UserEventScalarFieldEnum[]
  }

  /**
   * User.shariaReviews
   */
  export type User$shariaReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    where?: ShariaCompliantAccountWhereInput
    orderBy?: ShariaCompliantAccountOrderByWithRelationInput | ShariaCompliantAccountOrderByWithRelationInput[]
    cursor?: ShariaCompliantAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShariaCompliantAccountScalarFieldEnum | ShariaCompliantAccountScalarFieldEnum[]
  }

  /**
   * User.generatedIslamicReports
   */
  export type User$generatedIslamicReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    where?: IslamicFinanceReportWhereInput
    orderBy?: IslamicFinanceReportOrderByWithRelationInput | IslamicFinanceReportOrderByWithRelationInput[]
    cursor?: IslamicFinanceReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IslamicFinanceReportScalarFieldEnum | IslamicFinanceReportScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.notificationPreferences
   */
  export type User$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.pushSubscriptions
   */
  export type User$pushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Household
   */

  export type AggregateHousehold = {
    _count: HouseholdCountAggregateOutputType | null
    _min: HouseholdMinAggregateOutputType | null
    _max: HouseholdMaxAggregateOutputType | null
  }

  export type HouseholdMinAggregateOutputType = {
    id: string | null
    name: string | null
    baseCurrency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HouseholdMaxAggregateOutputType = {
    id: string | null
    name: string | null
    baseCurrency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HouseholdCountAggregateOutputType = {
    id: number
    name: number
    baseCurrency: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HouseholdMinAggregateInputType = {
    id?: true
    name?: true
    baseCurrency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HouseholdMaxAggregateInputType = {
    id?: true
    name?: true
    baseCurrency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HouseholdCountAggregateInputType = {
    id?: true
    name?: true
    baseCurrency?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HouseholdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Household to aggregate.
     */
    where?: HouseholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Households to fetch.
     */
    orderBy?: HouseholdOrderByWithRelationInput | HouseholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HouseholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Households from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Households.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Households
    **/
    _count?: true | HouseholdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HouseholdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HouseholdMaxAggregateInputType
  }

  export type GetHouseholdAggregateType<T extends HouseholdAggregateArgs> = {
        [P in keyof T & keyof AggregateHousehold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHousehold[P]>
      : GetScalarType<T[P], AggregateHousehold[P]>
  }




  export type HouseholdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdWhereInput
    orderBy?: HouseholdOrderByWithAggregationInput | HouseholdOrderByWithAggregationInput[]
    by: HouseholdScalarFieldEnum[] | HouseholdScalarFieldEnum
    having?: HouseholdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HouseholdCountAggregateInputType | true
    _min?: HouseholdMinAggregateInputType
    _max?: HouseholdMaxAggregateInputType
  }

  export type HouseholdGroupByOutputType = {
    id: string
    name: string
    baseCurrency: string
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: HouseholdCountAggregateOutputType | null
    _min: HouseholdMinAggregateOutputType | null
    _max: HouseholdMaxAggregateOutputType | null
  }

  type GetHouseholdGroupByPayload<T extends HouseholdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HouseholdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HouseholdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HouseholdGroupByOutputType[P]>
            : GetScalarType<T[P], HouseholdGroupByOutputType[P]>
        }
      >
    >


  export type HouseholdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseCurrency?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Household$membersArgs<ExtArgs>
    accounts?: boolean | Household$accountsArgs<ExtArgs>
    transactions?: boolean | Household$transactionsArgs<ExtArgs>
    debts?: boolean | Household$debtsArgs<ExtArgs>
    budgets?: boolean | Household$budgetsArgs<ExtArgs>
    wishlistItems?: boolean | Household$wishlistItemsArgs<ExtArgs>
    gratitudeEntries?: boolean | Household$gratitudeEntriesArgs<ExtArgs>
    categories?: boolean | Household$categoriesArgs<ExtArgs>
    recurringTransactions?: boolean | Household$recurringTransactionsArgs<ExtArgs>
    documentUploads?: boolean | Household$documentUploadsArgs<ExtArgs>
    userEvents?: boolean | Household$userEventsArgs<ExtArgs>
    spendingPatterns?: boolean | Household$spendingPatternsArgs<ExtArgs>
    financialInsights?: boolean | Household$financialInsightsArgs<ExtArgs>
    zakatCalculations?: boolean | Household$zakatCalculationsArgs<ExtArgs>
    zakatReminders?: boolean | Household$zakatRemindersArgs<ExtArgs>
    zakatPayments?: boolean | Household$zakatPaymentsArgs<ExtArgs>
    islamicFinanceReports?: boolean | Household$islamicFinanceReportsArgs<ExtArgs>
    notifications?: boolean | Household$notificationsArgs<ExtArgs>
    _count?: boolean | HouseholdCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["household"]>

  export type HouseholdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseCurrency?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["household"]>

  export type HouseholdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseCurrency?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["household"]>

  export type HouseholdSelectScalar = {
    id?: boolean
    name?: boolean
    baseCurrency?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HouseholdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "baseCurrency" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["household"]>
  export type HouseholdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Household$membersArgs<ExtArgs>
    accounts?: boolean | Household$accountsArgs<ExtArgs>
    transactions?: boolean | Household$transactionsArgs<ExtArgs>
    debts?: boolean | Household$debtsArgs<ExtArgs>
    budgets?: boolean | Household$budgetsArgs<ExtArgs>
    wishlistItems?: boolean | Household$wishlistItemsArgs<ExtArgs>
    gratitudeEntries?: boolean | Household$gratitudeEntriesArgs<ExtArgs>
    categories?: boolean | Household$categoriesArgs<ExtArgs>
    recurringTransactions?: boolean | Household$recurringTransactionsArgs<ExtArgs>
    documentUploads?: boolean | Household$documentUploadsArgs<ExtArgs>
    userEvents?: boolean | Household$userEventsArgs<ExtArgs>
    spendingPatterns?: boolean | Household$spendingPatternsArgs<ExtArgs>
    financialInsights?: boolean | Household$financialInsightsArgs<ExtArgs>
    zakatCalculations?: boolean | Household$zakatCalculationsArgs<ExtArgs>
    zakatReminders?: boolean | Household$zakatRemindersArgs<ExtArgs>
    zakatPayments?: boolean | Household$zakatPaymentsArgs<ExtArgs>
    islamicFinanceReports?: boolean | Household$islamicFinanceReportsArgs<ExtArgs>
    notifications?: boolean | Household$notificationsArgs<ExtArgs>
    _count?: boolean | HouseholdCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HouseholdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HouseholdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HouseholdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Household"
    objects: {
      members: Prisma.$HouseholdMemberPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      debts: Prisma.$DebtPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      wishlistItems: Prisma.$WishlistItemPayload<ExtArgs>[]
      gratitudeEntries: Prisma.$GratitudeEntryPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      recurringTransactions: Prisma.$RecurringTransactionPayload<ExtArgs>[]
      documentUploads: Prisma.$DocumentUploadPayload<ExtArgs>[]
      userEvents: Prisma.$UserEventPayload<ExtArgs>[]
      spendingPatterns: Prisma.$SpendingPatternPayload<ExtArgs>[]
      financialInsights: Prisma.$FinancialInsightPayload<ExtArgs>[]
      zakatCalculations: Prisma.$ZakatCalculationPayload<ExtArgs>[]
      zakatReminders: Prisma.$ZakatReminderPayload<ExtArgs>[]
      zakatPayments: Prisma.$ZakatPaymentPayload<ExtArgs>[]
      islamicFinanceReports: Prisma.$IslamicFinanceReportPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      baseCurrency: string
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["household"]>
    composites: {}
  }

  type HouseholdGetPayload<S extends boolean | null | undefined | HouseholdDefaultArgs> = $Result.GetResult<Prisma.$HouseholdPayload, S>

  type HouseholdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HouseholdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HouseholdCountAggregateInputType | true
    }

  export interface HouseholdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Household'], meta: { name: 'Household' } }
    /**
     * Find zero or one Household that matches the filter.
     * @param {HouseholdFindUniqueArgs} args - Arguments to find a Household
     * @example
     * // Get one Household
     * const household = await prisma.household.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HouseholdFindUniqueArgs>(args: SelectSubset<T, HouseholdFindUniqueArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Household that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HouseholdFindUniqueOrThrowArgs} args - Arguments to find a Household
     * @example
     * // Get one Household
     * const household = await prisma.household.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HouseholdFindUniqueOrThrowArgs>(args: SelectSubset<T, HouseholdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Household that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdFindFirstArgs} args - Arguments to find a Household
     * @example
     * // Get one Household
     * const household = await prisma.household.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HouseholdFindFirstArgs>(args?: SelectSubset<T, HouseholdFindFirstArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Household that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdFindFirstOrThrowArgs} args - Arguments to find a Household
     * @example
     * // Get one Household
     * const household = await prisma.household.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HouseholdFindFirstOrThrowArgs>(args?: SelectSubset<T, HouseholdFindFirstOrThrowArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Households that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Households
     * const households = await prisma.household.findMany()
     * 
     * // Get first 10 Households
     * const households = await prisma.household.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const householdWithIdOnly = await prisma.household.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HouseholdFindManyArgs>(args?: SelectSubset<T, HouseholdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Household.
     * @param {HouseholdCreateArgs} args - Arguments to create a Household.
     * @example
     * // Create one Household
     * const Household = await prisma.household.create({
     *   data: {
     *     // ... data to create a Household
     *   }
     * })
     * 
     */
    create<T extends HouseholdCreateArgs>(args: SelectSubset<T, HouseholdCreateArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Households.
     * @param {HouseholdCreateManyArgs} args - Arguments to create many Households.
     * @example
     * // Create many Households
     * const household = await prisma.household.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HouseholdCreateManyArgs>(args?: SelectSubset<T, HouseholdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Households and returns the data saved in the database.
     * @param {HouseholdCreateManyAndReturnArgs} args - Arguments to create many Households.
     * @example
     * // Create many Households
     * const household = await prisma.household.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Households and only return the `id`
     * const householdWithIdOnly = await prisma.household.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HouseholdCreateManyAndReturnArgs>(args?: SelectSubset<T, HouseholdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Household.
     * @param {HouseholdDeleteArgs} args - Arguments to delete one Household.
     * @example
     * // Delete one Household
     * const Household = await prisma.household.delete({
     *   where: {
     *     // ... filter to delete one Household
     *   }
     * })
     * 
     */
    delete<T extends HouseholdDeleteArgs>(args: SelectSubset<T, HouseholdDeleteArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Household.
     * @param {HouseholdUpdateArgs} args - Arguments to update one Household.
     * @example
     * // Update one Household
     * const household = await prisma.household.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HouseholdUpdateArgs>(args: SelectSubset<T, HouseholdUpdateArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Households.
     * @param {HouseholdDeleteManyArgs} args - Arguments to filter Households to delete.
     * @example
     * // Delete a few Households
     * const { count } = await prisma.household.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HouseholdDeleteManyArgs>(args?: SelectSubset<T, HouseholdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Households.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Households
     * const household = await prisma.household.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HouseholdUpdateManyArgs>(args: SelectSubset<T, HouseholdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Households and returns the data updated in the database.
     * @param {HouseholdUpdateManyAndReturnArgs} args - Arguments to update many Households.
     * @example
     * // Update many Households
     * const household = await prisma.household.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Households and only return the `id`
     * const householdWithIdOnly = await prisma.household.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HouseholdUpdateManyAndReturnArgs>(args: SelectSubset<T, HouseholdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Household.
     * @param {HouseholdUpsertArgs} args - Arguments to update or create a Household.
     * @example
     * // Update or create a Household
     * const household = await prisma.household.upsert({
     *   create: {
     *     // ... data to create a Household
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Household we want to update
     *   }
     * })
     */
    upsert<T extends HouseholdUpsertArgs>(args: SelectSubset<T, HouseholdUpsertArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Households.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdCountArgs} args - Arguments to filter Households to count.
     * @example
     * // Count the number of Households
     * const count = await prisma.household.count({
     *   where: {
     *     // ... the filter for the Households we want to count
     *   }
     * })
    **/
    count<T extends HouseholdCountArgs>(
      args?: Subset<T, HouseholdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HouseholdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Household.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HouseholdAggregateArgs>(args: Subset<T, HouseholdAggregateArgs>): Prisma.PrismaPromise<GetHouseholdAggregateType<T>>

    /**
     * Group by Household.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HouseholdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HouseholdGroupByArgs['orderBy'] }
        : { orderBy?: HouseholdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HouseholdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHouseholdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Household model
   */
  readonly fields: HouseholdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Household.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HouseholdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Household$membersArgs<ExtArgs> = {}>(args?: Subset<T, Household$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends Household$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Household$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Household$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Household$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    debts<T extends Household$debtsArgs<ExtArgs> = {}>(args?: Subset<T, Household$debtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgets<T extends Household$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Household$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wishlistItems<T extends Household$wishlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, Household$wishlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gratitudeEntries<T extends Household$gratitudeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Household$gratitudeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Household$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Household$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringTransactions<T extends Household$recurringTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Household$recurringTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentUploads<T extends Household$documentUploadsArgs<ExtArgs> = {}>(args?: Subset<T, Household$documentUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userEvents<T extends Household$userEventsArgs<ExtArgs> = {}>(args?: Subset<T, Household$userEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spendingPatterns<T extends Household$spendingPatternsArgs<ExtArgs> = {}>(args?: Subset<T, Household$spendingPatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialInsights<T extends Household$financialInsightsArgs<ExtArgs> = {}>(args?: Subset<T, Household$financialInsightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zakatCalculations<T extends Household$zakatCalculationsArgs<ExtArgs> = {}>(args?: Subset<T, Household$zakatCalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zakatReminders<T extends Household$zakatRemindersArgs<ExtArgs> = {}>(args?: Subset<T, Household$zakatRemindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zakatPayments<T extends Household$zakatPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Household$zakatPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    islamicFinanceReports<T extends Household$islamicFinanceReportsArgs<ExtArgs> = {}>(args?: Subset<T, Household$islamicFinanceReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Household$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Household$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Household model
   */
  interface HouseholdFieldRefs {
    readonly id: FieldRef<"Household", 'String'>
    readonly name: FieldRef<"Household", 'String'>
    readonly baseCurrency: FieldRef<"Household", 'String'>
    readonly settings: FieldRef<"Household", 'Json'>
    readonly createdAt: FieldRef<"Household", 'DateTime'>
    readonly updatedAt: FieldRef<"Household", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Household findUnique
   */
  export type HouseholdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Household to fetch.
     */
    where: HouseholdWhereUniqueInput
  }

  /**
   * Household findUniqueOrThrow
   */
  export type HouseholdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Household to fetch.
     */
    where: HouseholdWhereUniqueInput
  }

  /**
   * Household findFirst
   */
  export type HouseholdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Household to fetch.
     */
    where?: HouseholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Households to fetch.
     */
    orderBy?: HouseholdOrderByWithRelationInput | HouseholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Households.
     */
    cursor?: HouseholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Households from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Households.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Households.
     */
    distinct?: HouseholdScalarFieldEnum | HouseholdScalarFieldEnum[]
  }

  /**
   * Household findFirstOrThrow
   */
  export type HouseholdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Household to fetch.
     */
    where?: HouseholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Households to fetch.
     */
    orderBy?: HouseholdOrderByWithRelationInput | HouseholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Households.
     */
    cursor?: HouseholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Households from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Households.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Households.
     */
    distinct?: HouseholdScalarFieldEnum | HouseholdScalarFieldEnum[]
  }

  /**
   * Household findMany
   */
  export type HouseholdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Households to fetch.
     */
    where?: HouseholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Households to fetch.
     */
    orderBy?: HouseholdOrderByWithRelationInput | HouseholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Households.
     */
    cursor?: HouseholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Households from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Households.
     */
    skip?: number
    distinct?: HouseholdScalarFieldEnum | HouseholdScalarFieldEnum[]
  }

  /**
   * Household create
   */
  export type HouseholdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * The data needed to create a Household.
     */
    data: XOR<HouseholdCreateInput, HouseholdUncheckedCreateInput>
  }

  /**
   * Household createMany
   */
  export type HouseholdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Households.
     */
    data: HouseholdCreateManyInput | HouseholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Household createManyAndReturn
   */
  export type HouseholdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * The data used to create many Households.
     */
    data: HouseholdCreateManyInput | HouseholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Household update
   */
  export type HouseholdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * The data needed to update a Household.
     */
    data: XOR<HouseholdUpdateInput, HouseholdUncheckedUpdateInput>
    /**
     * Choose, which Household to update.
     */
    where: HouseholdWhereUniqueInput
  }

  /**
   * Household updateMany
   */
  export type HouseholdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Households.
     */
    data: XOR<HouseholdUpdateManyMutationInput, HouseholdUncheckedUpdateManyInput>
    /**
     * Filter which Households to update
     */
    where?: HouseholdWhereInput
    /**
     * Limit how many Households to update.
     */
    limit?: number
  }

  /**
   * Household updateManyAndReturn
   */
  export type HouseholdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * The data used to update Households.
     */
    data: XOR<HouseholdUpdateManyMutationInput, HouseholdUncheckedUpdateManyInput>
    /**
     * Filter which Households to update
     */
    where?: HouseholdWhereInput
    /**
     * Limit how many Households to update.
     */
    limit?: number
  }

  /**
   * Household upsert
   */
  export type HouseholdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * The filter to search for the Household to update in case it exists.
     */
    where: HouseholdWhereUniqueInput
    /**
     * In case the Household found by the `where` argument doesn't exist, create a new Household with this data.
     */
    create: XOR<HouseholdCreateInput, HouseholdUncheckedCreateInput>
    /**
     * In case the Household was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HouseholdUpdateInput, HouseholdUncheckedUpdateInput>
  }

  /**
   * Household delete
   */
  export type HouseholdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter which Household to delete.
     */
    where: HouseholdWhereUniqueInput
  }

  /**
   * Household deleteMany
   */
  export type HouseholdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Households to delete
     */
    where?: HouseholdWhereInput
    /**
     * Limit how many Households to delete.
     */
    limit?: number
  }

  /**
   * Household.members
   */
  export type Household$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    where?: HouseholdMemberWhereInput
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    cursor?: HouseholdMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * Household.accounts
   */
  export type Household$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Household.transactions
   */
  export type Household$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Household.debts
   */
  export type Household$debtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    cursor?: DebtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Household.budgets
   */
  export type Household$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Household.wishlistItems
   */
  export type Household$wishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * Household.gratitudeEntries
   */
  export type Household$gratitudeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    where?: GratitudeEntryWhereInput
    orderBy?: GratitudeEntryOrderByWithRelationInput | GratitudeEntryOrderByWithRelationInput[]
    cursor?: GratitudeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GratitudeEntryScalarFieldEnum | GratitudeEntryScalarFieldEnum[]
  }

  /**
   * Household.categories
   */
  export type Household$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Household.recurringTransactions
   */
  export type Household$recurringTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    where?: RecurringTransactionWhereInput
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    cursor?: RecurringTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringTransactionScalarFieldEnum | RecurringTransactionScalarFieldEnum[]
  }

  /**
   * Household.documentUploads
   */
  export type Household$documentUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    where?: DocumentUploadWhereInput
    orderBy?: DocumentUploadOrderByWithRelationInput | DocumentUploadOrderByWithRelationInput[]
    cursor?: DocumentUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentUploadScalarFieldEnum | DocumentUploadScalarFieldEnum[]
  }

  /**
   * Household.userEvents
   */
  export type Household$userEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    where?: UserEventWhereInput
    orderBy?: UserEventOrderByWithRelationInput | UserEventOrderByWithRelationInput[]
    cursor?: UserEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserEventScalarFieldEnum | UserEventScalarFieldEnum[]
  }

  /**
   * Household.spendingPatterns
   */
  export type Household$spendingPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    where?: SpendingPatternWhereInput
    orderBy?: SpendingPatternOrderByWithRelationInput | SpendingPatternOrderByWithRelationInput[]
    cursor?: SpendingPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendingPatternScalarFieldEnum | SpendingPatternScalarFieldEnum[]
  }

  /**
   * Household.financialInsights
   */
  export type Household$financialInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    where?: FinancialInsightWhereInput
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    cursor?: FinancialInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialInsightScalarFieldEnum | FinancialInsightScalarFieldEnum[]
  }

  /**
   * Household.zakatCalculations
   */
  export type Household$zakatCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    where?: ZakatCalculationWhereInput
    orderBy?: ZakatCalculationOrderByWithRelationInput | ZakatCalculationOrderByWithRelationInput[]
    cursor?: ZakatCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZakatCalculationScalarFieldEnum | ZakatCalculationScalarFieldEnum[]
  }

  /**
   * Household.zakatReminders
   */
  export type Household$zakatRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    where?: ZakatReminderWhereInput
    orderBy?: ZakatReminderOrderByWithRelationInput | ZakatReminderOrderByWithRelationInput[]
    cursor?: ZakatReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZakatReminderScalarFieldEnum | ZakatReminderScalarFieldEnum[]
  }

  /**
   * Household.zakatPayments
   */
  export type Household$zakatPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    where?: ZakatPaymentWhereInput
    orderBy?: ZakatPaymentOrderByWithRelationInput | ZakatPaymentOrderByWithRelationInput[]
    cursor?: ZakatPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZakatPaymentScalarFieldEnum | ZakatPaymentScalarFieldEnum[]
  }

  /**
   * Household.islamicFinanceReports
   */
  export type Household$islamicFinanceReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    where?: IslamicFinanceReportWhereInput
    orderBy?: IslamicFinanceReportOrderByWithRelationInput | IslamicFinanceReportOrderByWithRelationInput[]
    cursor?: IslamicFinanceReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IslamicFinanceReportScalarFieldEnum | IslamicFinanceReportScalarFieldEnum[]
  }

  /**
   * Household.notifications
   */
  export type Household$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Household without action
   */
  export type HouseholdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
  }


  /**
   * Model HouseholdMember
   */

  export type AggregateHouseholdMember = {
    _count: HouseholdMemberCountAggregateOutputType | null
    _min: HouseholdMemberMinAggregateOutputType | null
    _max: HouseholdMemberMaxAggregateOutputType | null
  }

  export type HouseholdMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    role: $Enums.HouseholdRole | null
    joinedAt: Date | null
  }

  export type HouseholdMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    role: $Enums.HouseholdRole | null
    joinedAt: Date | null
  }

  export type HouseholdMemberCountAggregateOutputType = {
    id: number
    userId: number
    householdId: number
    role: number
    permissions: number
    joinedAt: number
    _all: number
  }


  export type HouseholdMemberMinAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    role?: true
    joinedAt?: true
  }

  export type HouseholdMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    role?: true
    joinedAt?: true
  }

  export type HouseholdMemberCountAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    role?: true
    permissions?: true
    joinedAt?: true
    _all?: true
  }

  export type HouseholdMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HouseholdMember to aggregate.
     */
    where?: HouseholdMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseholdMembers to fetch.
     */
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HouseholdMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseholdMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseholdMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HouseholdMembers
    **/
    _count?: true | HouseholdMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HouseholdMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HouseholdMemberMaxAggregateInputType
  }

  export type GetHouseholdMemberAggregateType<T extends HouseholdMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateHouseholdMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHouseholdMember[P]>
      : GetScalarType<T[P], AggregateHouseholdMember[P]>
  }




  export type HouseholdMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdMemberWhereInput
    orderBy?: HouseholdMemberOrderByWithAggregationInput | HouseholdMemberOrderByWithAggregationInput[]
    by: HouseholdMemberScalarFieldEnum[] | HouseholdMemberScalarFieldEnum
    having?: HouseholdMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HouseholdMemberCountAggregateInputType | true
    _min?: HouseholdMemberMinAggregateInputType
    _max?: HouseholdMemberMaxAggregateInputType
  }

  export type HouseholdMemberGroupByOutputType = {
    id: string
    userId: string
    householdId: string
    role: $Enums.HouseholdRole
    permissions: JsonValue
    joinedAt: Date
    _count: HouseholdMemberCountAggregateOutputType | null
    _min: HouseholdMemberMinAggregateOutputType | null
    _max: HouseholdMemberMaxAggregateOutputType | null
  }

  type GetHouseholdMemberGroupByPayload<T extends HouseholdMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HouseholdMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HouseholdMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HouseholdMemberGroupByOutputType[P]>
            : GetScalarType<T[P], HouseholdMemberGroupByOutputType[P]>
        }
      >
    >


  export type HouseholdMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["householdMember"]>

  export type HouseholdMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["householdMember"]>

  export type HouseholdMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["householdMember"]>

  export type HouseholdMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    householdId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
  }

  export type HouseholdMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "householdId" | "role" | "permissions" | "joinedAt", ExtArgs["result"]["householdMember"]>
  export type HouseholdMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type HouseholdMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type HouseholdMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $HouseholdMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HouseholdMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      household: Prisma.$HouseholdPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      householdId: string
      role: $Enums.HouseholdRole
      permissions: Prisma.JsonValue
      joinedAt: Date
    }, ExtArgs["result"]["householdMember"]>
    composites: {}
  }

  type HouseholdMemberGetPayload<S extends boolean | null | undefined | HouseholdMemberDefaultArgs> = $Result.GetResult<Prisma.$HouseholdMemberPayload, S>

  type HouseholdMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HouseholdMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HouseholdMemberCountAggregateInputType | true
    }

  export interface HouseholdMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HouseholdMember'], meta: { name: 'HouseholdMember' } }
    /**
     * Find zero or one HouseholdMember that matches the filter.
     * @param {HouseholdMemberFindUniqueArgs} args - Arguments to find a HouseholdMember
     * @example
     * // Get one HouseholdMember
     * const householdMember = await prisma.householdMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HouseholdMemberFindUniqueArgs>(args: SelectSubset<T, HouseholdMemberFindUniqueArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HouseholdMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HouseholdMemberFindUniqueOrThrowArgs} args - Arguments to find a HouseholdMember
     * @example
     * // Get one HouseholdMember
     * const householdMember = await prisma.householdMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HouseholdMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, HouseholdMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HouseholdMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberFindFirstArgs} args - Arguments to find a HouseholdMember
     * @example
     * // Get one HouseholdMember
     * const householdMember = await prisma.householdMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HouseholdMemberFindFirstArgs>(args?: SelectSubset<T, HouseholdMemberFindFirstArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HouseholdMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberFindFirstOrThrowArgs} args - Arguments to find a HouseholdMember
     * @example
     * // Get one HouseholdMember
     * const householdMember = await prisma.householdMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HouseholdMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, HouseholdMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HouseholdMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HouseholdMembers
     * const householdMembers = await prisma.householdMember.findMany()
     * 
     * // Get first 10 HouseholdMembers
     * const householdMembers = await prisma.householdMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const householdMemberWithIdOnly = await prisma.householdMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HouseholdMemberFindManyArgs>(args?: SelectSubset<T, HouseholdMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HouseholdMember.
     * @param {HouseholdMemberCreateArgs} args - Arguments to create a HouseholdMember.
     * @example
     * // Create one HouseholdMember
     * const HouseholdMember = await prisma.householdMember.create({
     *   data: {
     *     // ... data to create a HouseholdMember
     *   }
     * })
     * 
     */
    create<T extends HouseholdMemberCreateArgs>(args: SelectSubset<T, HouseholdMemberCreateArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HouseholdMembers.
     * @param {HouseholdMemberCreateManyArgs} args - Arguments to create many HouseholdMembers.
     * @example
     * // Create many HouseholdMembers
     * const householdMember = await prisma.householdMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HouseholdMemberCreateManyArgs>(args?: SelectSubset<T, HouseholdMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HouseholdMembers and returns the data saved in the database.
     * @param {HouseholdMemberCreateManyAndReturnArgs} args - Arguments to create many HouseholdMembers.
     * @example
     * // Create many HouseholdMembers
     * const householdMember = await prisma.householdMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HouseholdMembers and only return the `id`
     * const householdMemberWithIdOnly = await prisma.householdMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HouseholdMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, HouseholdMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HouseholdMember.
     * @param {HouseholdMemberDeleteArgs} args - Arguments to delete one HouseholdMember.
     * @example
     * // Delete one HouseholdMember
     * const HouseholdMember = await prisma.householdMember.delete({
     *   where: {
     *     // ... filter to delete one HouseholdMember
     *   }
     * })
     * 
     */
    delete<T extends HouseholdMemberDeleteArgs>(args: SelectSubset<T, HouseholdMemberDeleteArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HouseholdMember.
     * @param {HouseholdMemberUpdateArgs} args - Arguments to update one HouseholdMember.
     * @example
     * // Update one HouseholdMember
     * const householdMember = await prisma.householdMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HouseholdMemberUpdateArgs>(args: SelectSubset<T, HouseholdMemberUpdateArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HouseholdMembers.
     * @param {HouseholdMemberDeleteManyArgs} args - Arguments to filter HouseholdMembers to delete.
     * @example
     * // Delete a few HouseholdMembers
     * const { count } = await prisma.householdMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HouseholdMemberDeleteManyArgs>(args?: SelectSubset<T, HouseholdMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HouseholdMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HouseholdMembers
     * const householdMember = await prisma.householdMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HouseholdMemberUpdateManyArgs>(args: SelectSubset<T, HouseholdMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HouseholdMembers and returns the data updated in the database.
     * @param {HouseholdMemberUpdateManyAndReturnArgs} args - Arguments to update many HouseholdMembers.
     * @example
     * // Update many HouseholdMembers
     * const householdMember = await prisma.householdMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HouseholdMembers and only return the `id`
     * const householdMemberWithIdOnly = await prisma.householdMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HouseholdMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, HouseholdMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HouseholdMember.
     * @param {HouseholdMemberUpsertArgs} args - Arguments to update or create a HouseholdMember.
     * @example
     * // Update or create a HouseholdMember
     * const householdMember = await prisma.householdMember.upsert({
     *   create: {
     *     // ... data to create a HouseholdMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HouseholdMember we want to update
     *   }
     * })
     */
    upsert<T extends HouseholdMemberUpsertArgs>(args: SelectSubset<T, HouseholdMemberUpsertArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HouseholdMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberCountArgs} args - Arguments to filter HouseholdMembers to count.
     * @example
     * // Count the number of HouseholdMembers
     * const count = await prisma.householdMember.count({
     *   where: {
     *     // ... the filter for the HouseholdMembers we want to count
     *   }
     * })
    **/
    count<T extends HouseholdMemberCountArgs>(
      args?: Subset<T, HouseholdMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HouseholdMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HouseholdMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HouseholdMemberAggregateArgs>(args: Subset<T, HouseholdMemberAggregateArgs>): Prisma.PrismaPromise<GetHouseholdMemberAggregateType<T>>

    /**
     * Group by HouseholdMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HouseholdMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HouseholdMemberGroupByArgs['orderBy'] }
        : { orderBy?: HouseholdMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HouseholdMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHouseholdMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HouseholdMember model
   */
  readonly fields: HouseholdMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HouseholdMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HouseholdMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HouseholdMember model
   */
  interface HouseholdMemberFieldRefs {
    readonly id: FieldRef<"HouseholdMember", 'String'>
    readonly userId: FieldRef<"HouseholdMember", 'String'>
    readonly householdId: FieldRef<"HouseholdMember", 'String'>
    readonly role: FieldRef<"HouseholdMember", 'HouseholdRole'>
    readonly permissions: FieldRef<"HouseholdMember", 'Json'>
    readonly joinedAt: FieldRef<"HouseholdMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HouseholdMember findUnique
   */
  export type HouseholdMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMember to fetch.
     */
    where: HouseholdMemberWhereUniqueInput
  }

  /**
   * HouseholdMember findUniqueOrThrow
   */
  export type HouseholdMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMember to fetch.
     */
    where: HouseholdMemberWhereUniqueInput
  }

  /**
   * HouseholdMember findFirst
   */
  export type HouseholdMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMember to fetch.
     */
    where?: HouseholdMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseholdMembers to fetch.
     */
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HouseholdMembers.
     */
    cursor?: HouseholdMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseholdMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseholdMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HouseholdMembers.
     */
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * HouseholdMember findFirstOrThrow
   */
  export type HouseholdMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMember to fetch.
     */
    where?: HouseholdMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseholdMembers to fetch.
     */
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HouseholdMembers.
     */
    cursor?: HouseholdMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseholdMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseholdMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HouseholdMembers.
     */
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * HouseholdMember findMany
   */
  export type HouseholdMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMembers to fetch.
     */
    where?: HouseholdMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseholdMembers to fetch.
     */
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HouseholdMembers.
     */
    cursor?: HouseholdMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseholdMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseholdMembers.
     */
    skip?: number
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * HouseholdMember create
   */
  export type HouseholdMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a HouseholdMember.
     */
    data: XOR<HouseholdMemberCreateInput, HouseholdMemberUncheckedCreateInput>
  }

  /**
   * HouseholdMember createMany
   */
  export type HouseholdMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HouseholdMembers.
     */
    data: HouseholdMemberCreateManyInput | HouseholdMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HouseholdMember createManyAndReturn
   */
  export type HouseholdMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * The data used to create many HouseholdMembers.
     */
    data: HouseholdMemberCreateManyInput | HouseholdMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HouseholdMember update
   */
  export type HouseholdMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a HouseholdMember.
     */
    data: XOR<HouseholdMemberUpdateInput, HouseholdMemberUncheckedUpdateInput>
    /**
     * Choose, which HouseholdMember to update.
     */
    where: HouseholdMemberWhereUniqueInput
  }

  /**
   * HouseholdMember updateMany
   */
  export type HouseholdMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HouseholdMembers.
     */
    data: XOR<HouseholdMemberUpdateManyMutationInput, HouseholdMemberUncheckedUpdateManyInput>
    /**
     * Filter which HouseholdMembers to update
     */
    where?: HouseholdMemberWhereInput
    /**
     * Limit how many HouseholdMembers to update.
     */
    limit?: number
  }

  /**
   * HouseholdMember updateManyAndReturn
   */
  export type HouseholdMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * The data used to update HouseholdMembers.
     */
    data: XOR<HouseholdMemberUpdateManyMutationInput, HouseholdMemberUncheckedUpdateManyInput>
    /**
     * Filter which HouseholdMembers to update
     */
    where?: HouseholdMemberWhereInput
    /**
     * Limit how many HouseholdMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HouseholdMember upsert
   */
  export type HouseholdMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the HouseholdMember to update in case it exists.
     */
    where: HouseholdMemberWhereUniqueInput
    /**
     * In case the HouseholdMember found by the `where` argument doesn't exist, create a new HouseholdMember with this data.
     */
    create: XOR<HouseholdMemberCreateInput, HouseholdMemberUncheckedCreateInput>
    /**
     * In case the HouseholdMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HouseholdMemberUpdateInput, HouseholdMemberUncheckedUpdateInput>
  }

  /**
   * HouseholdMember delete
   */
  export type HouseholdMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter which HouseholdMember to delete.
     */
    where: HouseholdMemberWhereUniqueInput
  }

  /**
   * HouseholdMember deleteMany
   */
  export type HouseholdMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HouseholdMembers to delete
     */
    where?: HouseholdMemberWhereInput
    /**
     * Limit how many HouseholdMembers to delete.
     */
    limit?: number
  }

  /**
   * HouseholdMember without action
   */
  export type HouseholdMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HouseholdMember
     */
    omit?: HouseholdMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
  }


  /**
   * Model Institution
   */

  export type AggregateInstitution = {
    _count: InstitutionCountAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  export type InstitutionMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    logoUrl: string | null
    country: string | null
    type: $Enums.InstitutionType | null
    createdAt: Date | null
  }

  export type InstitutionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    logoUrl: string | null
    country: string | null
    type: $Enums.InstitutionType | null
    createdAt: Date | null
  }

  export type InstitutionCountAggregateOutputType = {
    id: number
    name: number
    code: number
    logoUrl: number
    country: number
    type: number
    createdAt: number
    _all: number
  }


  export type InstitutionMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logoUrl?: true
    country?: true
    type?: true
    createdAt?: true
  }

  export type InstitutionMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logoUrl?: true
    country?: true
    type?: true
    createdAt?: true
  }

  export type InstitutionCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    logoUrl?: true
    country?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type InstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institution to aggregate.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutions
    **/
    _count?: true | InstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionMaxAggregateInputType
  }

  export type GetInstitutionAggregateType<T extends InstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution[P]>
      : GetScalarType<T[P], AggregateInstitution[P]>
  }




  export type InstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithAggregationInput | InstitutionOrderByWithAggregationInput[]
    by: InstitutionScalarFieldEnum[] | InstitutionScalarFieldEnum
    having?: InstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionCountAggregateInputType | true
    _min?: InstitutionMinAggregateInputType
    _max?: InstitutionMaxAggregateInputType
  }

  export type InstitutionGroupByOutputType = {
    id: string
    name: string
    code: string | null
    logoUrl: string | null
    country: string
    type: $Enums.InstitutionType
    createdAt: Date
    _count: InstitutionCountAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  type GetInstitutionGroupByPayload<T extends InstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    country?: boolean
    type?: boolean
    createdAt?: boolean
    accounts?: boolean | Institution$accountsArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    country?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    country?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    logoUrl?: boolean
    country?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type InstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "logoUrl" | "country" | "type" | "createdAt", ExtArgs["result"]["institution"]>
  export type InstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | Institution$accountsArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstitutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InstitutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institution"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      logoUrl: string | null
      country: string
      type: $Enums.InstitutionType
      createdAt: Date
    }, ExtArgs["result"]["institution"]>
    composites: {}
  }

  type InstitutionGetPayload<S extends boolean | null | undefined | InstitutionDefaultArgs> = $Result.GetResult<Prisma.$InstitutionPayload, S>

  type InstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionCountAggregateInputType | true
    }

  export interface InstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institution'], meta: { name: 'Institution' } }
    /**
     * Find zero or one Institution that matches the filter.
     * @param {InstitutionFindUniqueArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionFindUniqueArgs>(args: SelectSubset<T, InstitutionFindUniqueArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionFindUniqueOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionFindFirstArgs>(args?: SelectSubset<T, InstitutionFindFirstArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institution.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionWithIdOnly = await prisma.institution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionFindManyArgs>(args?: SelectSubset<T, InstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution.
     * @param {InstitutionCreateArgs} args - Arguments to create a Institution.
     * @example
     * // Create one Institution
     * const Institution = await prisma.institution.create({
     *   data: {
     *     // ... data to create a Institution
     *   }
     * })
     * 
     */
    create<T extends InstitutionCreateArgs>(args: SelectSubset<T, InstitutionCreateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutions.
     * @param {InstitutionCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionCreateManyArgs>(args?: SelectSubset<T, InstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Institutions and returns the data saved in the database.
     * @param {InstitutionCreateManyAndReturnArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Institutions and only return the `id`
     * const institutionWithIdOnly = await prisma.institution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstitutionCreateManyAndReturnArgs>(args?: SelectSubset<T, InstitutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Institution.
     * @param {InstitutionDeleteArgs} args - Arguments to delete one Institution.
     * @example
     * // Delete one Institution
     * const Institution = await prisma.institution.delete({
     *   where: {
     *     // ... filter to delete one Institution
     *   }
     * })
     * 
     */
    delete<T extends InstitutionDeleteArgs>(args: SelectSubset<T, InstitutionDeleteArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution.
     * @param {InstitutionUpdateArgs} args - Arguments to update one Institution.
     * @example
     * // Update one Institution
     * const institution = await prisma.institution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionUpdateArgs>(args: SelectSubset<T, InstitutionUpdateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutions.
     * @param {InstitutionDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionDeleteManyArgs>(args?: SelectSubset<T, InstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionUpdateManyArgs>(args: SelectSubset<T, InstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions and returns the data updated in the database.
     * @param {InstitutionUpdateManyAndReturnArgs} args - Arguments to update many Institutions.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Institutions and only return the `id`
     * const institutionWithIdOnly = await prisma.institution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstitutionUpdateManyAndReturnArgs>(args: SelectSubset<T, InstitutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Institution.
     * @param {InstitutionUpsertArgs} args - Arguments to update or create a Institution.
     * @example
     * // Update or create a Institution
     * const institution = await prisma.institution.upsert({
     *   create: {
     *     // ... data to create a Institution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionUpsertArgs>(args: SelectSubset<T, InstitutionUpsertArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institution.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends InstitutionCountArgs>(
      args?: Subset<T, InstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionAggregateArgs>(args: Subset<T, InstitutionAggregateArgs>): Prisma.PrismaPromise<GetInstitutionAggregateType<T>>

    /**
     * Group by Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institution model
   */
  readonly fields: InstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends Institution$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Institution model
   */
  interface InstitutionFieldRefs {
    readonly id: FieldRef<"Institution", 'String'>
    readonly name: FieldRef<"Institution", 'String'>
    readonly code: FieldRef<"Institution", 'String'>
    readonly logoUrl: FieldRef<"Institution", 'String'>
    readonly country: FieldRef<"Institution", 'String'>
    readonly type: FieldRef<"Institution", 'InstitutionType'>
    readonly createdAt: FieldRef<"Institution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Institution findUnique
   */
  export type InstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findUniqueOrThrow
   */
  export type InstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findFirst
   */
  export type InstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findFirstOrThrow
   */
  export type InstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findMany
   */
  export type InstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institutions to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution create
   */
  export type InstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Institution.
     */
    data: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
  }

  /**
   * Institution createMany
   */
  export type InstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institution createManyAndReturn
   */
  export type InstitutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institution update
   */
  export type InstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Institution.
     */
    data: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
    /**
     * Choose, which Institution to update.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution updateMany
   */
  export type InstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
  }

  /**
   * Institution updateManyAndReturn
   */
  export type InstitutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
  }

  /**
   * Institution upsert
   */
  export type InstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Institution to update in case it exists.
     */
    where: InstitutionWhereUniqueInput
    /**
     * In case the Institution found by the `where` argument doesn't exist, create a new Institution with this data.
     */
    create: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
    /**
     * In case the Institution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
  }

  /**
   * Institution delete
   */
  export type InstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter which Institution to delete.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution deleteMany
   */
  export type InstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutions to delete
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to delete.
     */
    limit?: number
  }

  /**
   * Institution.accounts
   */
  export type Institution$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Institution without action
   */
  export type InstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    balanceCents: number | null
  }

  export type AccountSumAggregateOutputType = {
    balanceCents: bigint | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    name: string | null
    type: $Enums.AccountType | null
    subtype: string | null
    currency: string | null
    institutionId: string | null
    accountNumber: string | null
    balanceCents: bigint | null
    isActive: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    name: string | null
    type: $Enums.AccountType | null
    subtype: string | null
    currency: string | null
    institutionId: string | null
    accountNumber: string | null
    balanceCents: bigint | null
    isActive: boolean | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    householdId: number
    name: number
    type: number
    subtype: number
    currency: number
    institutionId: number
    accountNumber: number
    balanceCents: number
    isActive: number
    ownerId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    balanceCents?: true
  }

  export type AccountSumAggregateInputType = {
    balanceCents?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    type?: true
    subtype?: true
    currency?: true
    institutionId?: true
    accountNumber?: true
    balanceCents?: true
    isActive?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    type?: true
    subtype?: true
    currency?: true
    institutionId?: true
    accountNumber?: true
    balanceCents?: true
    isActive?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    type?: true
    subtype?: true
    currency?: true
    institutionId?: true
    accountNumber?: true
    balanceCents?: true
    isActive?: true
    ownerId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency: string
    institutionId: string | null
    accountNumber: string | null
    balanceCents: bigint
    isActive: boolean
    ownerId: string | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    type?: boolean
    subtype?: boolean
    currency?: boolean
    institutionId?: boolean
    accountNumber?: boolean
    balanceCents?: boolean
    isActive?: boolean
    ownerId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    institution?: boolean | Account$institutionArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    transferTransactions?: boolean | Account$transferTransactionsArgs<ExtArgs>
    recurringTransactions?: boolean | Account$recurringTransactionsArgs<ExtArgs>
    recurringTransferTransactions?: boolean | Account$recurringTransferTransactionsArgs<ExtArgs>
    ledgerEntries?: boolean | Account$ledgerEntriesArgs<ExtArgs>
    zakatAssetBreakdown?: boolean | Account$zakatAssetBreakdownArgs<ExtArgs>
    shariaCompliance?: boolean | Account$shariaComplianceArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    type?: boolean
    subtype?: boolean
    currency?: boolean
    institutionId?: boolean
    accountNumber?: boolean
    balanceCents?: boolean
    isActive?: boolean
    ownerId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    institution?: boolean | Account$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    type?: boolean
    subtype?: boolean
    currency?: boolean
    institutionId?: boolean
    accountNumber?: boolean
    balanceCents?: boolean
    isActive?: boolean
    ownerId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    institution?: boolean | Account$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    householdId?: boolean
    name?: boolean
    type?: boolean
    subtype?: boolean
    currency?: boolean
    institutionId?: boolean
    accountNumber?: boolean
    balanceCents?: boolean
    isActive?: boolean
    ownerId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "name" | "type" | "subtype" | "currency" | "institutionId" | "accountNumber" | "balanceCents" | "isActive" | "ownerId" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    institution?: boolean | Account$institutionArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    transferTransactions?: boolean | Account$transferTransactionsArgs<ExtArgs>
    recurringTransactions?: boolean | Account$recurringTransactionsArgs<ExtArgs>
    recurringTransferTransactions?: boolean | Account$recurringTransferTransactionsArgs<ExtArgs>
    ledgerEntries?: boolean | Account$ledgerEntriesArgs<ExtArgs>
    zakatAssetBreakdown?: boolean | Account$zakatAssetBreakdownArgs<ExtArgs>
    shariaCompliance?: boolean | Account$shariaComplianceArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    institution?: boolean | Account$institutionArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    institution?: boolean | Account$institutionArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      transferTransactions: Prisma.$TransactionPayload<ExtArgs>[]
      recurringTransactions: Prisma.$RecurringTransactionPayload<ExtArgs>[]
      recurringTransferTransactions: Prisma.$RecurringTransactionPayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      zakatAssetBreakdown: Prisma.$ZakatAssetBreakdownPayload<ExtArgs>[]
      shariaCompliance: Prisma.$ShariaCompliantAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      name: string
      type: $Enums.AccountType
      subtype: string
      currency: string
      institutionId: string | null
      accountNumber: string | null
      balanceCents: bigint
      isActive: boolean
      ownerId: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends Account$institutionArgs<ExtArgs> = {}>(args?: Subset<T, Account$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Account$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transferTransactions<T extends Account$transferTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$transferTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringTransactions<T extends Account$recurringTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$recurringTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringTransferTransactions<T extends Account$recurringTransferTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$recurringTransferTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ledgerEntries<T extends Account$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Account$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zakatAssetBreakdown<T extends Account$zakatAssetBreakdownArgs<ExtArgs> = {}>(args?: Subset<T, Account$zakatAssetBreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shariaCompliance<T extends Account$shariaComplianceArgs<ExtArgs> = {}>(args?: Subset<T, Account$shariaComplianceArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly householdId: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'AccountType'>
    readonly subtype: FieldRef<"Account", 'String'>
    readonly currency: FieldRef<"Account", 'String'>
    readonly institutionId: FieldRef<"Account", 'String'>
    readonly accountNumber: FieldRef<"Account", 'String'>
    readonly balanceCents: FieldRef<"Account", 'BigInt'>
    readonly isActive: FieldRef<"Account", 'Boolean'>
    readonly ownerId: FieldRef<"Account", 'String'>
    readonly metadata: FieldRef<"Account", 'Json'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.institution
   */
  export type Account$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * Account.transactions
   */
  export type Account$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account.transferTransactions
   */
  export type Account$transferTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account.recurringTransactions
   */
  export type Account$recurringTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    where?: RecurringTransactionWhereInput
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    cursor?: RecurringTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringTransactionScalarFieldEnum | RecurringTransactionScalarFieldEnum[]
  }

  /**
   * Account.recurringTransferTransactions
   */
  export type Account$recurringTransferTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    where?: RecurringTransactionWhereInput
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    cursor?: RecurringTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringTransactionScalarFieldEnum | RecurringTransactionScalarFieldEnum[]
  }

  /**
   * Account.ledgerEntries
   */
  export type Account$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Account.zakatAssetBreakdown
   */
  export type Account$zakatAssetBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    where?: ZakatAssetBreakdownWhereInput
    orderBy?: ZakatAssetBreakdownOrderByWithRelationInput | ZakatAssetBreakdownOrderByWithRelationInput[]
    cursor?: ZakatAssetBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZakatAssetBreakdownScalarFieldEnum | ZakatAssetBreakdownScalarFieldEnum[]
  }

  /**
   * Account.shariaCompliance
   */
  export type Account$shariaComplianceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    where?: ShariaCompliantAccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Merchant
   */

  export type AggregateMerchant = {
    _count: MerchantCountAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  export type MerchantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logoUrl: string | null
    color: string | null
    createdAt: Date | null
  }

  export type MerchantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logoUrl: string | null
    color: string | null
    createdAt: Date | null
  }

  export type MerchantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logoUrl: number
    color: number
    createdAt: number
    _all: number
  }


  export type MerchantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    color?: true
    createdAt?: true
  }

  export type MerchantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    color?: true
    createdAt?: true
  }

  export type MerchantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type MerchantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchant to aggregate.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Merchants
    **/
    _count?: true | MerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantMaxAggregateInputType
  }

  export type GetMerchantAggregateType<T extends MerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchant[P]>
      : GetScalarType<T[P], AggregateMerchant[P]>
  }




  export type MerchantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantWhereInput
    orderBy?: MerchantOrderByWithAggregationInput | MerchantOrderByWithAggregationInput[]
    by: MerchantScalarFieldEnum[] | MerchantScalarFieldEnum
    having?: MerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantCountAggregateInputType | true
    _min?: MerchantMinAggregateInputType
    _max?: MerchantMaxAggregateInputType
  }

  export type MerchantGroupByOutputType = {
    id: string
    name: string
    slug: string
    logoUrl: string | null
    color: string | null
    createdAt: Date
    _count: MerchantCountAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  type GetMerchantGroupByPayload<T extends MerchantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantGroupByOutputType[P]>
        }
      >
    >


  export type MerchantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    color?: boolean
    createdAt?: boolean
    transactions?: boolean | Merchant$transactionsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type MerchantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "logoUrl" | "color" | "createdAt", ExtArgs["result"]["merchant"]>
  export type MerchantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Merchant$transactionsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MerchantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MerchantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MerchantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Merchant"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logoUrl: string | null
      color: string | null
      createdAt: Date
    }, ExtArgs["result"]["merchant"]>
    composites: {}
  }

  type MerchantGetPayload<S extends boolean | null | undefined | MerchantDefaultArgs> = $Result.GetResult<Prisma.$MerchantPayload, S>

  type MerchantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantCountAggregateInputType | true
    }

  export interface MerchantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Merchant'], meta: { name: 'Merchant' } }
    /**
     * Find zero or one Merchant that matches the filter.
     * @param {MerchantFindUniqueArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantFindUniqueArgs>(args: SelectSubset<T, MerchantFindUniqueArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Merchant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantFindUniqueOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantFindFirstArgs>(args?: SelectSubset<T, MerchantFindFirstArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchant.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantWithIdOnly = await prisma.merchant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantFindManyArgs>(args?: SelectSubset<T, MerchantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Merchant.
     * @param {MerchantCreateArgs} args - Arguments to create a Merchant.
     * @example
     * // Create one Merchant
     * const Merchant = await prisma.merchant.create({
     *   data: {
     *     // ... data to create a Merchant
     *   }
     * })
     * 
     */
    create<T extends MerchantCreateArgs>(args: SelectSubset<T, MerchantCreateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Merchants.
     * @param {MerchantCreateManyArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantCreateManyArgs>(args?: SelectSubset<T, MerchantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merchants and returns the data saved in the database.
     * @param {MerchantCreateManyAndReturnArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Merchant.
     * @param {MerchantDeleteArgs} args - Arguments to delete one Merchant.
     * @example
     * // Delete one Merchant
     * const Merchant = await prisma.merchant.delete({
     *   where: {
     *     // ... filter to delete one Merchant
     *   }
     * })
     * 
     */
    delete<T extends MerchantDeleteArgs>(args: SelectSubset<T, MerchantDeleteArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Merchant.
     * @param {MerchantUpdateArgs} args - Arguments to update one Merchant.
     * @example
     * // Update one Merchant
     * const merchant = await prisma.merchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantUpdateArgs>(args: SelectSubset<T, MerchantUpdateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Merchants.
     * @param {MerchantDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantDeleteManyArgs>(args?: SelectSubset<T, MerchantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantUpdateManyArgs>(args: SelectSubset<T, MerchantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants and returns the data updated in the database.
     * @param {MerchantUpdateManyAndReturnArgs} args - Arguments to update many Merchants.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Merchant.
     * @param {MerchantUpsertArgs} args - Arguments to update or create a Merchant.
     * @example
     * // Update or create a Merchant
     * const merchant = await prisma.merchant.upsert({
     *   create: {
     *     // ... data to create a Merchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchant we want to update
     *   }
     * })
     */
    upsert<T extends MerchantUpsertArgs>(args: SelectSubset<T, MerchantUpsertArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchant.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends MerchantCountArgs>(
      args?: Subset<T, MerchantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantAggregateArgs>(args: Subset<T, MerchantAggregateArgs>): Prisma.PrismaPromise<GetMerchantAggregateType<T>>

    /**
     * Group by Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantGroupByArgs['orderBy'] }
        : { orderBy?: MerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Merchant model
   */
  readonly fields: MerchantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Merchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Merchant$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Merchant model
   */
  interface MerchantFieldRefs {
    readonly id: FieldRef<"Merchant", 'String'>
    readonly name: FieldRef<"Merchant", 'String'>
    readonly slug: FieldRef<"Merchant", 'String'>
    readonly logoUrl: FieldRef<"Merchant", 'String'>
    readonly color: FieldRef<"Merchant", 'String'>
    readonly createdAt: FieldRef<"Merchant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Merchant findUnique
   */
  export type MerchantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findUniqueOrThrow
   */
  export type MerchantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findFirst
   */
  export type MerchantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findFirstOrThrow
   */
  export type MerchantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findMany
   */
  export type MerchantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchants to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant create
   */
  export type MerchantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to create a Merchant.
     */
    data: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
  }

  /**
   * Merchant createMany
   */
  export type MerchantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant createManyAndReturn
   */
  export type MerchantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merchant update
   */
  export type MerchantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to update a Merchant.
     */
    data: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
    /**
     * Choose, which Merchant to update.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant updateMany
   */
  export type MerchantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant updateManyAndReturn
   */
  export type MerchantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant upsert
   */
  export type MerchantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The filter to search for the Merchant to update in case it exists.
     */
    where: MerchantWhereUniqueInput
    /**
     * In case the Merchant found by the `where` argument doesn't exist, create a new Merchant with this data.
     */
    create: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
    /**
     * In case the Merchant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
  }

  /**
   * Merchant delete
   */
  export type MerchantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter which Merchant to delete.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant deleteMany
   */
  export type MerchantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchants to delete
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to delete.
     */
    limit?: number
  }

  /**
   * Merchant.transactions
   */
  export type Merchant$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Merchant without action
   */
  export type MerchantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    color: string | null
    type: $Enums.CategoryType | null
    parentId: string | null
    householdId: string | null
    isActive: boolean | null
    isEditable: boolean | null
    isArchived: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    icon: string | null
    color: string | null
    type: $Enums.CategoryType | null
    parentId: string | null
    householdId: string | null
    isActive: boolean | null
    isEditable: boolean | null
    isArchived: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    icon: number
    color: number
    type: number
    parentId: number
    householdId: number
    isActive: number
    isEditable: number
    isArchived: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    color?: true
    type?: true
    parentId?: true
    householdId?: true
    isActive?: true
    isEditable?: true
    isArchived?: true
    sortOrder?: true
    createdAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    color?: true
    type?: true
    parentId?: true
    householdId?: true
    isActive?: true
    isEditable?: true
    isArchived?: true
    sortOrder?: true
    createdAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    icon?: true
    color?: true
    type?: true
    parentId?: true
    householdId?: true
    isActive?: true
    isEditable?: true
    isArchived?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    icon: string | null
    color: string | null
    type: $Enums.CategoryType
    parentId: string | null
    householdId: string | null
    isActive: boolean
    isEditable: boolean
    isArchived: boolean
    sortOrder: number | null
    createdAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    color?: boolean
    type?: boolean
    parentId?: boolean
    householdId?: boolean
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    household?: boolean | Category$householdArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    transactions?: boolean | Category$transactionsArgs<ExtArgs>
    transactionSplits?: boolean | Category$transactionSplitsArgs<ExtArgs>
    budgetCategories?: boolean | Category$budgetCategoriesArgs<ExtArgs>
    recurringTransactions?: boolean | Category$recurringTransactionsArgs<ExtArgs>
    gratitudeEntries?: boolean | Category$gratitudeEntriesArgs<ExtArgs>
    transactionSuggestions?: boolean | Category$transactionSuggestionsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    color?: boolean
    type?: boolean
    parentId?: boolean
    householdId?: boolean
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    household?: boolean | Category$householdArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    color?: boolean
    type?: boolean
    parentId?: boolean
    householdId?: boolean
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    household?: boolean | Category$householdArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    icon?: boolean
    color?: boolean
    type?: boolean
    parentId?: boolean
    householdId?: boolean
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "icon" | "color" | "type" | "parentId" | "householdId" | "isActive" | "isEditable" | "isArchived" | "sortOrder" | "createdAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | Category$householdArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    transactions?: boolean | Category$transactionsArgs<ExtArgs>
    transactionSplits?: boolean | Category$transactionSplitsArgs<ExtArgs>
    budgetCategories?: boolean | Category$budgetCategoriesArgs<ExtArgs>
    recurringTransactions?: boolean | Category$recurringTransactionsArgs<ExtArgs>
    gratitudeEntries?: boolean | Category$gratitudeEntriesArgs<ExtArgs>
    transactionSuggestions?: boolean | Category$transactionSuggestionsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | Category$householdArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | Category$householdArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs> | null
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      transactionSplits: Prisma.$TransactionSplitPayload<ExtArgs>[]
      budgetCategories: Prisma.$BudgetCategoryPayload<ExtArgs>[]
      recurringTransactions: Prisma.$RecurringTransactionPayload<ExtArgs>[]
      gratitudeEntries: Prisma.$GratitudeEntryPayload<ExtArgs>[]
      transactionSuggestions: Prisma.$TransactionSuggestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      icon: string | null
      color: string | null
      type: $Enums.CategoryType
      parentId: string | null
      householdId: string | null
      isActive: boolean
      isEditable: boolean
      isArchived: boolean
      sortOrder: number | null
      createdAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends Category$householdArgs<ExtArgs> = {}>(args?: Subset<T, Category$householdArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Category$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionSplits<T extends Category$transactionSplitsArgs<ExtArgs> = {}>(args?: Subset<T, Category$transactionSplitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgetCategories<T extends Category$budgetCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$budgetCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringTransactions<T extends Category$recurringTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$recurringTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gratitudeEntries<T extends Category$gratitudeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$gratitudeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionSuggestions<T extends Category$transactionSuggestionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$transactionSuggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly type: FieldRef<"Category", 'CategoryType'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly householdId: FieldRef<"Category", 'String'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly isEditable: FieldRef<"Category", 'Boolean'>
    readonly isArchived: FieldRef<"Category", 'Boolean'>
    readonly sortOrder: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.household
   */
  export type Category$householdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Household
     */
    omit?: HouseholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    where?: HouseholdWhereInput
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.transactions
   */
  export type Category$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Category.transactionSplits
   */
  export type Category$transactionSplitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    where?: TransactionSplitWhereInput
    orderBy?: TransactionSplitOrderByWithRelationInput | TransactionSplitOrderByWithRelationInput[]
    cursor?: TransactionSplitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionSplitScalarFieldEnum | TransactionSplitScalarFieldEnum[]
  }

  /**
   * Category.budgetCategories
   */
  export type Category$budgetCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    where?: BudgetCategoryWhereInput
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    cursor?: BudgetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * Category.recurringTransactions
   */
  export type Category$recurringTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    where?: RecurringTransactionWhereInput
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    cursor?: RecurringTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringTransactionScalarFieldEnum | RecurringTransactionScalarFieldEnum[]
  }

  /**
   * Category.gratitudeEntries
   */
  export type Category$gratitudeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    where?: GratitudeEntryWhereInput
    orderBy?: GratitudeEntryOrderByWithRelationInput | GratitudeEntryOrderByWithRelationInput[]
    cursor?: GratitudeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GratitudeEntryScalarFieldEnum | GratitudeEntryScalarFieldEnum[]
  }

  /**
   * Category.transactionSuggestions
   */
  export type Category$transactionSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    where?: TransactionSuggestionWhereInput
    orderBy?: TransactionSuggestionOrderByWithRelationInput | TransactionSuggestionOrderByWithRelationInput[]
    cursor?: TransactionSuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionSuggestionScalarFieldEnum | TransactionSuggestionScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amountCents: number | null
    originalAmountCents: number | null
    exchangeRate: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amountCents: bigint | null
    originalAmountCents: bigint | null
    exchangeRate: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    amountCents: bigint | null
    currency: string | null
    originalAmountCents: bigint | null
    originalCurrency: string | null
    exchangeRate: Decimal | null
    description: string | null
    categoryId: string | null
    merchant: string | null
    merchantId: string | null
    merchantName: string | null
    merchantLogoUrl: string | null
    merchantColor: string | null
    date: Date | null
    accountId: string | null
    transferAccountId: string | null
    receiptUrl: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    amountCents: bigint | null
    currency: string | null
    originalAmountCents: bigint | null
    originalCurrency: string | null
    exchangeRate: Decimal | null
    description: string | null
    categoryId: string | null
    merchant: string | null
    merchantId: string | null
    merchantName: string | null
    merchantLogoUrl: string | null
    merchantColor: string | null
    date: Date | null
    accountId: string | null
    transferAccountId: string | null
    receiptUrl: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    householdId: number
    amountCents: number
    currency: number
    originalAmountCents: number
    originalCurrency: number
    exchangeRate: number
    description: number
    categoryId: number
    merchant: number
    merchantId: number
    merchantName: number
    merchantLogoUrl: number
    merchantColor: number
    date: number
    accountId: number
    transferAccountId: number
    receiptUrl: number
    metadata: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amountCents?: true
    originalAmountCents?: true
    exchangeRate?: true
  }

  export type TransactionSumAggregateInputType = {
    amountCents?: true
    originalAmountCents?: true
    exchangeRate?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    householdId?: true
    amountCents?: true
    currency?: true
    originalAmountCents?: true
    originalCurrency?: true
    exchangeRate?: true
    description?: true
    categoryId?: true
    merchant?: true
    merchantId?: true
    merchantName?: true
    merchantLogoUrl?: true
    merchantColor?: true
    date?: true
    accountId?: true
    transferAccountId?: true
    receiptUrl?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    householdId?: true
    amountCents?: true
    currency?: true
    originalAmountCents?: true
    originalCurrency?: true
    exchangeRate?: true
    description?: true
    categoryId?: true
    merchant?: true
    merchantId?: true
    merchantName?: true
    merchantLogoUrl?: true
    merchantColor?: true
    date?: true
    accountId?: true
    transferAccountId?: true
    receiptUrl?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    householdId?: true
    amountCents?: true
    currency?: true
    originalAmountCents?: true
    originalCurrency?: true
    exchangeRate?: true
    description?: true
    categoryId?: true
    merchant?: true
    merchantId?: true
    merchantName?: true
    merchantLogoUrl?: true
    merchantColor?: true
    date?: true
    accountId?: true
    transferAccountId?: true
    receiptUrl?: true
    metadata?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    householdId: string
    amountCents: bigint
    currency: string
    originalAmountCents: bigint | null
    originalCurrency: string | null
    exchangeRate: Decimal | null
    description: string
    categoryId: string | null
    merchant: string | null
    merchantId: string | null
    merchantName: string | null
    merchantLogoUrl: string | null
    merchantColor: string | null
    date: Date
    accountId: string
    transferAccountId: string | null
    receiptUrl: string | null
    metadata: JsonValue
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    amountCents?: boolean
    currency?: boolean
    originalAmountCents?: boolean
    originalCurrency?: boolean
    exchangeRate?: boolean
    description?: boolean
    categoryId?: boolean
    merchant?: boolean
    merchantId?: boolean
    merchantName?: boolean
    merchantLogoUrl?: boolean
    merchantColor?: boolean
    date?: boolean
    accountId?: boolean
    transferAccountId?: boolean
    receiptUrl?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | Transaction$transferAccountArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    merchantData?: boolean | Transaction$merchantDataArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    tags?: boolean | Transaction$tagsArgs<ExtArgs>
    splits?: boolean | Transaction$splitsArgs<ExtArgs>
    ledgerEntries?: boolean | Transaction$ledgerEntriesArgs<ExtArgs>
    recurringTransactionExecutions?: boolean | Transaction$recurringTransactionExecutionsArgs<ExtArgs>
    gratitudeEntries?: boolean | Transaction$gratitudeEntriesArgs<ExtArgs>
    createdFromSuggestion?: boolean | Transaction$createdFromSuggestionArgs<ExtArgs>
    zakatPayments?: boolean | Transaction$zakatPaymentsArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    amountCents?: boolean
    currency?: boolean
    originalAmountCents?: boolean
    originalCurrency?: boolean
    exchangeRate?: boolean
    description?: boolean
    categoryId?: boolean
    merchant?: boolean
    merchantId?: boolean
    merchantName?: boolean
    merchantLogoUrl?: boolean
    merchantColor?: boolean
    date?: boolean
    accountId?: boolean
    transferAccountId?: boolean
    receiptUrl?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | Transaction$transferAccountArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    merchantData?: boolean | Transaction$merchantDataArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    amountCents?: boolean
    currency?: boolean
    originalAmountCents?: boolean
    originalCurrency?: boolean
    exchangeRate?: boolean
    description?: boolean
    categoryId?: boolean
    merchant?: boolean
    merchantId?: boolean
    merchantName?: boolean
    merchantLogoUrl?: boolean
    merchantColor?: boolean
    date?: boolean
    accountId?: boolean
    transferAccountId?: boolean
    receiptUrl?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | Transaction$transferAccountArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    merchantData?: boolean | Transaction$merchantDataArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    householdId?: boolean
    amountCents?: boolean
    currency?: boolean
    originalAmountCents?: boolean
    originalCurrency?: boolean
    exchangeRate?: boolean
    description?: boolean
    categoryId?: boolean
    merchant?: boolean
    merchantId?: boolean
    merchantName?: boolean
    merchantLogoUrl?: boolean
    merchantColor?: boolean
    date?: boolean
    accountId?: boolean
    transferAccountId?: boolean
    receiptUrl?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "amountCents" | "currency" | "originalAmountCents" | "originalCurrency" | "exchangeRate" | "description" | "categoryId" | "merchant" | "merchantId" | "merchantName" | "merchantLogoUrl" | "merchantColor" | "date" | "accountId" | "transferAccountId" | "receiptUrl" | "metadata" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | Transaction$transferAccountArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    merchantData?: boolean | Transaction$merchantDataArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    tags?: boolean | Transaction$tagsArgs<ExtArgs>
    splits?: boolean | Transaction$splitsArgs<ExtArgs>
    ledgerEntries?: boolean | Transaction$ledgerEntriesArgs<ExtArgs>
    recurringTransactionExecutions?: boolean | Transaction$recurringTransactionExecutionsArgs<ExtArgs>
    gratitudeEntries?: boolean | Transaction$gratitudeEntriesArgs<ExtArgs>
    createdFromSuggestion?: boolean | Transaction$createdFromSuggestionArgs<ExtArgs>
    zakatPayments?: boolean | Transaction$zakatPaymentsArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | Transaction$transferAccountArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    merchantData?: boolean | Transaction$merchantDataArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | Transaction$transferAccountArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    merchantData?: boolean | Transaction$merchantDataArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      transferAccount: Prisma.$AccountPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      merchantData: Prisma.$MerchantPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      tags: Prisma.$TransactionTagPayload<ExtArgs>[]
      splits: Prisma.$TransactionSplitPayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      recurringTransactionExecutions: Prisma.$RecurringTransactionExecutionPayload<ExtArgs>[]
      gratitudeEntries: Prisma.$GratitudeEntryPayload<ExtArgs>[]
      createdFromSuggestion: Prisma.$TransactionSuggestionPayload<ExtArgs>[]
      zakatPayments: Prisma.$ZakatPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      amountCents: bigint
      currency: string
      originalAmountCents: bigint | null
      originalCurrency: string | null
      exchangeRate: Prisma.Decimal | null
      description: string
      categoryId: string | null
      merchant: string | null
      merchantId: string | null
      merchantName: string | null
      merchantLogoUrl: string | null
      merchantColor: string | null
      date: Date
      accountId: string
      transferAccountId: string | null
      receiptUrl: string | null
      metadata: Prisma.JsonValue
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transferAccount<T extends Transaction$transferAccountArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$transferAccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends Transaction$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    merchantData<T extends Transaction$merchantDataArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$merchantDataArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends Transaction$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    splits<T extends Transaction$splitsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$splitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ledgerEntries<T extends Transaction$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringTransactionExecutions<T extends Transaction$recurringTransactionExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$recurringTransactionExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gratitudeEntries<T extends Transaction$gratitudeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$gratitudeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdFromSuggestion<T extends Transaction$createdFromSuggestionArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$createdFromSuggestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zakatPayments<T extends Transaction$zakatPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$zakatPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly householdId: FieldRef<"Transaction", 'String'>
    readonly amountCents: FieldRef<"Transaction", 'BigInt'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly originalAmountCents: FieldRef<"Transaction", 'BigInt'>
    readonly originalCurrency: FieldRef<"Transaction", 'String'>
    readonly exchangeRate: FieldRef<"Transaction", 'Decimal'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly categoryId: FieldRef<"Transaction", 'String'>
    readonly merchant: FieldRef<"Transaction", 'String'>
    readonly merchantId: FieldRef<"Transaction", 'String'>
    readonly merchantName: FieldRef<"Transaction", 'String'>
    readonly merchantLogoUrl: FieldRef<"Transaction", 'String'>
    readonly merchantColor: FieldRef<"Transaction", 'String'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly accountId: FieldRef<"Transaction", 'String'>
    readonly transferAccountId: FieldRef<"Transaction", 'String'>
    readonly receiptUrl: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly createdBy: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.transferAccount
   */
  export type Transaction$transferAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Transaction.category
   */
  export type Transaction$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Transaction.merchantData
   */
  export type Transaction$merchantDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    where?: MerchantWhereInput
  }

  /**
   * Transaction.tags
   */
  export type Transaction$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    where?: TransactionTagWhereInput
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    cursor?: TransactionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * Transaction.splits
   */
  export type Transaction$splitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    where?: TransactionSplitWhereInput
    orderBy?: TransactionSplitOrderByWithRelationInput | TransactionSplitOrderByWithRelationInput[]
    cursor?: TransactionSplitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionSplitScalarFieldEnum | TransactionSplitScalarFieldEnum[]
  }

  /**
   * Transaction.ledgerEntries
   */
  export type Transaction$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Transaction.recurringTransactionExecutions
   */
  export type Transaction$recurringTransactionExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    where?: RecurringTransactionExecutionWhereInput
    orderBy?: RecurringTransactionExecutionOrderByWithRelationInput | RecurringTransactionExecutionOrderByWithRelationInput[]
    cursor?: RecurringTransactionExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringTransactionExecutionScalarFieldEnum | RecurringTransactionExecutionScalarFieldEnum[]
  }

  /**
   * Transaction.gratitudeEntries
   */
  export type Transaction$gratitudeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    where?: GratitudeEntryWhereInput
    orderBy?: GratitudeEntryOrderByWithRelationInput | GratitudeEntryOrderByWithRelationInput[]
    cursor?: GratitudeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GratitudeEntryScalarFieldEnum | GratitudeEntryScalarFieldEnum[]
  }

  /**
   * Transaction.createdFromSuggestion
   */
  export type Transaction$createdFromSuggestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    where?: TransactionSuggestionWhereInput
    orderBy?: TransactionSuggestionOrderByWithRelationInput | TransactionSuggestionOrderByWithRelationInput[]
    cursor?: TransactionSuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionSuggestionScalarFieldEnum | TransactionSuggestionScalarFieldEnum[]
  }

  /**
   * Transaction.zakatPayments
   */
  export type Transaction$zakatPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    where?: ZakatPaymentWhereInput
    orderBy?: ZakatPaymentOrderByWithRelationInput | ZakatPaymentOrderByWithRelationInput[]
    cursor?: ZakatPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZakatPaymentScalarFieldEnum | ZakatPaymentScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransactionTag
   */

  export type AggregateTransactionTag = {
    _count: TransactionTagCountAggregateOutputType | null
    _min: TransactionTagMinAggregateOutputType | null
    _max: TransactionTagMaxAggregateOutputType | null
  }

  export type TransactionTagMinAggregateOutputType = {
    transactionId: string | null
    tag: string | null
  }

  export type TransactionTagMaxAggregateOutputType = {
    transactionId: string | null
    tag: string | null
  }

  export type TransactionTagCountAggregateOutputType = {
    transactionId: number
    tag: number
    _all: number
  }


  export type TransactionTagMinAggregateInputType = {
    transactionId?: true
    tag?: true
  }

  export type TransactionTagMaxAggregateInputType = {
    transactionId?: true
    tag?: true
  }

  export type TransactionTagCountAggregateInputType = {
    transactionId?: true
    tag?: true
    _all?: true
  }

  export type TransactionTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionTag to aggregate.
     */
    where?: TransactionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionTags to fetch.
     */
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionTags
    **/
    _count?: true | TransactionTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionTagMaxAggregateInputType
  }

  export type GetTransactionTagAggregateType<T extends TransactionTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionTag[P]>
      : GetScalarType<T[P], AggregateTransactionTag[P]>
  }




  export type TransactionTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionTagWhereInput
    orderBy?: TransactionTagOrderByWithAggregationInput | TransactionTagOrderByWithAggregationInput[]
    by: TransactionTagScalarFieldEnum[] | TransactionTagScalarFieldEnum
    having?: TransactionTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionTagCountAggregateInputType | true
    _min?: TransactionTagMinAggregateInputType
    _max?: TransactionTagMaxAggregateInputType
  }

  export type TransactionTagGroupByOutputType = {
    transactionId: string
    tag: string
    _count: TransactionTagCountAggregateOutputType | null
    _min: TransactionTagMinAggregateOutputType | null
    _max: TransactionTagMaxAggregateOutputType | null
  }

  type GetTransactionTagGroupByPayload<T extends TransactionTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionTagGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionTagGroupByOutputType[P]>
        }
      >
    >


  export type TransactionTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transactionId?: boolean
    tag?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionTag"]>

  export type TransactionTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transactionId?: boolean
    tag?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionTag"]>

  export type TransactionTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transactionId?: boolean
    tag?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionTag"]>

  export type TransactionTagSelectScalar = {
    transactionId?: boolean
    tag?: boolean
  }

  export type TransactionTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"transactionId" | "tag", ExtArgs["result"]["transactionTag"]>
  export type TransactionTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionTag"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      transactionId: string
      tag: string
    }, ExtArgs["result"]["transactionTag"]>
    composites: {}
  }

  type TransactionTagGetPayload<S extends boolean | null | undefined | TransactionTagDefaultArgs> = $Result.GetResult<Prisma.$TransactionTagPayload, S>

  type TransactionTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionTagCountAggregateInputType | true
    }

  export interface TransactionTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionTag'], meta: { name: 'TransactionTag' } }
    /**
     * Find zero or one TransactionTag that matches the filter.
     * @param {TransactionTagFindUniqueArgs} args - Arguments to find a TransactionTag
     * @example
     * // Get one TransactionTag
     * const transactionTag = await prisma.transactionTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionTagFindUniqueArgs>(args: SelectSubset<T, TransactionTagFindUniqueArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionTagFindUniqueOrThrowArgs} args - Arguments to find a TransactionTag
     * @example
     * // Get one TransactionTag
     * const transactionTag = await prisma.transactionTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagFindFirstArgs} args - Arguments to find a TransactionTag
     * @example
     * // Get one TransactionTag
     * const transactionTag = await prisma.transactionTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionTagFindFirstArgs>(args?: SelectSubset<T, TransactionTagFindFirstArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagFindFirstOrThrowArgs} args - Arguments to find a TransactionTag
     * @example
     * // Get one TransactionTag
     * const transactionTag = await prisma.transactionTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionTags
     * const transactionTags = await prisma.transactionTag.findMany()
     * 
     * // Get first 10 TransactionTags
     * const transactionTags = await prisma.transactionTag.findMany({ take: 10 })
     * 
     * // Only select the `transactionId`
     * const transactionTagWithTransactionIdOnly = await prisma.transactionTag.findMany({ select: { transactionId: true } })
     * 
     */
    findMany<T extends TransactionTagFindManyArgs>(args?: SelectSubset<T, TransactionTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionTag.
     * @param {TransactionTagCreateArgs} args - Arguments to create a TransactionTag.
     * @example
     * // Create one TransactionTag
     * const TransactionTag = await prisma.transactionTag.create({
     *   data: {
     *     // ... data to create a TransactionTag
     *   }
     * })
     * 
     */
    create<T extends TransactionTagCreateArgs>(args: SelectSubset<T, TransactionTagCreateArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionTags.
     * @param {TransactionTagCreateManyArgs} args - Arguments to create many TransactionTags.
     * @example
     * // Create many TransactionTags
     * const transactionTag = await prisma.transactionTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionTagCreateManyArgs>(args?: SelectSubset<T, TransactionTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionTags and returns the data saved in the database.
     * @param {TransactionTagCreateManyAndReturnArgs} args - Arguments to create many TransactionTags.
     * @example
     * // Create many TransactionTags
     * const transactionTag = await prisma.transactionTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionTags and only return the `transactionId`
     * const transactionTagWithTransactionIdOnly = await prisma.transactionTag.createManyAndReturn({
     *   select: { transactionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionTagCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionTag.
     * @param {TransactionTagDeleteArgs} args - Arguments to delete one TransactionTag.
     * @example
     * // Delete one TransactionTag
     * const TransactionTag = await prisma.transactionTag.delete({
     *   where: {
     *     // ... filter to delete one TransactionTag
     *   }
     * })
     * 
     */
    delete<T extends TransactionTagDeleteArgs>(args: SelectSubset<T, TransactionTagDeleteArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionTag.
     * @param {TransactionTagUpdateArgs} args - Arguments to update one TransactionTag.
     * @example
     * // Update one TransactionTag
     * const transactionTag = await prisma.transactionTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionTagUpdateArgs>(args: SelectSubset<T, TransactionTagUpdateArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionTags.
     * @param {TransactionTagDeleteManyArgs} args - Arguments to filter TransactionTags to delete.
     * @example
     * // Delete a few TransactionTags
     * const { count } = await prisma.transactionTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionTagDeleteManyArgs>(args?: SelectSubset<T, TransactionTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionTags
     * const transactionTag = await prisma.transactionTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionTagUpdateManyArgs>(args: SelectSubset<T, TransactionTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionTags and returns the data updated in the database.
     * @param {TransactionTagUpdateManyAndReturnArgs} args - Arguments to update many TransactionTags.
     * @example
     * // Update many TransactionTags
     * const transactionTag = await prisma.transactionTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionTags and only return the `transactionId`
     * const transactionTagWithTransactionIdOnly = await prisma.transactionTag.updateManyAndReturn({
     *   select: { transactionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionTagUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionTag.
     * @param {TransactionTagUpsertArgs} args - Arguments to update or create a TransactionTag.
     * @example
     * // Update or create a TransactionTag
     * const transactionTag = await prisma.transactionTag.upsert({
     *   create: {
     *     // ... data to create a TransactionTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionTag we want to update
     *   }
     * })
     */
    upsert<T extends TransactionTagUpsertArgs>(args: SelectSubset<T, TransactionTagUpsertArgs<ExtArgs>>): Prisma__TransactionTagClient<$Result.GetResult<Prisma.$TransactionTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagCountArgs} args - Arguments to filter TransactionTags to count.
     * @example
     * // Count the number of TransactionTags
     * const count = await prisma.transactionTag.count({
     *   where: {
     *     // ... the filter for the TransactionTags we want to count
     *   }
     * })
    **/
    count<T extends TransactionTagCountArgs>(
      args?: Subset<T, TransactionTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionTagAggregateArgs>(args: Subset<T, TransactionTagAggregateArgs>): Prisma.PrismaPromise<GetTransactionTagAggregateType<T>>

    /**
     * Group by TransactionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionTagGroupByArgs['orderBy'] }
        : { orderBy?: TransactionTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionTag model
   */
  readonly fields: TransactionTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionTag model
   */
  interface TransactionTagFieldRefs {
    readonly transactionId: FieldRef<"TransactionTag", 'String'>
    readonly tag: FieldRef<"TransactionTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TransactionTag findUnique
   */
  export type TransactionTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTag to fetch.
     */
    where: TransactionTagWhereUniqueInput
  }

  /**
   * TransactionTag findUniqueOrThrow
   */
  export type TransactionTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTag to fetch.
     */
    where: TransactionTagWhereUniqueInput
  }

  /**
   * TransactionTag findFirst
   */
  export type TransactionTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTag to fetch.
     */
    where?: TransactionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionTags to fetch.
     */
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionTags.
     */
    cursor?: TransactionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionTags.
     */
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * TransactionTag findFirstOrThrow
   */
  export type TransactionTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTag to fetch.
     */
    where?: TransactionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionTags to fetch.
     */
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionTags.
     */
    cursor?: TransactionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionTags.
     */
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * TransactionTag findMany
   */
  export type TransactionTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter, which TransactionTags to fetch.
     */
    where?: TransactionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionTags to fetch.
     */
    orderBy?: TransactionTagOrderByWithRelationInput | TransactionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionTags.
     */
    cursor?: TransactionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionTags.
     */
    skip?: number
    distinct?: TransactionTagScalarFieldEnum | TransactionTagScalarFieldEnum[]
  }

  /**
   * TransactionTag create
   */
  export type TransactionTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionTag.
     */
    data: XOR<TransactionTagCreateInput, TransactionTagUncheckedCreateInput>
  }

  /**
   * TransactionTag createMany
   */
  export type TransactionTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionTags.
     */
    data: TransactionTagCreateManyInput | TransactionTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionTag createManyAndReturn
   */
  export type TransactionTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionTags.
     */
    data: TransactionTagCreateManyInput | TransactionTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionTag update
   */
  export type TransactionTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionTag.
     */
    data: XOR<TransactionTagUpdateInput, TransactionTagUncheckedUpdateInput>
    /**
     * Choose, which TransactionTag to update.
     */
    where: TransactionTagWhereUniqueInput
  }

  /**
   * TransactionTag updateMany
   */
  export type TransactionTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionTags.
     */
    data: XOR<TransactionTagUpdateManyMutationInput, TransactionTagUncheckedUpdateManyInput>
    /**
     * Filter which TransactionTags to update
     */
    where?: TransactionTagWhereInput
    /**
     * Limit how many TransactionTags to update.
     */
    limit?: number
  }

  /**
   * TransactionTag updateManyAndReturn
   */
  export type TransactionTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * The data used to update TransactionTags.
     */
    data: XOR<TransactionTagUpdateManyMutationInput, TransactionTagUncheckedUpdateManyInput>
    /**
     * Filter which TransactionTags to update
     */
    where?: TransactionTagWhereInput
    /**
     * Limit how many TransactionTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionTag upsert
   */
  export type TransactionTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionTag to update in case it exists.
     */
    where: TransactionTagWhereUniqueInput
    /**
     * In case the TransactionTag found by the `where` argument doesn't exist, create a new TransactionTag with this data.
     */
    create: XOR<TransactionTagCreateInput, TransactionTagUncheckedCreateInput>
    /**
     * In case the TransactionTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionTagUpdateInput, TransactionTagUncheckedUpdateInput>
  }

  /**
   * TransactionTag delete
   */
  export type TransactionTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
    /**
     * Filter which TransactionTag to delete.
     */
    where: TransactionTagWhereUniqueInput
  }

  /**
   * TransactionTag deleteMany
   */
  export type TransactionTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionTags to delete
     */
    where?: TransactionTagWhereInput
    /**
     * Limit how many TransactionTags to delete.
     */
    limit?: number
  }

  /**
   * TransactionTag without action
   */
  export type TransactionTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionTag
     */
    select?: TransactionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionTag
     */
    omit?: TransactionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionTagInclude<ExtArgs> | null
  }


  /**
   * Model TransactionSplit
   */

  export type AggregateTransactionSplit = {
    _count: TransactionSplitCountAggregateOutputType | null
    _avg: TransactionSplitAvgAggregateOutputType | null
    _sum: TransactionSplitSumAggregateOutputType | null
    _min: TransactionSplitMinAggregateOutputType | null
    _max: TransactionSplitMaxAggregateOutputType | null
  }

  export type TransactionSplitAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type TransactionSplitSumAggregateOutputType = {
    amountCents: bigint | null
  }

  export type TransactionSplitMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    categoryId: string | null
    amountCents: bigint | null
    description: string | null
    createdAt: Date | null
  }

  export type TransactionSplitMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    categoryId: string | null
    amountCents: bigint | null
    description: string | null
    createdAt: Date | null
  }

  export type TransactionSplitCountAggregateOutputType = {
    id: number
    transactionId: number
    categoryId: number
    amountCents: number
    description: number
    createdAt: number
    _all: number
  }


  export type TransactionSplitAvgAggregateInputType = {
    amountCents?: true
  }

  export type TransactionSplitSumAggregateInputType = {
    amountCents?: true
  }

  export type TransactionSplitMinAggregateInputType = {
    id?: true
    transactionId?: true
    categoryId?: true
    amountCents?: true
    description?: true
    createdAt?: true
  }

  export type TransactionSplitMaxAggregateInputType = {
    id?: true
    transactionId?: true
    categoryId?: true
    amountCents?: true
    description?: true
    createdAt?: true
  }

  export type TransactionSplitCountAggregateInputType = {
    id?: true
    transactionId?: true
    categoryId?: true
    amountCents?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionSplitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionSplit to aggregate.
     */
    where?: TransactionSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionSplits to fetch.
     */
    orderBy?: TransactionSplitOrderByWithRelationInput | TransactionSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionSplits
    **/
    _count?: true | TransactionSplitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionSplitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSplitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionSplitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionSplitMaxAggregateInputType
  }

  export type GetTransactionSplitAggregateType<T extends TransactionSplitAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionSplit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionSplit[P]>
      : GetScalarType<T[P], AggregateTransactionSplit[P]>
  }




  export type TransactionSplitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionSplitWhereInput
    orderBy?: TransactionSplitOrderByWithAggregationInput | TransactionSplitOrderByWithAggregationInput[]
    by: TransactionSplitScalarFieldEnum[] | TransactionSplitScalarFieldEnum
    having?: TransactionSplitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionSplitCountAggregateInputType | true
    _avg?: TransactionSplitAvgAggregateInputType
    _sum?: TransactionSplitSumAggregateInputType
    _min?: TransactionSplitMinAggregateInputType
    _max?: TransactionSplitMaxAggregateInputType
  }

  export type TransactionSplitGroupByOutputType = {
    id: string
    transactionId: string
    categoryId: string
    amountCents: bigint
    description: string | null
    createdAt: Date
    _count: TransactionSplitCountAggregateOutputType | null
    _avg: TransactionSplitAvgAggregateOutputType | null
    _sum: TransactionSplitSumAggregateOutputType | null
    _min: TransactionSplitMinAggregateOutputType | null
    _max: TransactionSplitMaxAggregateOutputType | null
  }

  type GetTransactionSplitGroupByPayload<T extends TransactionSplitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionSplitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionSplitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionSplitGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionSplitGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSplitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    categoryId?: boolean
    amountCents?: boolean
    description?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionSplit"]>

  export type TransactionSplitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    categoryId?: boolean
    amountCents?: boolean
    description?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionSplit"]>

  export type TransactionSplitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    categoryId?: boolean
    amountCents?: boolean
    description?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionSplit"]>

  export type TransactionSplitSelectScalar = {
    id?: boolean
    transactionId?: boolean
    categoryId?: boolean
    amountCents?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type TransactionSplitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "categoryId" | "amountCents" | "description" | "createdAt", ExtArgs["result"]["transactionSplit"]>
  export type TransactionSplitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type TransactionSplitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type TransactionSplitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $TransactionSplitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionSplit"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      categoryId: string
      amountCents: bigint
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["transactionSplit"]>
    composites: {}
  }

  type TransactionSplitGetPayload<S extends boolean | null | undefined | TransactionSplitDefaultArgs> = $Result.GetResult<Prisma.$TransactionSplitPayload, S>

  type TransactionSplitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionSplitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionSplitCountAggregateInputType | true
    }

  export interface TransactionSplitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionSplit'], meta: { name: 'TransactionSplit' } }
    /**
     * Find zero or one TransactionSplit that matches the filter.
     * @param {TransactionSplitFindUniqueArgs} args - Arguments to find a TransactionSplit
     * @example
     * // Get one TransactionSplit
     * const transactionSplit = await prisma.transactionSplit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionSplitFindUniqueArgs>(args: SelectSubset<T, TransactionSplitFindUniqueArgs<ExtArgs>>): Prisma__TransactionSplitClient<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionSplit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionSplitFindUniqueOrThrowArgs} args - Arguments to find a TransactionSplit
     * @example
     * // Get one TransactionSplit
     * const transactionSplit = await prisma.transactionSplit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionSplitFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionSplitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionSplitClient<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionSplit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSplitFindFirstArgs} args - Arguments to find a TransactionSplit
     * @example
     * // Get one TransactionSplit
     * const transactionSplit = await prisma.transactionSplit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionSplitFindFirstArgs>(args?: SelectSubset<T, TransactionSplitFindFirstArgs<ExtArgs>>): Prisma__TransactionSplitClient<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionSplit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSplitFindFirstOrThrowArgs} args - Arguments to find a TransactionSplit
     * @example
     * // Get one TransactionSplit
     * const transactionSplit = await prisma.transactionSplit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionSplitFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionSplitFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionSplitClient<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionSplits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSplitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionSplits
     * const transactionSplits = await prisma.transactionSplit.findMany()
     * 
     * // Get first 10 TransactionSplits
     * const transactionSplits = await prisma.transactionSplit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionSplitWithIdOnly = await prisma.transactionSplit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionSplitFindManyArgs>(args?: SelectSubset<T, TransactionSplitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionSplit.
     * @param {TransactionSplitCreateArgs} args - Arguments to create a TransactionSplit.
     * @example
     * // Create one TransactionSplit
     * const TransactionSplit = await prisma.transactionSplit.create({
     *   data: {
     *     // ... data to create a TransactionSplit
     *   }
     * })
     * 
     */
    create<T extends TransactionSplitCreateArgs>(args: SelectSubset<T, TransactionSplitCreateArgs<ExtArgs>>): Prisma__TransactionSplitClient<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionSplits.
     * @param {TransactionSplitCreateManyArgs} args - Arguments to create many TransactionSplits.
     * @example
     * // Create many TransactionSplits
     * const transactionSplit = await prisma.transactionSplit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionSplitCreateManyArgs>(args?: SelectSubset<T, TransactionSplitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionSplits and returns the data saved in the database.
     * @param {TransactionSplitCreateManyAndReturnArgs} args - Arguments to create many TransactionSplits.
     * @example
     * // Create many TransactionSplits
     * const transactionSplit = await prisma.transactionSplit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionSplits and only return the `id`
     * const transactionSplitWithIdOnly = await prisma.transactionSplit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionSplitCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionSplitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionSplit.
     * @param {TransactionSplitDeleteArgs} args - Arguments to delete one TransactionSplit.
     * @example
     * // Delete one TransactionSplit
     * const TransactionSplit = await prisma.transactionSplit.delete({
     *   where: {
     *     // ... filter to delete one TransactionSplit
     *   }
     * })
     * 
     */
    delete<T extends TransactionSplitDeleteArgs>(args: SelectSubset<T, TransactionSplitDeleteArgs<ExtArgs>>): Prisma__TransactionSplitClient<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionSplit.
     * @param {TransactionSplitUpdateArgs} args - Arguments to update one TransactionSplit.
     * @example
     * // Update one TransactionSplit
     * const transactionSplit = await prisma.transactionSplit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionSplitUpdateArgs>(args: SelectSubset<T, TransactionSplitUpdateArgs<ExtArgs>>): Prisma__TransactionSplitClient<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionSplits.
     * @param {TransactionSplitDeleteManyArgs} args - Arguments to filter TransactionSplits to delete.
     * @example
     * // Delete a few TransactionSplits
     * const { count } = await prisma.transactionSplit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionSplitDeleteManyArgs>(args?: SelectSubset<T, TransactionSplitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionSplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSplitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionSplits
     * const transactionSplit = await prisma.transactionSplit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionSplitUpdateManyArgs>(args: SelectSubset<T, TransactionSplitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionSplits and returns the data updated in the database.
     * @param {TransactionSplitUpdateManyAndReturnArgs} args - Arguments to update many TransactionSplits.
     * @example
     * // Update many TransactionSplits
     * const transactionSplit = await prisma.transactionSplit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionSplits and only return the `id`
     * const transactionSplitWithIdOnly = await prisma.transactionSplit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionSplitUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionSplitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionSplit.
     * @param {TransactionSplitUpsertArgs} args - Arguments to update or create a TransactionSplit.
     * @example
     * // Update or create a TransactionSplit
     * const transactionSplit = await prisma.transactionSplit.upsert({
     *   create: {
     *     // ... data to create a TransactionSplit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionSplit we want to update
     *   }
     * })
     */
    upsert<T extends TransactionSplitUpsertArgs>(args: SelectSubset<T, TransactionSplitUpsertArgs<ExtArgs>>): Prisma__TransactionSplitClient<$Result.GetResult<Prisma.$TransactionSplitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionSplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSplitCountArgs} args - Arguments to filter TransactionSplits to count.
     * @example
     * // Count the number of TransactionSplits
     * const count = await prisma.transactionSplit.count({
     *   where: {
     *     // ... the filter for the TransactionSplits we want to count
     *   }
     * })
    **/
    count<T extends TransactionSplitCountArgs>(
      args?: Subset<T, TransactionSplitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionSplitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionSplit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSplitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionSplitAggregateArgs>(args: Subset<T, TransactionSplitAggregateArgs>): Prisma.PrismaPromise<GetTransactionSplitAggregateType<T>>

    /**
     * Group by TransactionSplit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSplitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionSplitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionSplitGroupByArgs['orderBy'] }
        : { orderBy?: TransactionSplitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionSplitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionSplitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionSplit model
   */
  readonly fields: TransactionSplitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionSplit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionSplitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionSplit model
   */
  interface TransactionSplitFieldRefs {
    readonly id: FieldRef<"TransactionSplit", 'String'>
    readonly transactionId: FieldRef<"TransactionSplit", 'String'>
    readonly categoryId: FieldRef<"TransactionSplit", 'String'>
    readonly amountCents: FieldRef<"TransactionSplit", 'BigInt'>
    readonly description: FieldRef<"TransactionSplit", 'String'>
    readonly createdAt: FieldRef<"TransactionSplit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionSplit findUnique
   */
  export type TransactionSplitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSplit to fetch.
     */
    where: TransactionSplitWhereUniqueInput
  }

  /**
   * TransactionSplit findUniqueOrThrow
   */
  export type TransactionSplitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSplit to fetch.
     */
    where: TransactionSplitWhereUniqueInput
  }

  /**
   * TransactionSplit findFirst
   */
  export type TransactionSplitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSplit to fetch.
     */
    where?: TransactionSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionSplits to fetch.
     */
    orderBy?: TransactionSplitOrderByWithRelationInput | TransactionSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionSplits.
     */
    cursor?: TransactionSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionSplits.
     */
    distinct?: TransactionSplitScalarFieldEnum | TransactionSplitScalarFieldEnum[]
  }

  /**
   * TransactionSplit findFirstOrThrow
   */
  export type TransactionSplitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSplit to fetch.
     */
    where?: TransactionSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionSplits to fetch.
     */
    orderBy?: TransactionSplitOrderByWithRelationInput | TransactionSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionSplits.
     */
    cursor?: TransactionSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionSplits.
     */
    distinct?: TransactionSplitScalarFieldEnum | TransactionSplitScalarFieldEnum[]
  }

  /**
   * TransactionSplit findMany
   */
  export type TransactionSplitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSplits to fetch.
     */
    where?: TransactionSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionSplits to fetch.
     */
    orderBy?: TransactionSplitOrderByWithRelationInput | TransactionSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionSplits.
     */
    cursor?: TransactionSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionSplits.
     */
    skip?: number
    distinct?: TransactionSplitScalarFieldEnum | TransactionSplitScalarFieldEnum[]
  }

  /**
   * TransactionSplit create
   */
  export type TransactionSplitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionSplit.
     */
    data: XOR<TransactionSplitCreateInput, TransactionSplitUncheckedCreateInput>
  }

  /**
   * TransactionSplit createMany
   */
  export type TransactionSplitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionSplits.
     */
    data: TransactionSplitCreateManyInput | TransactionSplitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionSplit createManyAndReturn
   */
  export type TransactionSplitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionSplits.
     */
    data: TransactionSplitCreateManyInput | TransactionSplitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionSplit update
   */
  export type TransactionSplitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionSplit.
     */
    data: XOR<TransactionSplitUpdateInput, TransactionSplitUncheckedUpdateInput>
    /**
     * Choose, which TransactionSplit to update.
     */
    where: TransactionSplitWhereUniqueInput
  }

  /**
   * TransactionSplit updateMany
   */
  export type TransactionSplitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionSplits.
     */
    data: XOR<TransactionSplitUpdateManyMutationInput, TransactionSplitUncheckedUpdateManyInput>
    /**
     * Filter which TransactionSplits to update
     */
    where?: TransactionSplitWhereInput
    /**
     * Limit how many TransactionSplits to update.
     */
    limit?: number
  }

  /**
   * TransactionSplit updateManyAndReturn
   */
  export type TransactionSplitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * The data used to update TransactionSplits.
     */
    data: XOR<TransactionSplitUpdateManyMutationInput, TransactionSplitUncheckedUpdateManyInput>
    /**
     * Filter which TransactionSplits to update
     */
    where?: TransactionSplitWhereInput
    /**
     * Limit how many TransactionSplits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionSplit upsert
   */
  export type TransactionSplitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionSplit to update in case it exists.
     */
    where: TransactionSplitWhereUniqueInput
    /**
     * In case the TransactionSplit found by the `where` argument doesn't exist, create a new TransactionSplit with this data.
     */
    create: XOR<TransactionSplitCreateInput, TransactionSplitUncheckedCreateInput>
    /**
     * In case the TransactionSplit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionSplitUpdateInput, TransactionSplitUncheckedUpdateInput>
  }

  /**
   * TransactionSplit delete
   */
  export type TransactionSplitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
    /**
     * Filter which TransactionSplit to delete.
     */
    where: TransactionSplitWhereUniqueInput
  }

  /**
   * TransactionSplit deleteMany
   */
  export type TransactionSplitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionSplits to delete
     */
    where?: TransactionSplitWhereInput
    /**
     * Limit how many TransactionSplits to delete.
     */
    limit?: number
  }

  /**
   * TransactionSplit without action
   */
  export type TransactionSplitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSplit
     */
    select?: TransactionSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSplit
     */
    omit?: TransactionSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSplitInclude<ExtArgs> | null
  }


  /**
   * Model LedgerEntry
   */

  export type AggregateLedgerEntry = {
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  export type LedgerEntryAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type LedgerEntrySumAggregateOutputType = {
    amountCents: bigint | null
  }

  export type LedgerEntryMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    accountId: string | null
    type: $Enums.LedgerType | null
    amountCents: bigint | null
    currency: string | null
    createdAt: Date | null
  }

  export type LedgerEntryMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    accountId: string | null
    type: $Enums.LedgerType | null
    amountCents: bigint | null
    currency: string | null
    createdAt: Date | null
  }

  export type LedgerEntryCountAggregateOutputType = {
    id: number
    transactionId: number
    accountId: number
    type: number
    amountCents: number
    currency: number
    createdAt: number
    _all: number
  }


  export type LedgerEntryAvgAggregateInputType = {
    amountCents?: true
  }

  export type LedgerEntrySumAggregateInputType = {
    amountCents?: true
  }

  export type LedgerEntryMinAggregateInputType = {
    id?: true
    transactionId?: true
    accountId?: true
    type?: true
    amountCents?: true
    currency?: true
    createdAt?: true
  }

  export type LedgerEntryMaxAggregateInputType = {
    id?: true
    transactionId?: true
    accountId?: true
    type?: true
    amountCents?: true
    currency?: true
    createdAt?: true
  }

  export type LedgerEntryCountAggregateInputType = {
    id?: true
    transactionId?: true
    accountId?: true
    type?: true
    amountCents?: true
    currency?: true
    createdAt?: true
    _all?: true
  }

  export type LedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntry to aggregate.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerEntries
    **/
    _count?: true | LedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type GetLedgerEntryAggregateType<T extends LedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerEntry[P]>
      : GetScalarType<T[P], AggregateLedgerEntry[P]>
  }




  export type LedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithAggregationInput | LedgerEntryOrderByWithAggregationInput[]
    by: LedgerEntryScalarFieldEnum[] | LedgerEntryScalarFieldEnum
    having?: LedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerEntryCountAggregateInputType | true
    _avg?: LedgerEntryAvgAggregateInputType
    _sum?: LedgerEntrySumAggregateInputType
    _min?: LedgerEntryMinAggregateInputType
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type LedgerEntryGroupByOutputType = {
    id: string
    transactionId: string
    accountId: string
    type: $Enums.LedgerType
    amountCents: bigint
    currency: string
    createdAt: Date
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  type GetLedgerEntryGroupByPayload<T extends LedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type LedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    accountId?: boolean
    type?: boolean
    amountCents?: boolean
    currency?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    accountId?: boolean
    type?: boolean
    amountCents?: boolean
    currency?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    accountId?: boolean
    type?: boolean
    amountCents?: boolean
    currency?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectScalar = {
    id?: boolean
    transactionId?: boolean
    accountId?: boolean
    type?: boolean
    amountCents?: boolean
    currency?: boolean
    createdAt?: boolean
  }

  export type LedgerEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "accountId" | "type" | "amountCents" | "currency" | "createdAt", ExtArgs["result"]["ledgerEntry"]>
  export type LedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type LedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type LedgerEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $LedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerEntry"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      accountId: string
      type: $Enums.LedgerType
      amountCents: bigint
      currency: string
      createdAt: Date
    }, ExtArgs["result"]["ledgerEntry"]>
    composites: {}
  }

  type LedgerEntryGetPayload<S extends boolean | null | undefined | LedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$LedgerEntryPayload, S>

  type LedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LedgerEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LedgerEntryCountAggregateInputType | true
    }

  export interface LedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerEntry'], meta: { name: 'LedgerEntry' } }
    /**
     * Find zero or one LedgerEntry that matches the filter.
     * @param {LedgerEntryFindUniqueArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerEntryFindUniqueArgs>(args: SelectSubset<T, LedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LedgerEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerEntryFindFirstArgs>(args?: SelectSubset<T, LedgerEntryFindFirstArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany()
     * 
     * // Get first 10 LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerEntryFindManyArgs>(args?: SelectSubset<T, LedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LedgerEntry.
     * @param {LedgerEntryCreateArgs} args - Arguments to create a LedgerEntry.
     * @example
     * // Create one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.create({
     *   data: {
     *     // ... data to create a LedgerEntry
     *   }
     * })
     * 
     */
    create<T extends LedgerEntryCreateArgs>(args: SelectSubset<T, LedgerEntryCreateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LedgerEntries.
     * @param {LedgerEntryCreateManyArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerEntryCreateManyArgs>(args?: SelectSubset<T, LedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerEntries and returns the data saved in the database.
     * @param {LedgerEntryCreateManyAndReturnArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LedgerEntry.
     * @param {LedgerEntryDeleteArgs} args - Arguments to delete one LedgerEntry.
     * @example
     * // Delete one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.delete({
     *   where: {
     *     // ... filter to delete one LedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends LedgerEntryDeleteArgs>(args: SelectSubset<T, LedgerEntryDeleteArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LedgerEntry.
     * @param {LedgerEntryUpdateArgs} args - Arguments to update one LedgerEntry.
     * @example
     * // Update one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerEntryUpdateArgs>(args: SelectSubset<T, LedgerEntryUpdateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LedgerEntries.
     * @param {LedgerEntryDeleteManyArgs} args - Arguments to filter LedgerEntries to delete.
     * @example
     * // Delete a few LedgerEntries
     * const { count } = await prisma.ledgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerEntryDeleteManyArgs>(args?: SelectSubset<T, LedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerEntryUpdateManyArgs>(args: SelectSubset<T, LedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries and returns the data updated in the database.
     * @param {LedgerEntryUpdateManyAndReturnArgs} args - Arguments to update many LedgerEntries.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LedgerEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, LedgerEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LedgerEntry.
     * @param {LedgerEntryUpsertArgs} args - Arguments to update or create a LedgerEntry.
     * @example
     * // Update or create a LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.upsert({
     *   create: {
     *     // ... data to create a LedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends LedgerEntryUpsertArgs>(args: SelectSubset<T, LedgerEntryUpsertArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryCountArgs} args - Arguments to filter LedgerEntries to count.
     * @example
     * // Count the number of LedgerEntries
     * const count = await prisma.ledgerEntry.count({
     *   where: {
     *     // ... the filter for the LedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends LedgerEntryCountArgs>(
      args?: Subset<T, LedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerEntryAggregateArgs>(args: Subset<T, LedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetLedgerEntryAggregateType<T>>

    /**
     * Group by LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: LedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerEntry model
   */
  readonly fields: LedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerEntry model
   */
  interface LedgerEntryFieldRefs {
    readonly id: FieldRef<"LedgerEntry", 'String'>
    readonly transactionId: FieldRef<"LedgerEntry", 'String'>
    readonly accountId: FieldRef<"LedgerEntry", 'String'>
    readonly type: FieldRef<"LedgerEntry", 'LedgerType'>
    readonly amountCents: FieldRef<"LedgerEntry", 'BigInt'>
    readonly currency: FieldRef<"LedgerEntry", 'String'>
    readonly createdAt: FieldRef<"LedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerEntry findUnique
   */
  export type LedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findUniqueOrThrow
   */
  export type LedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findFirst
   */
  export type LedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findFirstOrThrow
   */
  export type LedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findMany
   */
  export type LedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntries to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry create
   */
  export type LedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerEntry.
     */
    data: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
  }

  /**
   * LedgerEntry createMany
   */
  export type LedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerEntry createManyAndReturn
   */
  export type LedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry update
   */
  export type LedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerEntry.
     */
    data: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which LedgerEntry to update.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry updateMany
   */
  export type LedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to update.
     */
    limit?: number
  }

  /**
   * LedgerEntry updateManyAndReturn
   */
  export type LedgerEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry upsert
   */
  export type LedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerEntry to update in case it exists.
     */
    where: LedgerEntryWhereUniqueInput
    /**
     * In case the LedgerEntry found by the `where` argument doesn't exist, create a new LedgerEntry with this data.
     */
    create: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
    /**
     * In case the LedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
  }

  /**
   * LedgerEntry delete
   */
  export type LedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which LedgerEntry to delete.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry deleteMany
   */
  export type LedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntries to delete
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to delete.
     */
    limit?: number
  }

  /**
   * LedgerEntry without action
   */
  export type LedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model Debt
   */

  export type AggregateDebt = {
    _count: DebtCountAggregateOutputType | null
    _avg: DebtAvgAggregateOutputType | null
    _sum: DebtSumAggregateOutputType | null
    _min: DebtMinAggregateOutputType | null
    _max: DebtMaxAggregateOutputType | null
  }

  export type DebtAvgAggregateOutputType = {
    principalAmountCents: number | null
    currentBalanceCents: number | null
    interestRate: Decimal | null
    marginRate: Decimal | null
  }

  export type DebtSumAggregateOutputType = {
    principalAmountCents: bigint | null
    currentBalanceCents: bigint | null
    interestRate: Decimal | null
    marginRate: Decimal | null
  }

  export type DebtMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    type: $Enums.DebtType | null
    name: string | null
    creditor: string | null
    principalAmountCents: bigint | null
    currentBalanceCents: bigint | null
    currency: string | null
    interestRate: Decimal | null
    marginRate: Decimal | null
    startDate: Date | null
    maturityDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    type: $Enums.DebtType | null
    name: string | null
    creditor: string | null
    principalAmountCents: bigint | null
    currentBalanceCents: bigint | null
    currency: string | null
    interestRate: Decimal | null
    marginRate: Decimal | null
    startDate: Date | null
    maturityDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtCountAggregateOutputType = {
    id: number
    householdId: number
    type: number
    name: number
    creditor: number
    principalAmountCents: number
    currentBalanceCents: number
    currency: number
    interestRate: number
    marginRate: number
    startDate: number
    maturityDate: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DebtAvgAggregateInputType = {
    principalAmountCents?: true
    currentBalanceCents?: true
    interestRate?: true
    marginRate?: true
  }

  export type DebtSumAggregateInputType = {
    principalAmountCents?: true
    currentBalanceCents?: true
    interestRate?: true
    marginRate?: true
  }

  export type DebtMinAggregateInputType = {
    id?: true
    householdId?: true
    type?: true
    name?: true
    creditor?: true
    principalAmountCents?: true
    currentBalanceCents?: true
    currency?: true
    interestRate?: true
    marginRate?: true
    startDate?: true
    maturityDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtMaxAggregateInputType = {
    id?: true
    householdId?: true
    type?: true
    name?: true
    creditor?: true
    principalAmountCents?: true
    currentBalanceCents?: true
    currency?: true
    interestRate?: true
    marginRate?: true
    startDate?: true
    maturityDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtCountAggregateInputType = {
    id?: true
    householdId?: true
    type?: true
    name?: true
    creditor?: true
    principalAmountCents?: true
    currentBalanceCents?: true
    currency?: true
    interestRate?: true
    marginRate?: true
    startDate?: true
    maturityDate?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DebtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debt to aggregate.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Debts
    **/
    _count?: true | DebtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtMaxAggregateInputType
  }

  export type GetDebtAggregateType<T extends DebtAggregateArgs> = {
        [P in keyof T & keyof AggregateDebt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebt[P]>
      : GetScalarType<T[P], AggregateDebt[P]>
  }




  export type DebtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtWhereInput
    orderBy?: DebtOrderByWithAggregationInput | DebtOrderByWithAggregationInput[]
    by: DebtScalarFieldEnum[] | DebtScalarFieldEnum
    having?: DebtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtCountAggregateInputType | true
    _avg?: DebtAvgAggregateInputType
    _sum?: DebtSumAggregateInputType
    _min?: DebtMinAggregateInputType
    _max?: DebtMaxAggregateInputType
  }

  export type DebtGroupByOutputType = {
    id: string
    householdId: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint
    currentBalanceCents: bigint
    currency: string
    interestRate: Decimal | null
    marginRate: Decimal | null
    startDate: Date
    maturityDate: Date | null
    isActive: boolean
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DebtCountAggregateOutputType | null
    _avg: DebtAvgAggregateOutputType | null
    _sum: DebtSumAggregateOutputType | null
    _min: DebtMinAggregateOutputType | null
    _max: DebtMaxAggregateOutputType | null
  }

  type GetDebtGroupByPayload<T extends DebtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtGroupByOutputType[P]>
            : GetScalarType<T[P], DebtGroupByOutputType[P]>
        }
      >
    >


  export type DebtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    type?: boolean
    name?: boolean
    creditor?: boolean
    principalAmountCents?: boolean
    currentBalanceCents?: boolean
    currency?: boolean
    interestRate?: boolean
    marginRate?: boolean
    startDate?: boolean
    maturityDate?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    payments?: boolean | Debt$paymentsArgs<ExtArgs>
    _count?: boolean | DebtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debt"]>

  export type DebtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    type?: boolean
    name?: boolean
    creditor?: boolean
    principalAmountCents?: boolean
    currentBalanceCents?: boolean
    currency?: boolean
    interestRate?: boolean
    marginRate?: boolean
    startDate?: boolean
    maturityDate?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debt"]>

  export type DebtSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    type?: boolean
    name?: boolean
    creditor?: boolean
    principalAmountCents?: boolean
    currentBalanceCents?: boolean
    currency?: boolean
    interestRate?: boolean
    marginRate?: boolean
    startDate?: boolean
    maturityDate?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debt"]>

  export type DebtSelectScalar = {
    id?: boolean
    householdId?: boolean
    type?: boolean
    name?: boolean
    creditor?: boolean
    principalAmountCents?: boolean
    currentBalanceCents?: boolean
    currency?: boolean
    interestRate?: boolean
    marginRate?: boolean
    startDate?: boolean
    maturityDate?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DebtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "type" | "name" | "creditor" | "principalAmountCents" | "currentBalanceCents" | "currency" | "interestRate" | "marginRate" | "startDate" | "maturityDate" | "isActive" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["debt"]>
  export type DebtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    payments?: boolean | Debt$paymentsArgs<ExtArgs>
    _count?: boolean | DebtCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DebtIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type DebtIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $DebtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Debt"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      payments: Prisma.$DebtPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      type: $Enums.DebtType
      name: string
      creditor: string
      principalAmountCents: bigint
      currentBalanceCents: bigint
      currency: string
      interestRate: Prisma.Decimal | null
      marginRate: Prisma.Decimal | null
      startDate: Date
      maturityDate: Date | null
      isActive: boolean
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["debt"]>
    composites: {}
  }

  type DebtGetPayload<S extends boolean | null | undefined | DebtDefaultArgs> = $Result.GetResult<Prisma.$DebtPayload, S>

  type DebtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtCountAggregateInputType | true
    }

  export interface DebtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Debt'], meta: { name: 'Debt' } }
    /**
     * Find zero or one Debt that matches the filter.
     * @param {DebtFindUniqueArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtFindUniqueArgs>(args: SelectSubset<T, DebtFindUniqueArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Debt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtFindUniqueOrThrowArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindFirstArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtFindFirstArgs>(args?: SelectSubset<T, DebtFindFirstArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindFirstOrThrowArgs} args - Arguments to find a Debt
     * @example
     * // Get one Debt
     * const debt = await prisma.debt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Debts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debts
     * const debts = await prisma.debt.findMany()
     * 
     * // Get first 10 Debts
     * const debts = await prisma.debt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtWithIdOnly = await prisma.debt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtFindManyArgs>(args?: SelectSubset<T, DebtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Debt.
     * @param {DebtCreateArgs} args - Arguments to create a Debt.
     * @example
     * // Create one Debt
     * const Debt = await prisma.debt.create({
     *   data: {
     *     // ... data to create a Debt
     *   }
     * })
     * 
     */
    create<T extends DebtCreateArgs>(args: SelectSubset<T, DebtCreateArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Debts.
     * @param {DebtCreateManyArgs} args - Arguments to create many Debts.
     * @example
     * // Create many Debts
     * const debt = await prisma.debt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtCreateManyArgs>(args?: SelectSubset<T, DebtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Debts and returns the data saved in the database.
     * @param {DebtCreateManyAndReturnArgs} args - Arguments to create many Debts.
     * @example
     * // Create many Debts
     * const debt = await prisma.debt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Debts and only return the `id`
     * const debtWithIdOnly = await prisma.debt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DebtCreateManyAndReturnArgs>(args?: SelectSubset<T, DebtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Debt.
     * @param {DebtDeleteArgs} args - Arguments to delete one Debt.
     * @example
     * // Delete one Debt
     * const Debt = await prisma.debt.delete({
     *   where: {
     *     // ... filter to delete one Debt
     *   }
     * })
     * 
     */
    delete<T extends DebtDeleteArgs>(args: SelectSubset<T, DebtDeleteArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Debt.
     * @param {DebtUpdateArgs} args - Arguments to update one Debt.
     * @example
     * // Update one Debt
     * const debt = await prisma.debt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtUpdateArgs>(args: SelectSubset<T, DebtUpdateArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Debts.
     * @param {DebtDeleteManyArgs} args - Arguments to filter Debts to delete.
     * @example
     * // Delete a few Debts
     * const { count } = await prisma.debt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtDeleteManyArgs>(args?: SelectSubset<T, DebtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debts
     * const debt = await prisma.debt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtUpdateManyArgs>(args: SelectSubset<T, DebtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debts and returns the data updated in the database.
     * @param {DebtUpdateManyAndReturnArgs} args - Arguments to update many Debts.
     * @example
     * // Update many Debts
     * const debt = await prisma.debt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Debts and only return the `id`
     * const debtWithIdOnly = await prisma.debt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DebtUpdateManyAndReturnArgs>(args: SelectSubset<T, DebtUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Debt.
     * @param {DebtUpsertArgs} args - Arguments to update or create a Debt.
     * @example
     * // Update or create a Debt
     * const debt = await prisma.debt.upsert({
     *   create: {
     *     // ... data to create a Debt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debt we want to update
     *   }
     * })
     */
    upsert<T extends DebtUpsertArgs>(args: SelectSubset<T, DebtUpsertArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Debts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtCountArgs} args - Arguments to filter Debts to count.
     * @example
     * // Count the number of Debts
     * const count = await prisma.debt.count({
     *   where: {
     *     // ... the filter for the Debts we want to count
     *   }
     * })
    **/
    count<T extends DebtCountArgs>(
      args?: Subset<T, DebtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtAggregateArgs>(args: Subset<T, DebtAggregateArgs>): Prisma.PrismaPromise<GetDebtAggregateType<T>>

    /**
     * Group by Debt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtGroupByArgs['orderBy'] }
        : { orderBy?: DebtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Debt model
   */
  readonly fields: DebtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Debt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Debt$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Debt$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Debt model
   */
  interface DebtFieldRefs {
    readonly id: FieldRef<"Debt", 'String'>
    readonly householdId: FieldRef<"Debt", 'String'>
    readonly type: FieldRef<"Debt", 'DebtType'>
    readonly name: FieldRef<"Debt", 'String'>
    readonly creditor: FieldRef<"Debt", 'String'>
    readonly principalAmountCents: FieldRef<"Debt", 'BigInt'>
    readonly currentBalanceCents: FieldRef<"Debt", 'BigInt'>
    readonly currency: FieldRef<"Debt", 'String'>
    readonly interestRate: FieldRef<"Debt", 'Decimal'>
    readonly marginRate: FieldRef<"Debt", 'Decimal'>
    readonly startDate: FieldRef<"Debt", 'DateTime'>
    readonly maturityDate: FieldRef<"Debt", 'DateTime'>
    readonly isActive: FieldRef<"Debt", 'Boolean'>
    readonly metadata: FieldRef<"Debt", 'Json'>
    readonly createdAt: FieldRef<"Debt", 'DateTime'>
    readonly updatedAt: FieldRef<"Debt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Debt findUnique
   */
  export type DebtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt findUniqueOrThrow
   */
  export type DebtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt findFirst
   */
  export type DebtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debts.
     */
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt findFirstOrThrow
   */
  export type DebtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debt to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debts.
     */
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt findMany
   */
  export type DebtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter, which Debts to fetch.
     */
    where?: DebtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debts to fetch.
     */
    orderBy?: DebtOrderByWithRelationInput | DebtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Debts.
     */
    cursor?: DebtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debts.
     */
    skip?: number
    distinct?: DebtScalarFieldEnum | DebtScalarFieldEnum[]
  }

  /**
   * Debt create
   */
  export type DebtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The data needed to create a Debt.
     */
    data: XOR<DebtCreateInput, DebtUncheckedCreateInput>
  }

  /**
   * Debt createMany
   */
  export type DebtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Debts.
     */
    data: DebtCreateManyInput | DebtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Debt createManyAndReturn
   */
  export type DebtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * The data used to create many Debts.
     */
    data: DebtCreateManyInput | DebtCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Debt update
   */
  export type DebtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The data needed to update a Debt.
     */
    data: XOR<DebtUpdateInput, DebtUncheckedUpdateInput>
    /**
     * Choose, which Debt to update.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt updateMany
   */
  export type DebtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Debts.
     */
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyInput>
    /**
     * Filter which Debts to update
     */
    where?: DebtWhereInput
    /**
     * Limit how many Debts to update.
     */
    limit?: number
  }

  /**
   * Debt updateManyAndReturn
   */
  export type DebtUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * The data used to update Debts.
     */
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyInput>
    /**
     * Filter which Debts to update
     */
    where?: DebtWhereInput
    /**
     * Limit how many Debts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Debt upsert
   */
  export type DebtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * The filter to search for the Debt to update in case it exists.
     */
    where: DebtWhereUniqueInput
    /**
     * In case the Debt found by the `where` argument doesn't exist, create a new Debt with this data.
     */
    create: XOR<DebtCreateInput, DebtUncheckedCreateInput>
    /**
     * In case the Debt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtUpdateInput, DebtUncheckedUpdateInput>
  }

  /**
   * Debt delete
   */
  export type DebtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
    /**
     * Filter which Debt to delete.
     */
    where: DebtWhereUniqueInput
  }

  /**
   * Debt deleteMany
   */
  export type DebtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debts to delete
     */
    where?: DebtWhereInput
    /**
     * Limit how many Debts to delete.
     */
    limit?: number
  }

  /**
   * Debt.payments
   */
  export type Debt$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    where?: DebtPaymentWhereInput
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    cursor?: DebtPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * Debt without action
   */
  export type DebtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debt
     */
    select?: DebtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debt
     */
    omit?: DebtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtInclude<ExtArgs> | null
  }


  /**
   * Model DebtPayment
   */

  export type AggregateDebtPayment = {
    _count: DebtPaymentCountAggregateOutputType | null
    _avg: DebtPaymentAvgAggregateOutputType | null
    _sum: DebtPaymentSumAggregateOutputType | null
    _min: DebtPaymentMinAggregateOutputType | null
    _max: DebtPaymentMaxAggregateOutputType | null
  }

  export type DebtPaymentAvgAggregateOutputType = {
    amountCents: number | null
    principalAmountCents: number | null
    interestAmountCents: number | null
  }

  export type DebtPaymentSumAggregateOutputType = {
    amountCents: bigint | null
    principalAmountCents: bigint | null
    interestAmountCents: bigint | null
  }

  export type DebtPaymentMinAggregateOutputType = {
    id: string | null
    debtId: string | null
    amountCents: bigint | null
    currency: string | null
    paymentDate: Date | null
    principalAmountCents: bigint | null
    interestAmountCents: bigint | null
    transactionId: string | null
    createdAt: Date | null
  }

  export type DebtPaymentMaxAggregateOutputType = {
    id: string | null
    debtId: string | null
    amountCents: bigint | null
    currency: string | null
    paymentDate: Date | null
    principalAmountCents: bigint | null
    interestAmountCents: bigint | null
    transactionId: string | null
    createdAt: Date | null
  }

  export type DebtPaymentCountAggregateOutputType = {
    id: number
    debtId: number
    amountCents: number
    currency: number
    paymentDate: number
    principalAmountCents: number
    interestAmountCents: number
    transactionId: number
    createdAt: number
    _all: number
  }


  export type DebtPaymentAvgAggregateInputType = {
    amountCents?: true
    principalAmountCents?: true
    interestAmountCents?: true
  }

  export type DebtPaymentSumAggregateInputType = {
    amountCents?: true
    principalAmountCents?: true
    interestAmountCents?: true
  }

  export type DebtPaymentMinAggregateInputType = {
    id?: true
    debtId?: true
    amountCents?: true
    currency?: true
    paymentDate?: true
    principalAmountCents?: true
    interestAmountCents?: true
    transactionId?: true
    createdAt?: true
  }

  export type DebtPaymentMaxAggregateInputType = {
    id?: true
    debtId?: true
    amountCents?: true
    currency?: true
    paymentDate?: true
    principalAmountCents?: true
    interestAmountCents?: true
    transactionId?: true
    createdAt?: true
  }

  export type DebtPaymentCountAggregateInputType = {
    id?: true
    debtId?: true
    amountCents?: true
    currency?: true
    paymentDate?: true
    principalAmountCents?: true
    interestAmountCents?: true
    transactionId?: true
    createdAt?: true
    _all?: true
  }

  export type DebtPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtPayment to aggregate.
     */
    where?: DebtPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtPayments to fetch.
     */
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DebtPayments
    **/
    _count?: true | DebtPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtPaymentMaxAggregateInputType
  }

  export type GetDebtPaymentAggregateType<T extends DebtPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtPayment[P]>
      : GetScalarType<T[P], AggregateDebtPayment[P]>
  }




  export type DebtPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtPaymentWhereInput
    orderBy?: DebtPaymentOrderByWithAggregationInput | DebtPaymentOrderByWithAggregationInput[]
    by: DebtPaymentScalarFieldEnum[] | DebtPaymentScalarFieldEnum
    having?: DebtPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtPaymentCountAggregateInputType | true
    _avg?: DebtPaymentAvgAggregateInputType
    _sum?: DebtPaymentSumAggregateInputType
    _min?: DebtPaymentMinAggregateInputType
    _max?: DebtPaymentMaxAggregateInputType
  }

  export type DebtPaymentGroupByOutputType = {
    id: string
    debtId: string
    amountCents: bigint
    currency: string
    paymentDate: Date
    principalAmountCents: bigint
    interestAmountCents: bigint
    transactionId: string | null
    createdAt: Date
    _count: DebtPaymentCountAggregateOutputType | null
    _avg: DebtPaymentAvgAggregateOutputType | null
    _sum: DebtPaymentSumAggregateOutputType | null
    _min: DebtPaymentMinAggregateOutputType | null
    _max: DebtPaymentMaxAggregateOutputType | null
  }

  type GetDebtPaymentGroupByPayload<T extends DebtPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], DebtPaymentGroupByOutputType[P]>
        }
      >
    >


  export type DebtPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtId?: boolean
    amountCents?: boolean
    currency?: boolean
    paymentDate?: boolean
    principalAmountCents?: boolean
    interestAmountCents?: boolean
    transactionId?: boolean
    createdAt?: boolean
    debt?: boolean | DebtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtPayment"]>

  export type DebtPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtId?: boolean
    amountCents?: boolean
    currency?: boolean
    paymentDate?: boolean
    principalAmountCents?: boolean
    interestAmountCents?: boolean
    transactionId?: boolean
    createdAt?: boolean
    debt?: boolean | DebtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtPayment"]>

  export type DebtPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtId?: boolean
    amountCents?: boolean
    currency?: boolean
    paymentDate?: boolean
    principalAmountCents?: boolean
    interestAmountCents?: boolean
    transactionId?: boolean
    createdAt?: boolean
    debt?: boolean | DebtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtPayment"]>

  export type DebtPaymentSelectScalar = {
    id?: boolean
    debtId?: boolean
    amountCents?: boolean
    currency?: boolean
    paymentDate?: boolean
    principalAmountCents?: boolean
    interestAmountCents?: boolean
    transactionId?: boolean
    createdAt?: boolean
  }

  export type DebtPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "debtId" | "amountCents" | "currency" | "paymentDate" | "principalAmountCents" | "interestAmountCents" | "transactionId" | "createdAt", ExtArgs["result"]["debtPayment"]>
  export type DebtPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debt?: boolean | DebtDefaultArgs<ExtArgs>
  }
  export type DebtPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debt?: boolean | DebtDefaultArgs<ExtArgs>
  }
  export type DebtPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debt?: boolean | DebtDefaultArgs<ExtArgs>
  }

  export type $DebtPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DebtPayment"
    objects: {
      debt: Prisma.$DebtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      debtId: string
      amountCents: bigint
      currency: string
      paymentDate: Date
      principalAmountCents: bigint
      interestAmountCents: bigint
      transactionId: string | null
      createdAt: Date
    }, ExtArgs["result"]["debtPayment"]>
    composites: {}
  }

  type DebtPaymentGetPayload<S extends boolean | null | undefined | DebtPaymentDefaultArgs> = $Result.GetResult<Prisma.$DebtPaymentPayload, S>

  type DebtPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtPaymentCountAggregateInputType | true
    }

  export interface DebtPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DebtPayment'], meta: { name: 'DebtPayment' } }
    /**
     * Find zero or one DebtPayment that matches the filter.
     * @param {DebtPaymentFindUniqueArgs} args - Arguments to find a DebtPayment
     * @example
     * // Get one DebtPayment
     * const debtPayment = await prisma.debtPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtPaymentFindUniqueArgs>(args: SelectSubset<T, DebtPaymentFindUniqueArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DebtPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtPaymentFindUniqueOrThrowArgs} args - Arguments to find a DebtPayment
     * @example
     * // Get one DebtPayment
     * const debtPayment = await prisma.debtPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentFindFirstArgs} args - Arguments to find a DebtPayment
     * @example
     * // Get one DebtPayment
     * const debtPayment = await prisma.debtPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtPaymentFindFirstArgs>(args?: SelectSubset<T, DebtPaymentFindFirstArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentFindFirstOrThrowArgs} args - Arguments to find a DebtPayment
     * @example
     * // Get one DebtPayment
     * const debtPayment = await prisma.debtPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DebtPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DebtPayments
     * const debtPayments = await prisma.debtPayment.findMany()
     * 
     * // Get first 10 DebtPayments
     * const debtPayments = await prisma.debtPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtPaymentWithIdOnly = await prisma.debtPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtPaymentFindManyArgs>(args?: SelectSubset<T, DebtPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DebtPayment.
     * @param {DebtPaymentCreateArgs} args - Arguments to create a DebtPayment.
     * @example
     * // Create one DebtPayment
     * const DebtPayment = await prisma.debtPayment.create({
     *   data: {
     *     // ... data to create a DebtPayment
     *   }
     * })
     * 
     */
    create<T extends DebtPaymentCreateArgs>(args: SelectSubset<T, DebtPaymentCreateArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DebtPayments.
     * @param {DebtPaymentCreateManyArgs} args - Arguments to create many DebtPayments.
     * @example
     * // Create many DebtPayments
     * const debtPayment = await prisma.debtPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtPaymentCreateManyArgs>(args?: SelectSubset<T, DebtPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DebtPayments and returns the data saved in the database.
     * @param {DebtPaymentCreateManyAndReturnArgs} args - Arguments to create many DebtPayments.
     * @example
     * // Create many DebtPayments
     * const debtPayment = await prisma.debtPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DebtPayments and only return the `id`
     * const debtPaymentWithIdOnly = await prisma.debtPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DebtPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, DebtPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DebtPayment.
     * @param {DebtPaymentDeleteArgs} args - Arguments to delete one DebtPayment.
     * @example
     * // Delete one DebtPayment
     * const DebtPayment = await prisma.debtPayment.delete({
     *   where: {
     *     // ... filter to delete one DebtPayment
     *   }
     * })
     * 
     */
    delete<T extends DebtPaymentDeleteArgs>(args: SelectSubset<T, DebtPaymentDeleteArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DebtPayment.
     * @param {DebtPaymentUpdateArgs} args - Arguments to update one DebtPayment.
     * @example
     * // Update one DebtPayment
     * const debtPayment = await prisma.debtPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtPaymentUpdateArgs>(args: SelectSubset<T, DebtPaymentUpdateArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DebtPayments.
     * @param {DebtPaymentDeleteManyArgs} args - Arguments to filter DebtPayments to delete.
     * @example
     * // Delete a few DebtPayments
     * const { count } = await prisma.debtPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtPaymentDeleteManyArgs>(args?: SelectSubset<T, DebtPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DebtPayments
     * const debtPayment = await prisma.debtPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtPaymentUpdateManyArgs>(args: SelectSubset<T, DebtPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtPayments and returns the data updated in the database.
     * @param {DebtPaymentUpdateManyAndReturnArgs} args - Arguments to update many DebtPayments.
     * @example
     * // Update many DebtPayments
     * const debtPayment = await prisma.debtPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DebtPayments and only return the `id`
     * const debtPaymentWithIdOnly = await prisma.debtPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DebtPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, DebtPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DebtPayment.
     * @param {DebtPaymentUpsertArgs} args - Arguments to update or create a DebtPayment.
     * @example
     * // Update or create a DebtPayment
     * const debtPayment = await prisma.debtPayment.upsert({
     *   create: {
     *     // ... data to create a DebtPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DebtPayment we want to update
     *   }
     * })
     */
    upsert<T extends DebtPaymentUpsertArgs>(args: SelectSubset<T, DebtPaymentUpsertArgs<ExtArgs>>): Prisma__DebtPaymentClient<$Result.GetResult<Prisma.$DebtPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DebtPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentCountArgs} args - Arguments to filter DebtPayments to count.
     * @example
     * // Count the number of DebtPayments
     * const count = await prisma.debtPayment.count({
     *   where: {
     *     // ... the filter for the DebtPayments we want to count
     *   }
     * })
    **/
    count<T extends DebtPaymentCountArgs>(
      args?: Subset<T, DebtPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DebtPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtPaymentAggregateArgs>(args: Subset<T, DebtPaymentAggregateArgs>): Prisma.PrismaPromise<GetDebtPaymentAggregateType<T>>

    /**
     * Group by DebtPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtPaymentGroupByArgs['orderBy'] }
        : { orderBy?: DebtPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DebtPayment model
   */
  readonly fields: DebtPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DebtPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debt<T extends DebtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtDefaultArgs<ExtArgs>>): Prisma__DebtClient<$Result.GetResult<Prisma.$DebtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DebtPayment model
   */
  interface DebtPaymentFieldRefs {
    readonly id: FieldRef<"DebtPayment", 'String'>
    readonly debtId: FieldRef<"DebtPayment", 'String'>
    readonly amountCents: FieldRef<"DebtPayment", 'BigInt'>
    readonly currency: FieldRef<"DebtPayment", 'String'>
    readonly paymentDate: FieldRef<"DebtPayment", 'DateTime'>
    readonly principalAmountCents: FieldRef<"DebtPayment", 'BigInt'>
    readonly interestAmountCents: FieldRef<"DebtPayment", 'BigInt'>
    readonly transactionId: FieldRef<"DebtPayment", 'String'>
    readonly createdAt: FieldRef<"DebtPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DebtPayment findUnique
   */
  export type DebtPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayment to fetch.
     */
    where: DebtPaymentWhereUniqueInput
  }

  /**
   * DebtPayment findUniqueOrThrow
   */
  export type DebtPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayment to fetch.
     */
    where: DebtPaymentWhereUniqueInput
  }

  /**
   * DebtPayment findFirst
   */
  export type DebtPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayment to fetch.
     */
    where?: DebtPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtPayments to fetch.
     */
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtPayments.
     */
    cursor?: DebtPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtPayments.
     */
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * DebtPayment findFirstOrThrow
   */
  export type DebtPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayment to fetch.
     */
    where?: DebtPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtPayments to fetch.
     */
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtPayments.
     */
    cursor?: DebtPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtPayments.
     */
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * DebtPayment findMany
   */
  export type DebtPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter, which DebtPayments to fetch.
     */
    where?: DebtPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtPayments to fetch.
     */
    orderBy?: DebtPaymentOrderByWithRelationInput | DebtPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DebtPayments.
     */
    cursor?: DebtPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtPayments.
     */
    skip?: number
    distinct?: DebtPaymentScalarFieldEnum | DebtPaymentScalarFieldEnum[]
  }

  /**
   * DebtPayment create
   */
  export type DebtPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a DebtPayment.
     */
    data: XOR<DebtPaymentCreateInput, DebtPaymentUncheckedCreateInput>
  }

  /**
   * DebtPayment createMany
   */
  export type DebtPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DebtPayments.
     */
    data: DebtPaymentCreateManyInput | DebtPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DebtPayment createManyAndReturn
   */
  export type DebtPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many DebtPayments.
     */
    data: DebtPaymentCreateManyInput | DebtPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DebtPayment update
   */
  export type DebtPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a DebtPayment.
     */
    data: XOR<DebtPaymentUpdateInput, DebtPaymentUncheckedUpdateInput>
    /**
     * Choose, which DebtPayment to update.
     */
    where: DebtPaymentWhereUniqueInput
  }

  /**
   * DebtPayment updateMany
   */
  export type DebtPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DebtPayments.
     */
    data: XOR<DebtPaymentUpdateManyMutationInput, DebtPaymentUncheckedUpdateManyInput>
    /**
     * Filter which DebtPayments to update
     */
    where?: DebtPaymentWhereInput
    /**
     * Limit how many DebtPayments to update.
     */
    limit?: number
  }

  /**
   * DebtPayment updateManyAndReturn
   */
  export type DebtPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * The data used to update DebtPayments.
     */
    data: XOR<DebtPaymentUpdateManyMutationInput, DebtPaymentUncheckedUpdateManyInput>
    /**
     * Filter which DebtPayments to update
     */
    where?: DebtPaymentWhereInput
    /**
     * Limit how many DebtPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DebtPayment upsert
   */
  export type DebtPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the DebtPayment to update in case it exists.
     */
    where: DebtPaymentWhereUniqueInput
    /**
     * In case the DebtPayment found by the `where` argument doesn't exist, create a new DebtPayment with this data.
     */
    create: XOR<DebtPaymentCreateInput, DebtPaymentUncheckedCreateInput>
    /**
     * In case the DebtPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtPaymentUpdateInput, DebtPaymentUncheckedUpdateInput>
  }

  /**
   * DebtPayment delete
   */
  export type DebtPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
    /**
     * Filter which DebtPayment to delete.
     */
    where: DebtPaymentWhereUniqueInput
  }

  /**
   * DebtPayment deleteMany
   */
  export type DebtPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtPayments to delete
     */
    where?: DebtPaymentWhereInput
    /**
     * Limit how many DebtPayments to delete.
     */
    limit?: number
  }

  /**
   * DebtPayment without action
   */
  export type DebtPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtPayment
     */
    select?: DebtPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtPayment
     */
    omit?: DebtPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    totalAllocatedCents: number | null
  }

  export type BudgetSumAggregateOutputType = {
    totalAllocatedCents: bigint | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    name: string | null
    period: $Enums.BudgetPeriod | null
    totalAllocatedCents: bigint | null
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    name: string | null
    period: $Enums.BudgetPeriod | null
    totalAllocatedCents: bigint | null
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    householdId: number
    name: number
    period: number
    totalAllocatedCents: number
    currency: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    totalAllocatedCents?: true
  }

  export type BudgetSumAggregateInputType = {
    totalAllocatedCents?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    period?: true
    totalAllocatedCents?: true
    currency?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    period?: true
    totalAllocatedCents?: true
    currency?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    period?: true
    totalAllocatedCents?: true
    currency?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    householdId: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint
    currency: string
    startDate: Date
    endDate: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    period?: boolean
    totalAllocatedCents?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    categories?: boolean | Budget$categoriesArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    period?: boolean
    totalAllocatedCents?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    period?: boolean
    totalAllocatedCents?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    householdId?: boolean
    name?: boolean
    period?: boolean
    totalAllocatedCents?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "name" | "period" | "totalAllocatedCents" | "currency" | "startDate" | "endDate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["budget"]>
  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    categories?: boolean | Budget$categoriesArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      categories: Prisma.$BudgetCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      name: string
      period: $Enums.BudgetPeriod
      totalAllocatedCents: bigint
      currency: string
      startDate: Date
      endDate: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categories<T extends Budget$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Budget$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly householdId: FieldRef<"Budget", 'String'>
    readonly name: FieldRef<"Budget", 'String'>
    readonly period: FieldRef<"Budget", 'BudgetPeriod'>
    readonly totalAllocatedCents: FieldRef<"Budget", 'BigInt'>
    readonly currency: FieldRef<"Budget", 'String'>
    readonly startDate: FieldRef<"Budget", 'DateTime'>
    readonly endDate: FieldRef<"Budget", 'DateTime'>
    readonly isActive: FieldRef<"Budget", 'Boolean'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to delete.
     */
    limit?: number
  }

  /**
   * Budget.categories
   */
  export type Budget$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    where?: BudgetCategoryWhereInput
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    cursor?: BudgetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model BudgetCategory
   */

  export type AggregateBudgetCategory = {
    _count: BudgetCategoryCountAggregateOutputType | null
    _avg: BudgetCategoryAvgAggregateOutputType | null
    _sum: BudgetCategorySumAggregateOutputType | null
    _min: BudgetCategoryMinAggregateOutputType | null
    _max: BudgetCategoryMaxAggregateOutputType | null
  }

  export type BudgetCategoryAvgAggregateOutputType = {
    allocatedAmountCents: number | null
    spentAmountCents: number | null
    carryOverCents: number | null
  }

  export type BudgetCategorySumAggregateOutputType = {
    allocatedAmountCents: bigint | null
    spentAmountCents: bigint | null
    carryOverCents: bigint | null
  }

  export type BudgetCategoryMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    categoryId: string | null
    allocatedAmountCents: bigint | null
    spentAmountCents: bigint | null
    carryOverCents: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCategoryMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    categoryId: string | null
    allocatedAmountCents: bigint | null
    spentAmountCents: bigint | null
    carryOverCents: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCategoryCountAggregateOutputType = {
    id: number
    budgetId: number
    categoryId: number
    allocatedAmountCents: number
    spentAmountCents: number
    carryOverCents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetCategoryAvgAggregateInputType = {
    allocatedAmountCents?: true
    spentAmountCents?: true
    carryOverCents?: true
  }

  export type BudgetCategorySumAggregateInputType = {
    allocatedAmountCents?: true
    spentAmountCents?: true
    carryOverCents?: true
  }

  export type BudgetCategoryMinAggregateInputType = {
    id?: true
    budgetId?: true
    categoryId?: true
    allocatedAmountCents?: true
    spentAmountCents?: true
    carryOverCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCategoryMaxAggregateInputType = {
    id?: true
    budgetId?: true
    categoryId?: true
    allocatedAmountCents?: true
    spentAmountCents?: true
    carryOverCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCategoryCountAggregateInputType = {
    id?: true
    budgetId?: true
    categoryId?: true
    allocatedAmountCents?: true
    spentAmountCents?: true
    carryOverCents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetCategory to aggregate.
     */
    where?: BudgetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetCategories to fetch.
     */
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetCategories
    **/
    _count?: true | BudgetCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetCategoryMaxAggregateInputType
  }

  export type GetBudgetCategoryAggregateType<T extends BudgetCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetCategory[P]>
      : GetScalarType<T[P], AggregateBudgetCategory[P]>
  }




  export type BudgetCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetCategoryWhereInput
    orderBy?: BudgetCategoryOrderByWithAggregationInput | BudgetCategoryOrderByWithAggregationInput[]
    by: BudgetCategoryScalarFieldEnum[] | BudgetCategoryScalarFieldEnum
    having?: BudgetCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCategoryCountAggregateInputType | true
    _avg?: BudgetCategoryAvgAggregateInputType
    _sum?: BudgetCategorySumAggregateInputType
    _min?: BudgetCategoryMinAggregateInputType
    _max?: BudgetCategoryMaxAggregateInputType
  }

  export type BudgetCategoryGroupByOutputType = {
    id: string
    budgetId: string
    categoryId: string
    allocatedAmountCents: bigint
    spentAmountCents: bigint
    carryOverCents: bigint
    createdAt: Date
    updatedAt: Date
    _count: BudgetCategoryCountAggregateOutputType | null
    _avg: BudgetCategoryAvgAggregateOutputType | null
    _sum: BudgetCategorySumAggregateOutputType | null
    _min: BudgetCategoryMinAggregateOutputType | null
    _max: BudgetCategoryMaxAggregateOutputType | null
  }

  type GetBudgetCategoryGroupByPayload<T extends BudgetCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BudgetCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    categoryId?: boolean
    allocatedAmountCents?: boolean
    spentAmountCents?: boolean
    carryOverCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetCategory"]>

  export type BudgetCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    categoryId?: boolean
    allocatedAmountCents?: boolean
    spentAmountCents?: boolean
    carryOverCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetCategory"]>

  export type BudgetCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    categoryId?: boolean
    allocatedAmountCents?: boolean
    spentAmountCents?: boolean
    carryOverCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetCategory"]>

  export type BudgetCategorySelectScalar = {
    id?: boolean
    budgetId?: boolean
    categoryId?: boolean
    allocatedAmountCents?: boolean
    spentAmountCents?: boolean
    carryOverCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budgetId" | "categoryId" | "allocatedAmountCents" | "spentAmountCents" | "carryOverCents" | "createdAt" | "updatedAt", ExtArgs["result"]["budgetCategory"]>
  export type BudgetCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type BudgetCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type BudgetCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $BudgetCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetCategory"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      categoryId: string
      allocatedAmountCents: bigint
      spentAmountCents: bigint
      carryOverCents: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budgetCategory"]>
    composites: {}
  }

  type BudgetCategoryGetPayload<S extends boolean | null | undefined | BudgetCategoryDefaultArgs> = $Result.GetResult<Prisma.$BudgetCategoryPayload, S>

  type BudgetCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCategoryCountAggregateInputType | true
    }

  export interface BudgetCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetCategory'], meta: { name: 'BudgetCategory' } }
    /**
     * Find zero or one BudgetCategory that matches the filter.
     * @param {BudgetCategoryFindUniqueArgs} args - Arguments to find a BudgetCategory
     * @example
     * // Get one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetCategoryFindUniqueArgs>(args: SelectSubset<T, BudgetCategoryFindUniqueArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BudgetCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetCategoryFindUniqueOrThrowArgs} args - Arguments to find a BudgetCategory
     * @example
     * // Get one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryFindFirstArgs} args - Arguments to find a BudgetCategory
     * @example
     * // Get one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetCategoryFindFirstArgs>(args?: SelectSubset<T, BudgetCategoryFindFirstArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryFindFirstOrThrowArgs} args - Arguments to find a BudgetCategory
     * @example
     * // Get one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BudgetCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetCategories
     * const budgetCategories = await prisma.budgetCategory.findMany()
     * 
     * // Get first 10 BudgetCategories
     * const budgetCategories = await prisma.budgetCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetCategoryWithIdOnly = await prisma.budgetCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetCategoryFindManyArgs>(args?: SelectSubset<T, BudgetCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BudgetCategory.
     * @param {BudgetCategoryCreateArgs} args - Arguments to create a BudgetCategory.
     * @example
     * // Create one BudgetCategory
     * const BudgetCategory = await prisma.budgetCategory.create({
     *   data: {
     *     // ... data to create a BudgetCategory
     *   }
     * })
     * 
     */
    create<T extends BudgetCategoryCreateArgs>(args: SelectSubset<T, BudgetCategoryCreateArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BudgetCategories.
     * @param {BudgetCategoryCreateManyArgs} args - Arguments to create many BudgetCategories.
     * @example
     * // Create many BudgetCategories
     * const budgetCategory = await prisma.budgetCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCategoryCreateManyArgs>(args?: SelectSubset<T, BudgetCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetCategories and returns the data saved in the database.
     * @param {BudgetCategoryCreateManyAndReturnArgs} args - Arguments to create many BudgetCategories.
     * @example
     * // Create many BudgetCategories
     * const budgetCategory = await prisma.budgetCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetCategories and only return the `id`
     * const budgetCategoryWithIdOnly = await prisma.budgetCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BudgetCategory.
     * @param {BudgetCategoryDeleteArgs} args - Arguments to delete one BudgetCategory.
     * @example
     * // Delete one BudgetCategory
     * const BudgetCategory = await prisma.budgetCategory.delete({
     *   where: {
     *     // ... filter to delete one BudgetCategory
     *   }
     * })
     * 
     */
    delete<T extends BudgetCategoryDeleteArgs>(args: SelectSubset<T, BudgetCategoryDeleteArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BudgetCategory.
     * @param {BudgetCategoryUpdateArgs} args - Arguments to update one BudgetCategory.
     * @example
     * // Update one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetCategoryUpdateArgs>(args: SelectSubset<T, BudgetCategoryUpdateArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BudgetCategories.
     * @param {BudgetCategoryDeleteManyArgs} args - Arguments to filter BudgetCategories to delete.
     * @example
     * // Delete a few BudgetCategories
     * const { count } = await prisma.budgetCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetCategoryDeleteManyArgs>(args?: SelectSubset<T, BudgetCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetCategories
     * const budgetCategory = await prisma.budgetCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetCategoryUpdateManyArgs>(args: SelectSubset<T, BudgetCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetCategories and returns the data updated in the database.
     * @param {BudgetCategoryUpdateManyAndReturnArgs} args - Arguments to update many BudgetCategories.
     * @example
     * // Update many BudgetCategories
     * const budgetCategory = await prisma.budgetCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BudgetCategories and only return the `id`
     * const budgetCategoryWithIdOnly = await prisma.budgetCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BudgetCategory.
     * @param {BudgetCategoryUpsertArgs} args - Arguments to update or create a BudgetCategory.
     * @example
     * // Update or create a BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.upsert({
     *   create: {
     *     // ... data to create a BudgetCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetCategory we want to update
     *   }
     * })
     */
    upsert<T extends BudgetCategoryUpsertArgs>(args: SelectSubset<T, BudgetCategoryUpsertArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BudgetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryCountArgs} args - Arguments to filter BudgetCategories to count.
     * @example
     * // Count the number of BudgetCategories
     * const count = await prisma.budgetCategory.count({
     *   where: {
     *     // ... the filter for the BudgetCategories we want to count
     *   }
     * })
    **/
    count<T extends BudgetCategoryCountArgs>(
      args?: Subset<T, BudgetCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetCategoryAggregateArgs>(args: Subset<T, BudgetCategoryAggregateArgs>): Prisma.PrismaPromise<GetBudgetCategoryAggregateType<T>>

    /**
     * Group by BudgetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BudgetCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetCategory model
   */
  readonly fields: BudgetCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetCategory model
   */
  interface BudgetCategoryFieldRefs {
    readonly id: FieldRef<"BudgetCategory", 'String'>
    readonly budgetId: FieldRef<"BudgetCategory", 'String'>
    readonly categoryId: FieldRef<"BudgetCategory", 'String'>
    readonly allocatedAmountCents: FieldRef<"BudgetCategory", 'BigInt'>
    readonly spentAmountCents: FieldRef<"BudgetCategory", 'BigInt'>
    readonly carryOverCents: FieldRef<"BudgetCategory", 'BigInt'>
    readonly createdAt: FieldRef<"BudgetCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"BudgetCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BudgetCategory findUnique
   */
  export type BudgetCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategory to fetch.
     */
    where: BudgetCategoryWhereUniqueInput
  }

  /**
   * BudgetCategory findUniqueOrThrow
   */
  export type BudgetCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategory to fetch.
     */
    where: BudgetCategoryWhereUniqueInput
  }

  /**
   * BudgetCategory findFirst
   */
  export type BudgetCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategory to fetch.
     */
    where?: BudgetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetCategories to fetch.
     */
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetCategories.
     */
    cursor?: BudgetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetCategories.
     */
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * BudgetCategory findFirstOrThrow
   */
  export type BudgetCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategory to fetch.
     */
    where?: BudgetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetCategories to fetch.
     */
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetCategories.
     */
    cursor?: BudgetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetCategories.
     */
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * BudgetCategory findMany
   */
  export type BudgetCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategories to fetch.
     */
    where?: BudgetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetCategories to fetch.
     */
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetCategories.
     */
    cursor?: BudgetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetCategories.
     */
    skip?: number
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * BudgetCategory create
   */
  export type BudgetCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetCategory.
     */
    data: XOR<BudgetCategoryCreateInput, BudgetCategoryUncheckedCreateInput>
  }

  /**
   * BudgetCategory createMany
   */
  export type BudgetCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetCategories.
     */
    data: BudgetCategoryCreateManyInput | BudgetCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetCategory createManyAndReturn
   */
  export type BudgetCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many BudgetCategories.
     */
    data: BudgetCategoryCreateManyInput | BudgetCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetCategory update
   */
  export type BudgetCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetCategory.
     */
    data: XOR<BudgetCategoryUpdateInput, BudgetCategoryUncheckedUpdateInput>
    /**
     * Choose, which BudgetCategory to update.
     */
    where: BudgetCategoryWhereUniqueInput
  }

  /**
   * BudgetCategory updateMany
   */
  export type BudgetCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetCategories.
     */
    data: XOR<BudgetCategoryUpdateManyMutationInput, BudgetCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BudgetCategories to update
     */
    where?: BudgetCategoryWhereInput
    /**
     * Limit how many BudgetCategories to update.
     */
    limit?: number
  }

  /**
   * BudgetCategory updateManyAndReturn
   */
  export type BudgetCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * The data used to update BudgetCategories.
     */
    data: XOR<BudgetCategoryUpdateManyMutationInput, BudgetCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BudgetCategories to update
     */
    where?: BudgetCategoryWhereInput
    /**
     * Limit how many BudgetCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetCategory upsert
   */
  export type BudgetCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetCategory to update in case it exists.
     */
    where: BudgetCategoryWhereUniqueInput
    /**
     * In case the BudgetCategory found by the `where` argument doesn't exist, create a new BudgetCategory with this data.
     */
    create: XOR<BudgetCategoryCreateInput, BudgetCategoryUncheckedCreateInput>
    /**
     * In case the BudgetCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetCategoryUpdateInput, BudgetCategoryUncheckedUpdateInput>
  }

  /**
   * BudgetCategory delete
   */
  export type BudgetCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter which BudgetCategory to delete.
     */
    where: BudgetCategoryWhereUniqueInput
  }

  /**
   * BudgetCategory deleteMany
   */
  export type BudgetCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetCategories to delete
     */
    where?: BudgetCategoryWhereInput
    /**
     * Limit how many BudgetCategories to delete.
     */
    limit?: number
  }

  /**
   * BudgetCategory without action
   */
  export type BudgetCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetCategory
     */
    omit?: BudgetCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
  }


  /**
   * Model WishlistItem
   */

  export type AggregateWishlistItem = {
    _count: WishlistItemCountAggregateOutputType | null
    _avg: WishlistItemAvgAggregateOutputType | null
    _sum: WishlistItemSumAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  export type WishlistItemAvgAggregateOutputType = {
    currentPriceCents: number | null
    targetPriceCents: number | null
  }

  export type WishlistItemSumAggregateOutputType = {
    currentPriceCents: bigint | null
    targetPriceCents: bigint | null
  }

  export type WishlistItemMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    name: string | null
    url: string | null
    currentPriceCents: bigint | null
    targetPriceCents: bigint | null
    currency: string | null
    imageUrl: string | null
    merchant: string | null
    linkedGoalId: string | null
    isPurchased: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistItemMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    name: string | null
    url: string | null
    currentPriceCents: bigint | null
    targetPriceCents: bigint | null
    currency: string | null
    imageUrl: string | null
    merchant: string | null
    linkedGoalId: string | null
    isPurchased: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WishlistItemCountAggregateOutputType = {
    id: number
    householdId: number
    name: number
    url: number
    currentPriceCents: number
    targetPriceCents: number
    currency: number
    imageUrl: number
    merchant: number
    linkedGoalId: number
    isPurchased: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WishlistItemAvgAggregateInputType = {
    currentPriceCents?: true
    targetPriceCents?: true
  }

  export type WishlistItemSumAggregateInputType = {
    currentPriceCents?: true
    targetPriceCents?: true
  }

  export type WishlistItemMinAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    url?: true
    currentPriceCents?: true
    targetPriceCents?: true
    currency?: true
    imageUrl?: true
    merchant?: true
    linkedGoalId?: true
    isPurchased?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistItemMaxAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    url?: true
    currentPriceCents?: true
    targetPriceCents?: true
    currency?: true
    imageUrl?: true
    merchant?: true
    linkedGoalId?: true
    isPurchased?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WishlistItemCountAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    url?: true
    currentPriceCents?: true
    targetPriceCents?: true
    currency?: true
    imageUrl?: true
    merchant?: true
    linkedGoalId?: true
    isPurchased?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WishlistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItem to aggregate.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishlistItems
    **/
    _count?: true | WishlistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistItemMaxAggregateInputType
  }

  export type GetWishlistItemAggregateType<T extends WishlistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistItem[P]>
      : GetScalarType<T[P], AggregateWishlistItem[P]>
  }




  export type WishlistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithAggregationInput | WishlistItemOrderByWithAggregationInput[]
    by: WishlistItemScalarFieldEnum[] | WishlistItemScalarFieldEnum
    having?: WishlistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistItemCountAggregateInputType | true
    _avg?: WishlistItemAvgAggregateInputType
    _sum?: WishlistItemSumAggregateInputType
    _min?: WishlistItemMinAggregateInputType
    _max?: WishlistItemMaxAggregateInputType
  }

  export type WishlistItemGroupByOutputType = {
    id: string
    householdId: string
    name: string
    url: string
    currentPriceCents: bigint
    targetPriceCents: bigint | null
    currency: string
    imageUrl: string | null
    merchant: string
    linkedGoalId: string | null
    isPurchased: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: WishlistItemCountAggregateOutputType | null
    _avg: WishlistItemAvgAggregateOutputType | null
    _sum: WishlistItemSumAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  type GetWishlistItemGroupByPayload<T extends WishlistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
        }
      >
    >


  export type WishlistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    url?: boolean
    currentPriceCents?: boolean
    targetPriceCents?: boolean
    currency?: boolean
    imageUrl?: boolean
    merchant?: boolean
    linkedGoalId?: boolean
    isPurchased?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    priceHistory?: boolean | WishlistItem$priceHistoryArgs<ExtArgs>
    _count?: boolean | WishlistItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    url?: boolean
    currentPriceCents?: boolean
    targetPriceCents?: boolean
    currency?: boolean
    imageUrl?: boolean
    merchant?: boolean
    linkedGoalId?: boolean
    isPurchased?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    url?: boolean
    currentPriceCents?: boolean
    targetPriceCents?: boolean
    currency?: boolean
    imageUrl?: boolean
    merchant?: boolean
    linkedGoalId?: boolean
    isPurchased?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectScalar = {
    id?: boolean
    householdId?: boolean
    name?: boolean
    url?: boolean
    currentPriceCents?: boolean
    targetPriceCents?: boolean
    currency?: boolean
    imageUrl?: boolean
    merchant?: boolean
    linkedGoalId?: boolean
    isPurchased?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WishlistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "name" | "url" | "currentPriceCents" | "targetPriceCents" | "currency" | "imageUrl" | "merchant" | "linkedGoalId" | "isPurchased" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["wishlistItem"]>
  export type WishlistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    priceHistory?: boolean | WishlistItem$priceHistoryArgs<ExtArgs>
    _count?: boolean | WishlistItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WishlistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WishlistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WishlistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WishlistItem"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      priceHistory: Prisma.$PriceHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      name: string
      url: string
      currentPriceCents: bigint
      targetPriceCents: bigint | null
      currency: string
      imageUrl: string | null
      merchant: string
      linkedGoalId: string | null
      isPurchased: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wishlistItem"]>
    composites: {}
  }

  type WishlistItemGetPayload<S extends boolean | null | undefined | WishlistItemDefaultArgs> = $Result.GetResult<Prisma.$WishlistItemPayload, S>

  type WishlistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WishlistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WishlistItemCountAggregateInputType | true
    }

  export interface WishlistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WishlistItem'], meta: { name: 'WishlistItem' } }
    /**
     * Find zero or one WishlistItem that matches the filter.
     * @param {WishlistItemFindUniqueArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistItemFindUniqueArgs>(args: SelectSubset<T, WishlistItemFindUniqueArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WishlistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistItemFindUniqueOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistItemFindFirstArgs>(args?: SelectSubset<T, WishlistItemFindFirstArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WishlistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany()
     * 
     * // Get first 10 WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistItemFindManyArgs>(args?: SelectSubset<T, WishlistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WishlistItem.
     * @param {WishlistItemCreateArgs} args - Arguments to create a WishlistItem.
     * @example
     * // Create one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.create({
     *   data: {
     *     // ... data to create a WishlistItem
     *   }
     * })
     * 
     */
    create<T extends WishlistItemCreateArgs>(args: SelectSubset<T, WishlistItemCreateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WishlistItems.
     * @param {WishlistItemCreateManyArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistItemCreateManyArgs>(args?: SelectSubset<T, WishlistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WishlistItems and returns the data saved in the database.
     * @param {WishlistItemCreateManyAndReturnArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishlistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WishlistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WishlistItem.
     * @param {WishlistItemDeleteArgs} args - Arguments to delete one WishlistItem.
     * @example
     * // Delete one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.delete({
     *   where: {
     *     // ... filter to delete one WishlistItem
     *   }
     * })
     * 
     */
    delete<T extends WishlistItemDeleteArgs>(args: SelectSubset<T, WishlistItemDeleteArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WishlistItem.
     * @param {WishlistItemUpdateArgs} args - Arguments to update one WishlistItem.
     * @example
     * // Update one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistItemUpdateArgs>(args: SelectSubset<T, WishlistItemUpdateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WishlistItems.
     * @param {WishlistItemDeleteManyArgs} args - Arguments to filter WishlistItems to delete.
     * @example
     * // Delete a few WishlistItems
     * const { count } = await prisma.wishlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistItemDeleteManyArgs>(args?: SelectSubset<T, WishlistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistItemUpdateManyArgs>(args: SelectSubset<T, WishlistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems and returns the data updated in the database.
     * @param {WishlistItemUpdateManyAndReturnArgs} args - Arguments to update many WishlistItems.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WishlistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, WishlistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WishlistItem.
     * @param {WishlistItemUpsertArgs} args - Arguments to update or create a WishlistItem.
     * @example
     * // Update or create a WishlistItem
     * const wishlistItem = await prisma.wishlistItem.upsert({
     *   create: {
     *     // ... data to create a WishlistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistItem we want to update
     *   }
     * })
     */
    upsert<T extends WishlistItemUpsertArgs>(args: SelectSubset<T, WishlistItemUpsertArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemCountArgs} args - Arguments to filter WishlistItems to count.
     * @example
     * // Count the number of WishlistItems
     * const count = await prisma.wishlistItem.count({
     *   where: {
     *     // ... the filter for the WishlistItems we want to count
     *   }
     * })
    **/
    count<T extends WishlistItemCountArgs>(
      args?: Subset<T, WishlistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistItemAggregateArgs>(args: Subset<T, WishlistItemAggregateArgs>): Prisma.PrismaPromise<GetWishlistItemAggregateType<T>>

    /**
     * Group by WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistItemGroupByArgs['orderBy'] }
        : { orderBy?: WishlistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WishlistItem model
   */
  readonly fields: WishlistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    priceHistory<T extends WishlistItem$priceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, WishlistItem$priceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WishlistItem model
   */
  interface WishlistItemFieldRefs {
    readonly id: FieldRef<"WishlistItem", 'String'>
    readonly householdId: FieldRef<"WishlistItem", 'String'>
    readonly name: FieldRef<"WishlistItem", 'String'>
    readonly url: FieldRef<"WishlistItem", 'String'>
    readonly currentPriceCents: FieldRef<"WishlistItem", 'BigInt'>
    readonly targetPriceCents: FieldRef<"WishlistItem", 'BigInt'>
    readonly currency: FieldRef<"WishlistItem", 'String'>
    readonly imageUrl: FieldRef<"WishlistItem", 'String'>
    readonly merchant: FieldRef<"WishlistItem", 'String'>
    readonly linkedGoalId: FieldRef<"WishlistItem", 'String'>
    readonly isPurchased: FieldRef<"WishlistItem", 'Boolean'>
    readonly createdBy: FieldRef<"WishlistItem", 'String'>
    readonly createdAt: FieldRef<"WishlistItem", 'DateTime'>
    readonly updatedAt: FieldRef<"WishlistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WishlistItem findUnique
   */
  export type WishlistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findUniqueOrThrow
   */
  export type WishlistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findFirst
   */
  export type WishlistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findFirstOrThrow
   */
  export type WishlistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findMany
   */
  export type WishlistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItems to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem create
   */
  export type WishlistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WishlistItem.
     */
    data: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
  }

  /**
   * WishlistItem createMany
   */
  export type WishlistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WishlistItem createManyAndReturn
   */
  export type WishlistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistItem update
   */
  export type WishlistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WishlistItem.
     */
    data: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
    /**
     * Choose, which WishlistItem to update.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem updateMany
   */
  export type WishlistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to update.
     */
    limit?: number
  }

  /**
   * WishlistItem updateManyAndReturn
   */
  export type WishlistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistItem upsert
   */
  export type WishlistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WishlistItem to update in case it exists.
     */
    where: WishlistItemWhereUniqueInput
    /**
     * In case the WishlistItem found by the `where` argument doesn't exist, create a new WishlistItem with this data.
     */
    create: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
    /**
     * In case the WishlistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
  }

  /**
   * WishlistItem delete
   */
  export type WishlistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter which WishlistItem to delete.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem deleteMany
   */
  export type WishlistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItems to delete
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to delete.
     */
    limit?: number
  }

  /**
   * WishlistItem.priceHistory
   */
  export type WishlistItem$priceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    cursor?: PriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * WishlistItem without action
   */
  export type WishlistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
  }


  /**
   * Model PriceHistory
   */

  export type AggregatePriceHistory = {
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  export type PriceHistoryAvgAggregateOutputType = {
    priceCents: number | null
  }

  export type PriceHistorySumAggregateOutputType = {
    priceCents: bigint | null
  }

  export type PriceHistoryMinAggregateOutputType = {
    id: string | null
    wishlistItemId: string | null
    priceCents: bigint | null
    currency: string | null
    recordedAt: Date | null
  }

  export type PriceHistoryMaxAggregateOutputType = {
    id: string | null
    wishlistItemId: string | null
    priceCents: bigint | null
    currency: string | null
    recordedAt: Date | null
  }

  export type PriceHistoryCountAggregateOutputType = {
    id: number
    wishlistItemId: number
    priceCents: number
    currency: number
    recordedAt: number
    _all: number
  }


  export type PriceHistoryAvgAggregateInputType = {
    priceCents?: true
  }

  export type PriceHistorySumAggregateInputType = {
    priceCents?: true
  }

  export type PriceHistoryMinAggregateInputType = {
    id?: true
    wishlistItemId?: true
    priceCents?: true
    currency?: true
    recordedAt?: true
  }

  export type PriceHistoryMaxAggregateInputType = {
    id?: true
    wishlistItemId?: true
    priceCents?: true
    currency?: true
    recordedAt?: true
  }

  export type PriceHistoryCountAggregateInputType = {
    id?: true
    wishlistItemId?: true
    priceCents?: true
    currency?: true
    recordedAt?: true
    _all?: true
  }

  export type PriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistory to aggregate.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceHistories
    **/
    _count?: true | PriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type GetPriceHistoryAggregateType<T extends PriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceHistory[P]>
      : GetScalarType<T[P], AggregatePriceHistory[P]>
  }




  export type PriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithAggregationInput | PriceHistoryOrderByWithAggregationInput[]
    by: PriceHistoryScalarFieldEnum[] | PriceHistoryScalarFieldEnum
    having?: PriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceHistoryCountAggregateInputType | true
    _avg?: PriceHistoryAvgAggregateInputType
    _sum?: PriceHistorySumAggregateInputType
    _min?: PriceHistoryMinAggregateInputType
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type PriceHistoryGroupByOutputType = {
    id: string
    wishlistItemId: string
    priceCents: bigint
    currency: string
    recordedAt: Date
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  type GetPriceHistoryGroupByPayload<T extends PriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wishlistItemId?: boolean
    priceCents?: boolean
    currency?: boolean
    recordedAt?: boolean
    wishlistItem?: boolean | WishlistItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wishlistItemId?: boolean
    priceCents?: boolean
    currency?: boolean
    recordedAt?: boolean
    wishlistItem?: boolean | WishlistItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wishlistItemId?: boolean
    priceCents?: boolean
    currency?: boolean
    recordedAt?: boolean
    wishlistItem?: boolean | WishlistItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectScalar = {
    id?: boolean
    wishlistItemId?: boolean
    priceCents?: boolean
    currency?: boolean
    recordedAt?: boolean
  }

  export type PriceHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wishlistItemId" | "priceCents" | "currency" | "recordedAt", ExtArgs["result"]["priceHistory"]>
  export type PriceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wishlistItem?: boolean | WishlistItemDefaultArgs<ExtArgs>
  }
  export type PriceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wishlistItem?: boolean | WishlistItemDefaultArgs<ExtArgs>
  }
  export type PriceHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wishlistItem?: boolean | WishlistItemDefaultArgs<ExtArgs>
  }

  export type $PriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceHistory"
    objects: {
      wishlistItem: Prisma.$WishlistItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      wishlistItemId: string
      priceCents: bigint
      currency: string
      recordedAt: Date
    }, ExtArgs["result"]["priceHistory"]>
    composites: {}
  }

  type PriceHistoryGetPayload<S extends boolean | null | undefined | PriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$PriceHistoryPayload, S>

  type PriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceHistoryCountAggregateInputType | true
    }

  export interface PriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceHistory'], meta: { name: 'PriceHistory' } }
    /**
     * Find zero or one PriceHistory that matches the filter.
     * @param {PriceHistoryFindUniqueArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceHistoryFindUniqueArgs>(args: SelectSubset<T, PriceHistoryFindUniqueArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceHistoryFindFirstArgs>(args?: SelectSubset<T, PriceHistoryFindFirstArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany()
     * 
     * // Get first 10 PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceHistoryFindManyArgs>(args?: SelectSubset<T, PriceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceHistory.
     * @param {PriceHistoryCreateArgs} args - Arguments to create a PriceHistory.
     * @example
     * // Create one PriceHistory
     * const PriceHistory = await prisma.priceHistory.create({
     *   data: {
     *     // ... data to create a PriceHistory
     *   }
     * })
     * 
     */
    create<T extends PriceHistoryCreateArgs>(args: SelectSubset<T, PriceHistoryCreateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceHistories.
     * @param {PriceHistoryCreateManyArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceHistoryCreateManyArgs>(args?: SelectSubset<T, PriceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceHistories and returns the data saved in the database.
     * @param {PriceHistoryCreateManyAndReturnArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceHistories and only return the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceHistory.
     * @param {PriceHistoryDeleteArgs} args - Arguments to delete one PriceHistory.
     * @example
     * // Delete one PriceHistory
     * const PriceHistory = await prisma.priceHistory.delete({
     *   where: {
     *     // ... filter to delete one PriceHistory
     *   }
     * })
     * 
     */
    delete<T extends PriceHistoryDeleteArgs>(args: SelectSubset<T, PriceHistoryDeleteArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceHistory.
     * @param {PriceHistoryUpdateArgs} args - Arguments to update one PriceHistory.
     * @example
     * // Update one PriceHistory
     * const priceHistory = await prisma.priceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceHistoryUpdateArgs>(args: SelectSubset<T, PriceHistoryUpdateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceHistories.
     * @param {PriceHistoryDeleteManyArgs} args - Arguments to filter PriceHistories to delete.
     * @example
     * // Delete a few PriceHistories
     * const { count } = await prisma.priceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceHistoryDeleteManyArgs>(args?: SelectSubset<T, PriceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceHistoryUpdateManyArgs>(args: SelectSubset<T, PriceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories and returns the data updated in the database.
     * @param {PriceHistoryUpdateManyAndReturnArgs} args - Arguments to update many PriceHistories.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceHistories and only return the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceHistory.
     * @param {PriceHistoryUpsertArgs} args - Arguments to update or create a PriceHistory.
     * @example
     * // Update or create a PriceHistory
     * const priceHistory = await prisma.priceHistory.upsert({
     *   create: {
     *     // ... data to create a PriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceHistory we want to update
     *   }
     * })
     */
    upsert<T extends PriceHistoryUpsertArgs>(args: SelectSubset<T, PriceHistoryUpsertArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryCountArgs} args - Arguments to filter PriceHistories to count.
     * @example
     * // Count the number of PriceHistories
     * const count = await prisma.priceHistory.count({
     *   where: {
     *     // ... the filter for the PriceHistories we want to count
     *   }
     * })
    **/
    count<T extends PriceHistoryCountArgs>(
      args?: Subset<T, PriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceHistoryAggregateArgs>(args: Subset<T, PriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetPriceHistoryAggregateType<T>>

    /**
     * Group by PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceHistory model
   */
  readonly fields: PriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wishlistItem<T extends WishlistItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WishlistItemDefaultArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceHistory model
   */
  interface PriceHistoryFieldRefs {
    readonly id: FieldRef<"PriceHistory", 'String'>
    readonly wishlistItemId: FieldRef<"PriceHistory", 'String'>
    readonly priceCents: FieldRef<"PriceHistory", 'BigInt'>
    readonly currency: FieldRef<"PriceHistory", 'String'>
    readonly recordedAt: FieldRef<"PriceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceHistory findUnique
   */
  export type PriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findUniqueOrThrow
   */
  export type PriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findFirst
   */
  export type PriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findFirstOrThrow
   */
  export type PriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findMany
   */
  export type PriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistories to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory create
   */
  export type PriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceHistory.
     */
    data: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
  }

  /**
   * PriceHistory createMany
   */
  export type PriceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceHistory createManyAndReturn
   */
  export type PriceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceHistory update
   */
  export type PriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceHistory.
     */
    data: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which PriceHistory to update.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory updateMany
   */
  export type PriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to update.
     */
    limit?: number
  }

  /**
   * PriceHistory updateManyAndReturn
   */
  export type PriceHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceHistory upsert
   */
  export type PriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceHistory to update in case it exists.
     */
    where: PriceHistoryWhereUniqueInput
    /**
     * In case the PriceHistory found by the `where` argument doesn't exist, create a new PriceHistory with this data.
     */
    create: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
    /**
     * In case the PriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
  }

  /**
   * PriceHistory delete
   */
  export type PriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which PriceHistory to delete.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory deleteMany
   */
  export type PriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistories to delete
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to delete.
     */
    limit?: number
  }

  /**
   * PriceHistory without action
   */
  export type PriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model GratitudeEntry
   */

  export type AggregateGratitudeEntry = {
    _count: GratitudeEntryCountAggregateOutputType | null
    _avg: GratitudeEntryAvgAggregateOutputType | null
    _sum: GratitudeEntrySumAggregateOutputType | null
    _min: GratitudeEntryMinAggregateOutputType | null
    _max: GratitudeEntryMaxAggregateOutputType | null
  }

  export type GratitudeEntryAvgAggregateOutputType = {
    estimatedValueCents: number | null
  }

  export type GratitudeEntrySumAggregateOutputType = {
    estimatedValueCents: bigint | null
  }

  export type GratitudeEntryMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    giver: string | null
    type: $Enums.GratitudeType | null
    categoryId: string | null
    transactionId: string | null
    estimatedValueCents: bigint | null
    currency: string | null
    description: string | null
    date: Date | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type GratitudeEntryMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    giver: string | null
    type: $Enums.GratitudeType | null
    categoryId: string | null
    transactionId: string | null
    estimatedValueCents: bigint | null
    currency: string | null
    description: string | null
    date: Date | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type GratitudeEntryCountAggregateOutputType = {
    id: number
    householdId: number
    giver: number
    type: number
    categoryId: number
    transactionId: number
    estimatedValueCents: number
    currency: number
    description: number
    date: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type GratitudeEntryAvgAggregateInputType = {
    estimatedValueCents?: true
  }

  export type GratitudeEntrySumAggregateInputType = {
    estimatedValueCents?: true
  }

  export type GratitudeEntryMinAggregateInputType = {
    id?: true
    householdId?: true
    giver?: true
    type?: true
    categoryId?: true
    transactionId?: true
    estimatedValueCents?: true
    currency?: true
    description?: true
    date?: true
    createdBy?: true
    createdAt?: true
  }

  export type GratitudeEntryMaxAggregateInputType = {
    id?: true
    householdId?: true
    giver?: true
    type?: true
    categoryId?: true
    transactionId?: true
    estimatedValueCents?: true
    currency?: true
    description?: true
    date?: true
    createdBy?: true
    createdAt?: true
  }

  export type GratitudeEntryCountAggregateInputType = {
    id?: true
    householdId?: true
    giver?: true
    type?: true
    categoryId?: true
    transactionId?: true
    estimatedValueCents?: true
    currency?: true
    description?: true
    date?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type GratitudeEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GratitudeEntry to aggregate.
     */
    where?: GratitudeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GratitudeEntries to fetch.
     */
    orderBy?: GratitudeEntryOrderByWithRelationInput | GratitudeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GratitudeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GratitudeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GratitudeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GratitudeEntries
    **/
    _count?: true | GratitudeEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GratitudeEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GratitudeEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GratitudeEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GratitudeEntryMaxAggregateInputType
  }

  export type GetGratitudeEntryAggregateType<T extends GratitudeEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateGratitudeEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGratitudeEntry[P]>
      : GetScalarType<T[P], AggregateGratitudeEntry[P]>
  }




  export type GratitudeEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GratitudeEntryWhereInput
    orderBy?: GratitudeEntryOrderByWithAggregationInput | GratitudeEntryOrderByWithAggregationInput[]
    by: GratitudeEntryScalarFieldEnum[] | GratitudeEntryScalarFieldEnum
    having?: GratitudeEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GratitudeEntryCountAggregateInputType | true
    _avg?: GratitudeEntryAvgAggregateInputType
    _sum?: GratitudeEntrySumAggregateInputType
    _min?: GratitudeEntryMinAggregateInputType
    _max?: GratitudeEntryMaxAggregateInputType
  }

  export type GratitudeEntryGroupByOutputType = {
    id: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    categoryId: string | null
    transactionId: string | null
    estimatedValueCents: bigint | null
    currency: string | null
    description: string
    date: Date
    createdBy: string
    createdAt: Date
    _count: GratitudeEntryCountAggregateOutputType | null
    _avg: GratitudeEntryAvgAggregateOutputType | null
    _sum: GratitudeEntrySumAggregateOutputType | null
    _min: GratitudeEntryMinAggregateOutputType | null
    _max: GratitudeEntryMaxAggregateOutputType | null
  }

  type GetGratitudeEntryGroupByPayload<T extends GratitudeEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GratitudeEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GratitudeEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GratitudeEntryGroupByOutputType[P]>
            : GetScalarType<T[P], GratitudeEntryGroupByOutputType[P]>
        }
      >
    >


  export type GratitudeEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    giver?: boolean
    type?: boolean
    categoryId?: boolean
    transactionId?: boolean
    estimatedValueCents?: boolean
    currency?: boolean
    description?: boolean
    date?: boolean
    createdBy?: boolean
    createdAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    category?: boolean | GratitudeEntry$categoryArgs<ExtArgs>
    transaction?: boolean | GratitudeEntry$transactionArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gratitudeEntry"]>

  export type GratitudeEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    giver?: boolean
    type?: boolean
    categoryId?: boolean
    transactionId?: boolean
    estimatedValueCents?: boolean
    currency?: boolean
    description?: boolean
    date?: boolean
    createdBy?: boolean
    createdAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    category?: boolean | GratitudeEntry$categoryArgs<ExtArgs>
    transaction?: boolean | GratitudeEntry$transactionArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gratitudeEntry"]>

  export type GratitudeEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    giver?: boolean
    type?: boolean
    categoryId?: boolean
    transactionId?: boolean
    estimatedValueCents?: boolean
    currency?: boolean
    description?: boolean
    date?: boolean
    createdBy?: boolean
    createdAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    category?: boolean | GratitudeEntry$categoryArgs<ExtArgs>
    transaction?: boolean | GratitudeEntry$transactionArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gratitudeEntry"]>

  export type GratitudeEntrySelectScalar = {
    id?: boolean
    householdId?: boolean
    giver?: boolean
    type?: boolean
    categoryId?: boolean
    transactionId?: boolean
    estimatedValueCents?: boolean
    currency?: boolean
    description?: boolean
    date?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type GratitudeEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "giver" | "type" | "categoryId" | "transactionId" | "estimatedValueCents" | "currency" | "description" | "date" | "createdBy" | "createdAt", ExtArgs["result"]["gratitudeEntry"]>
  export type GratitudeEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    category?: boolean | GratitudeEntry$categoryArgs<ExtArgs>
    transaction?: boolean | GratitudeEntry$transactionArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GratitudeEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    category?: boolean | GratitudeEntry$categoryArgs<ExtArgs>
    transaction?: boolean | GratitudeEntry$transactionArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GratitudeEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    category?: boolean | GratitudeEntry$categoryArgs<ExtArgs>
    transaction?: boolean | GratitudeEntry$transactionArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GratitudeEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GratitudeEntry"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      giver: string
      type: $Enums.GratitudeType
      categoryId: string | null
      transactionId: string | null
      estimatedValueCents: bigint | null
      currency: string | null
      description: string
      date: Date
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["gratitudeEntry"]>
    composites: {}
  }

  type GratitudeEntryGetPayload<S extends boolean | null | undefined | GratitudeEntryDefaultArgs> = $Result.GetResult<Prisma.$GratitudeEntryPayload, S>

  type GratitudeEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GratitudeEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GratitudeEntryCountAggregateInputType | true
    }

  export interface GratitudeEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GratitudeEntry'], meta: { name: 'GratitudeEntry' } }
    /**
     * Find zero or one GratitudeEntry that matches the filter.
     * @param {GratitudeEntryFindUniqueArgs} args - Arguments to find a GratitudeEntry
     * @example
     * // Get one GratitudeEntry
     * const gratitudeEntry = await prisma.gratitudeEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GratitudeEntryFindUniqueArgs>(args: SelectSubset<T, GratitudeEntryFindUniqueArgs<ExtArgs>>): Prisma__GratitudeEntryClient<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GratitudeEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GratitudeEntryFindUniqueOrThrowArgs} args - Arguments to find a GratitudeEntry
     * @example
     * // Get one GratitudeEntry
     * const gratitudeEntry = await prisma.gratitudeEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GratitudeEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, GratitudeEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GratitudeEntryClient<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GratitudeEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratitudeEntryFindFirstArgs} args - Arguments to find a GratitudeEntry
     * @example
     * // Get one GratitudeEntry
     * const gratitudeEntry = await prisma.gratitudeEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GratitudeEntryFindFirstArgs>(args?: SelectSubset<T, GratitudeEntryFindFirstArgs<ExtArgs>>): Prisma__GratitudeEntryClient<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GratitudeEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratitudeEntryFindFirstOrThrowArgs} args - Arguments to find a GratitudeEntry
     * @example
     * // Get one GratitudeEntry
     * const gratitudeEntry = await prisma.gratitudeEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GratitudeEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, GratitudeEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__GratitudeEntryClient<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GratitudeEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratitudeEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GratitudeEntries
     * const gratitudeEntries = await prisma.gratitudeEntry.findMany()
     * 
     * // Get first 10 GratitudeEntries
     * const gratitudeEntries = await prisma.gratitudeEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gratitudeEntryWithIdOnly = await prisma.gratitudeEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GratitudeEntryFindManyArgs>(args?: SelectSubset<T, GratitudeEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GratitudeEntry.
     * @param {GratitudeEntryCreateArgs} args - Arguments to create a GratitudeEntry.
     * @example
     * // Create one GratitudeEntry
     * const GratitudeEntry = await prisma.gratitudeEntry.create({
     *   data: {
     *     // ... data to create a GratitudeEntry
     *   }
     * })
     * 
     */
    create<T extends GratitudeEntryCreateArgs>(args: SelectSubset<T, GratitudeEntryCreateArgs<ExtArgs>>): Prisma__GratitudeEntryClient<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GratitudeEntries.
     * @param {GratitudeEntryCreateManyArgs} args - Arguments to create many GratitudeEntries.
     * @example
     * // Create many GratitudeEntries
     * const gratitudeEntry = await prisma.gratitudeEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GratitudeEntryCreateManyArgs>(args?: SelectSubset<T, GratitudeEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GratitudeEntries and returns the data saved in the database.
     * @param {GratitudeEntryCreateManyAndReturnArgs} args - Arguments to create many GratitudeEntries.
     * @example
     * // Create many GratitudeEntries
     * const gratitudeEntry = await prisma.gratitudeEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GratitudeEntries and only return the `id`
     * const gratitudeEntryWithIdOnly = await prisma.gratitudeEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GratitudeEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, GratitudeEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GratitudeEntry.
     * @param {GratitudeEntryDeleteArgs} args - Arguments to delete one GratitudeEntry.
     * @example
     * // Delete one GratitudeEntry
     * const GratitudeEntry = await prisma.gratitudeEntry.delete({
     *   where: {
     *     // ... filter to delete one GratitudeEntry
     *   }
     * })
     * 
     */
    delete<T extends GratitudeEntryDeleteArgs>(args: SelectSubset<T, GratitudeEntryDeleteArgs<ExtArgs>>): Prisma__GratitudeEntryClient<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GratitudeEntry.
     * @param {GratitudeEntryUpdateArgs} args - Arguments to update one GratitudeEntry.
     * @example
     * // Update one GratitudeEntry
     * const gratitudeEntry = await prisma.gratitudeEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GratitudeEntryUpdateArgs>(args: SelectSubset<T, GratitudeEntryUpdateArgs<ExtArgs>>): Prisma__GratitudeEntryClient<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GratitudeEntries.
     * @param {GratitudeEntryDeleteManyArgs} args - Arguments to filter GratitudeEntries to delete.
     * @example
     * // Delete a few GratitudeEntries
     * const { count } = await prisma.gratitudeEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GratitudeEntryDeleteManyArgs>(args?: SelectSubset<T, GratitudeEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GratitudeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratitudeEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GratitudeEntries
     * const gratitudeEntry = await prisma.gratitudeEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GratitudeEntryUpdateManyArgs>(args: SelectSubset<T, GratitudeEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GratitudeEntries and returns the data updated in the database.
     * @param {GratitudeEntryUpdateManyAndReturnArgs} args - Arguments to update many GratitudeEntries.
     * @example
     * // Update many GratitudeEntries
     * const gratitudeEntry = await prisma.gratitudeEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GratitudeEntries and only return the `id`
     * const gratitudeEntryWithIdOnly = await prisma.gratitudeEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GratitudeEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, GratitudeEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GratitudeEntry.
     * @param {GratitudeEntryUpsertArgs} args - Arguments to update or create a GratitudeEntry.
     * @example
     * // Update or create a GratitudeEntry
     * const gratitudeEntry = await prisma.gratitudeEntry.upsert({
     *   create: {
     *     // ... data to create a GratitudeEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GratitudeEntry we want to update
     *   }
     * })
     */
    upsert<T extends GratitudeEntryUpsertArgs>(args: SelectSubset<T, GratitudeEntryUpsertArgs<ExtArgs>>): Prisma__GratitudeEntryClient<$Result.GetResult<Prisma.$GratitudeEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GratitudeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratitudeEntryCountArgs} args - Arguments to filter GratitudeEntries to count.
     * @example
     * // Count the number of GratitudeEntries
     * const count = await prisma.gratitudeEntry.count({
     *   where: {
     *     // ... the filter for the GratitudeEntries we want to count
     *   }
     * })
    **/
    count<T extends GratitudeEntryCountArgs>(
      args?: Subset<T, GratitudeEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GratitudeEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GratitudeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratitudeEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GratitudeEntryAggregateArgs>(args: Subset<T, GratitudeEntryAggregateArgs>): Prisma.PrismaPromise<GetGratitudeEntryAggregateType<T>>

    /**
     * Group by GratitudeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GratitudeEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GratitudeEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GratitudeEntryGroupByArgs['orderBy'] }
        : { orderBy?: GratitudeEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GratitudeEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGratitudeEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GratitudeEntry model
   */
  readonly fields: GratitudeEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GratitudeEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GratitudeEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends GratitudeEntry$categoryArgs<ExtArgs> = {}>(args?: Subset<T, GratitudeEntry$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends GratitudeEntry$transactionArgs<ExtArgs> = {}>(args?: Subset<T, GratitudeEntry$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GratitudeEntry model
   */
  interface GratitudeEntryFieldRefs {
    readonly id: FieldRef<"GratitudeEntry", 'String'>
    readonly householdId: FieldRef<"GratitudeEntry", 'String'>
    readonly giver: FieldRef<"GratitudeEntry", 'String'>
    readonly type: FieldRef<"GratitudeEntry", 'GratitudeType'>
    readonly categoryId: FieldRef<"GratitudeEntry", 'String'>
    readonly transactionId: FieldRef<"GratitudeEntry", 'String'>
    readonly estimatedValueCents: FieldRef<"GratitudeEntry", 'BigInt'>
    readonly currency: FieldRef<"GratitudeEntry", 'String'>
    readonly description: FieldRef<"GratitudeEntry", 'String'>
    readonly date: FieldRef<"GratitudeEntry", 'DateTime'>
    readonly createdBy: FieldRef<"GratitudeEntry", 'String'>
    readonly createdAt: FieldRef<"GratitudeEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GratitudeEntry findUnique
   */
  export type GratitudeEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GratitudeEntry to fetch.
     */
    where: GratitudeEntryWhereUniqueInput
  }

  /**
   * GratitudeEntry findUniqueOrThrow
   */
  export type GratitudeEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GratitudeEntry to fetch.
     */
    where: GratitudeEntryWhereUniqueInput
  }

  /**
   * GratitudeEntry findFirst
   */
  export type GratitudeEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GratitudeEntry to fetch.
     */
    where?: GratitudeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GratitudeEntries to fetch.
     */
    orderBy?: GratitudeEntryOrderByWithRelationInput | GratitudeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GratitudeEntries.
     */
    cursor?: GratitudeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GratitudeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GratitudeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GratitudeEntries.
     */
    distinct?: GratitudeEntryScalarFieldEnum | GratitudeEntryScalarFieldEnum[]
  }

  /**
   * GratitudeEntry findFirstOrThrow
   */
  export type GratitudeEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GratitudeEntry to fetch.
     */
    where?: GratitudeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GratitudeEntries to fetch.
     */
    orderBy?: GratitudeEntryOrderByWithRelationInput | GratitudeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GratitudeEntries.
     */
    cursor?: GratitudeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GratitudeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GratitudeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GratitudeEntries.
     */
    distinct?: GratitudeEntryScalarFieldEnum | GratitudeEntryScalarFieldEnum[]
  }

  /**
   * GratitudeEntry findMany
   */
  export type GratitudeEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GratitudeEntries to fetch.
     */
    where?: GratitudeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GratitudeEntries to fetch.
     */
    orderBy?: GratitudeEntryOrderByWithRelationInput | GratitudeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GratitudeEntries.
     */
    cursor?: GratitudeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GratitudeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GratitudeEntries.
     */
    skip?: number
    distinct?: GratitudeEntryScalarFieldEnum | GratitudeEntryScalarFieldEnum[]
  }

  /**
   * GratitudeEntry create
   */
  export type GratitudeEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a GratitudeEntry.
     */
    data: XOR<GratitudeEntryCreateInput, GratitudeEntryUncheckedCreateInput>
  }

  /**
   * GratitudeEntry createMany
   */
  export type GratitudeEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GratitudeEntries.
     */
    data: GratitudeEntryCreateManyInput | GratitudeEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GratitudeEntry createManyAndReturn
   */
  export type GratitudeEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * The data used to create many GratitudeEntries.
     */
    data: GratitudeEntryCreateManyInput | GratitudeEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GratitudeEntry update
   */
  export type GratitudeEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a GratitudeEntry.
     */
    data: XOR<GratitudeEntryUpdateInput, GratitudeEntryUncheckedUpdateInput>
    /**
     * Choose, which GratitudeEntry to update.
     */
    where: GratitudeEntryWhereUniqueInput
  }

  /**
   * GratitudeEntry updateMany
   */
  export type GratitudeEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GratitudeEntries.
     */
    data: XOR<GratitudeEntryUpdateManyMutationInput, GratitudeEntryUncheckedUpdateManyInput>
    /**
     * Filter which GratitudeEntries to update
     */
    where?: GratitudeEntryWhereInput
    /**
     * Limit how many GratitudeEntries to update.
     */
    limit?: number
  }

  /**
   * GratitudeEntry updateManyAndReturn
   */
  export type GratitudeEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * The data used to update GratitudeEntries.
     */
    data: XOR<GratitudeEntryUpdateManyMutationInput, GratitudeEntryUncheckedUpdateManyInput>
    /**
     * Filter which GratitudeEntries to update
     */
    where?: GratitudeEntryWhereInput
    /**
     * Limit how many GratitudeEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GratitudeEntry upsert
   */
  export type GratitudeEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the GratitudeEntry to update in case it exists.
     */
    where: GratitudeEntryWhereUniqueInput
    /**
     * In case the GratitudeEntry found by the `where` argument doesn't exist, create a new GratitudeEntry with this data.
     */
    create: XOR<GratitudeEntryCreateInput, GratitudeEntryUncheckedCreateInput>
    /**
     * In case the GratitudeEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GratitudeEntryUpdateInput, GratitudeEntryUncheckedUpdateInput>
  }

  /**
   * GratitudeEntry delete
   */
  export type GratitudeEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
    /**
     * Filter which GratitudeEntry to delete.
     */
    where: GratitudeEntryWhereUniqueInput
  }

  /**
   * GratitudeEntry deleteMany
   */
  export type GratitudeEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GratitudeEntries to delete
     */
    where?: GratitudeEntryWhereInput
    /**
     * Limit how many GratitudeEntries to delete.
     */
    limit?: number
  }

  /**
   * GratitudeEntry.category
   */
  export type GratitudeEntry$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * GratitudeEntry.transaction
   */
  export type GratitudeEntry$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * GratitudeEntry without action
   */
  export type GratitudeEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GratitudeEntry
     */
    select?: GratitudeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GratitudeEntry
     */
    omit?: GratitudeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GratitudeEntryInclude<ExtArgs> | null
  }


  /**
   * Model ExchangeRate
   */

  export type AggregateExchangeRate = {
    _count: ExchangeRateCountAggregateOutputType | null
    _avg: ExchangeRateAvgAggregateOutputType | null
    _sum: ExchangeRateSumAggregateOutputType | null
    _min: ExchangeRateMinAggregateOutputType | null
    _max: ExchangeRateMaxAggregateOutputType | null
  }

  export type ExchangeRateAvgAggregateOutputType = {
    rate: Decimal | null
  }

  export type ExchangeRateSumAggregateOutputType = {
    rate: Decimal | null
  }

  export type ExchangeRateMinAggregateOutputType = {
    id: string | null
    fromCurrency: string | null
    toCurrency: string | null
    rate: Decimal | null
    date: Date | null
    source: string | null
    createdAt: Date | null
  }

  export type ExchangeRateMaxAggregateOutputType = {
    id: string | null
    fromCurrency: string | null
    toCurrency: string | null
    rate: Decimal | null
    date: Date | null
    source: string | null
    createdAt: Date | null
  }

  export type ExchangeRateCountAggregateOutputType = {
    id: number
    fromCurrency: number
    toCurrency: number
    rate: number
    date: number
    source: number
    createdAt: number
    _all: number
  }


  export type ExchangeRateAvgAggregateInputType = {
    rate?: true
  }

  export type ExchangeRateSumAggregateInputType = {
    rate?: true
  }

  export type ExchangeRateMinAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    date?: true
    source?: true
    createdAt?: true
  }

  export type ExchangeRateMaxAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    date?: true
    source?: true
    createdAt?: true
  }

  export type ExchangeRateCountAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    date?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type ExchangeRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeRate to aggregate.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExchangeRates
    **/
    _count?: true | ExchangeRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangeRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangeRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangeRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangeRateMaxAggregateInputType
  }

  export type GetExchangeRateAggregateType<T extends ExchangeRateAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangeRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangeRate[P]>
      : GetScalarType<T[P], AggregateExchangeRate[P]>
  }




  export type ExchangeRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeRateWhereInput
    orderBy?: ExchangeRateOrderByWithAggregationInput | ExchangeRateOrderByWithAggregationInput[]
    by: ExchangeRateScalarFieldEnum[] | ExchangeRateScalarFieldEnum
    having?: ExchangeRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangeRateCountAggregateInputType | true
    _avg?: ExchangeRateAvgAggregateInputType
    _sum?: ExchangeRateSumAggregateInputType
    _min?: ExchangeRateMinAggregateInputType
    _max?: ExchangeRateMaxAggregateInputType
  }

  export type ExchangeRateGroupByOutputType = {
    id: string
    fromCurrency: string
    toCurrency: string
    rate: Decimal
    date: Date
    source: string | null
    createdAt: Date
    _count: ExchangeRateCountAggregateOutputType | null
    _avg: ExchangeRateAvgAggregateOutputType | null
    _sum: ExchangeRateSumAggregateOutputType | null
    _min: ExchangeRateMinAggregateOutputType | null
    _max: ExchangeRateMaxAggregateOutputType | null
  }

  type GetExchangeRateGroupByPayload<T extends ExchangeRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangeRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangeRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangeRateGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangeRateGroupByOutputType[P]>
        }
      >
    >


  export type ExchangeRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    date?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exchangeRate"]>

  export type ExchangeRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    date?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exchangeRate"]>

  export type ExchangeRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    date?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exchangeRate"]>

  export type ExchangeRateSelectScalar = {
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    date?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type ExchangeRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromCurrency" | "toCurrency" | "rate" | "date" | "source" | "createdAt", ExtArgs["result"]["exchangeRate"]>

  export type $ExchangeRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExchangeRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromCurrency: string
      toCurrency: string
      rate: Prisma.Decimal
      date: Date
      source: string | null
      createdAt: Date
    }, ExtArgs["result"]["exchangeRate"]>
    composites: {}
  }

  type ExchangeRateGetPayload<S extends boolean | null | undefined | ExchangeRateDefaultArgs> = $Result.GetResult<Prisma.$ExchangeRatePayload, S>

  type ExchangeRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExchangeRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExchangeRateCountAggregateInputType | true
    }

  export interface ExchangeRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExchangeRate'], meta: { name: 'ExchangeRate' } }
    /**
     * Find zero or one ExchangeRate that matches the filter.
     * @param {ExchangeRateFindUniqueArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExchangeRateFindUniqueArgs>(args: SelectSubset<T, ExchangeRateFindUniqueArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExchangeRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExchangeRateFindUniqueOrThrowArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExchangeRateFindUniqueOrThrowArgs>(args: SelectSubset<T, ExchangeRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangeRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindFirstArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExchangeRateFindFirstArgs>(args?: SelectSubset<T, ExchangeRateFindFirstArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangeRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindFirstOrThrowArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExchangeRateFindFirstOrThrowArgs>(args?: SelectSubset<T, ExchangeRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExchangeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExchangeRates
     * const exchangeRates = await prisma.exchangeRate.findMany()
     * 
     * // Get first 10 ExchangeRates
     * const exchangeRates = await prisma.exchangeRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangeRateWithIdOnly = await prisma.exchangeRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExchangeRateFindManyArgs>(args?: SelectSubset<T, ExchangeRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExchangeRate.
     * @param {ExchangeRateCreateArgs} args - Arguments to create a ExchangeRate.
     * @example
     * // Create one ExchangeRate
     * const ExchangeRate = await prisma.exchangeRate.create({
     *   data: {
     *     // ... data to create a ExchangeRate
     *   }
     * })
     * 
     */
    create<T extends ExchangeRateCreateArgs>(args: SelectSubset<T, ExchangeRateCreateArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExchangeRates.
     * @param {ExchangeRateCreateManyArgs} args - Arguments to create many ExchangeRates.
     * @example
     * // Create many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExchangeRateCreateManyArgs>(args?: SelectSubset<T, ExchangeRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExchangeRates and returns the data saved in the database.
     * @param {ExchangeRateCreateManyAndReturnArgs} args - Arguments to create many ExchangeRates.
     * @example
     * // Create many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExchangeRates and only return the `id`
     * const exchangeRateWithIdOnly = await prisma.exchangeRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExchangeRateCreateManyAndReturnArgs>(args?: SelectSubset<T, ExchangeRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExchangeRate.
     * @param {ExchangeRateDeleteArgs} args - Arguments to delete one ExchangeRate.
     * @example
     * // Delete one ExchangeRate
     * const ExchangeRate = await prisma.exchangeRate.delete({
     *   where: {
     *     // ... filter to delete one ExchangeRate
     *   }
     * })
     * 
     */
    delete<T extends ExchangeRateDeleteArgs>(args: SelectSubset<T, ExchangeRateDeleteArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExchangeRate.
     * @param {ExchangeRateUpdateArgs} args - Arguments to update one ExchangeRate.
     * @example
     * // Update one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExchangeRateUpdateArgs>(args: SelectSubset<T, ExchangeRateUpdateArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExchangeRates.
     * @param {ExchangeRateDeleteManyArgs} args - Arguments to filter ExchangeRates to delete.
     * @example
     * // Delete a few ExchangeRates
     * const { count } = await prisma.exchangeRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExchangeRateDeleteManyArgs>(args?: SelectSubset<T, ExchangeRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExchangeRateUpdateManyArgs>(args: SelectSubset<T, ExchangeRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeRates and returns the data updated in the database.
     * @param {ExchangeRateUpdateManyAndReturnArgs} args - Arguments to update many ExchangeRates.
     * @example
     * // Update many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExchangeRates and only return the `id`
     * const exchangeRateWithIdOnly = await prisma.exchangeRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExchangeRateUpdateManyAndReturnArgs>(args: SelectSubset<T, ExchangeRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExchangeRate.
     * @param {ExchangeRateUpsertArgs} args - Arguments to update or create a ExchangeRate.
     * @example
     * // Update or create a ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.upsert({
     *   create: {
     *     // ... data to create a ExchangeRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExchangeRate we want to update
     *   }
     * })
     */
    upsert<T extends ExchangeRateUpsertArgs>(args: SelectSubset<T, ExchangeRateUpsertArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateCountArgs} args - Arguments to filter ExchangeRates to count.
     * @example
     * // Count the number of ExchangeRates
     * const count = await prisma.exchangeRate.count({
     *   where: {
     *     // ... the filter for the ExchangeRates we want to count
     *   }
     * })
    **/
    count<T extends ExchangeRateCountArgs>(
      args?: Subset<T, ExchangeRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangeRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangeRateAggregateArgs>(args: Subset<T, ExchangeRateAggregateArgs>): Prisma.PrismaPromise<GetExchangeRateAggregateType<T>>

    /**
     * Group by ExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangeRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangeRateGroupByArgs['orderBy'] }
        : { orderBy?: ExchangeRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangeRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangeRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExchangeRate model
   */
  readonly fields: ExchangeRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExchangeRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExchangeRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExchangeRate model
   */
  interface ExchangeRateFieldRefs {
    readonly id: FieldRef<"ExchangeRate", 'String'>
    readonly fromCurrency: FieldRef<"ExchangeRate", 'String'>
    readonly toCurrency: FieldRef<"ExchangeRate", 'String'>
    readonly rate: FieldRef<"ExchangeRate", 'Decimal'>
    readonly date: FieldRef<"ExchangeRate", 'DateTime'>
    readonly source: FieldRef<"ExchangeRate", 'String'>
    readonly createdAt: FieldRef<"ExchangeRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExchangeRate findUnique
   */
  export type ExchangeRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate findUniqueOrThrow
   */
  export type ExchangeRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate findFirst
   */
  export type ExchangeRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeRates.
     */
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate findFirstOrThrow
   */
  export type ExchangeRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeRates.
     */
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate findMany
   */
  export type ExchangeRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Filter, which ExchangeRates to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate create
   */
  export type ExchangeRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * The data needed to create a ExchangeRate.
     */
    data: XOR<ExchangeRateCreateInput, ExchangeRateUncheckedCreateInput>
  }

  /**
   * ExchangeRate createMany
   */
  export type ExchangeRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExchangeRates.
     */
    data: ExchangeRateCreateManyInput | ExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExchangeRate createManyAndReturn
   */
  export type ExchangeRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * The data used to create many ExchangeRates.
     */
    data: ExchangeRateCreateManyInput | ExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExchangeRate update
   */
  export type ExchangeRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * The data needed to update a ExchangeRate.
     */
    data: XOR<ExchangeRateUpdateInput, ExchangeRateUncheckedUpdateInput>
    /**
     * Choose, which ExchangeRate to update.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate updateMany
   */
  export type ExchangeRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExchangeRates.
     */
    data: XOR<ExchangeRateUpdateManyMutationInput, ExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeRates to update
     */
    where?: ExchangeRateWhereInput
    /**
     * Limit how many ExchangeRates to update.
     */
    limit?: number
  }

  /**
   * ExchangeRate updateManyAndReturn
   */
  export type ExchangeRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * The data used to update ExchangeRates.
     */
    data: XOR<ExchangeRateUpdateManyMutationInput, ExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeRates to update
     */
    where?: ExchangeRateWhereInput
    /**
     * Limit how many ExchangeRates to update.
     */
    limit?: number
  }

  /**
   * ExchangeRate upsert
   */
  export type ExchangeRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * The filter to search for the ExchangeRate to update in case it exists.
     */
    where: ExchangeRateWhereUniqueInput
    /**
     * In case the ExchangeRate found by the `where` argument doesn't exist, create a new ExchangeRate with this data.
     */
    create: XOR<ExchangeRateCreateInput, ExchangeRateUncheckedCreateInput>
    /**
     * In case the ExchangeRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExchangeRateUpdateInput, ExchangeRateUncheckedUpdateInput>
  }

  /**
   * ExchangeRate delete
   */
  export type ExchangeRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Filter which ExchangeRate to delete.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate deleteMany
   */
  export type ExchangeRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeRates to delete
     */
    where?: ExchangeRateWhereInput
    /**
     * Limit how many ExchangeRates to delete.
     */
    limit?: number
  }

  /**
   * ExchangeRate without action
   */
  export type ExchangeRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
  }


  /**
   * Model Passkey
   */

  export type AggregatePasskey = {
    _count: PasskeyCountAggregateOutputType | null
    _avg: PasskeyAvgAggregateOutputType | null
    _sum: PasskeySumAggregateOutputType | null
    _min: PasskeyMinAggregateOutputType | null
    _max: PasskeyMaxAggregateOutputType | null
  }

  export type PasskeyAvgAggregateOutputType = {
    counter: number | null
  }

  export type PasskeySumAggregateOutputType = {
    counter: number | null
  }

  export type PasskeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    credentialId: string | null
    publicKey: string | null
    counter: number | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type PasskeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    credentialId: string | null
    publicKey: string | null
    counter: number | null
    createdAt: Date | null
    lastUsedAt: Date | null
  }

  export type PasskeyCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    credentialId: number
    publicKey: number
    counter: number
    transports: number
    createdAt: number
    lastUsedAt: number
    _all: number
  }


  export type PasskeyAvgAggregateInputType = {
    counter?: true
  }

  export type PasskeySumAggregateInputType = {
    counter?: true
  }

  export type PasskeyMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type PasskeyMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    createdAt?: true
    lastUsedAt?: true
  }

  export type PasskeyCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    transports?: true
    createdAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type PasskeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passkey to aggregate.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passkeys
    **/
    _count?: true | PasskeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasskeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasskeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasskeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasskeyMaxAggregateInputType
  }

  export type GetPasskeyAggregateType<T extends PasskeyAggregateArgs> = {
        [P in keyof T & keyof AggregatePasskey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasskey[P]>
      : GetScalarType<T[P], AggregatePasskey[P]>
  }




  export type PasskeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasskeyWhereInput
    orderBy?: PasskeyOrderByWithAggregationInput | PasskeyOrderByWithAggregationInput[]
    by: PasskeyScalarFieldEnum[] | PasskeyScalarFieldEnum
    having?: PasskeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasskeyCountAggregateInputType | true
    _avg?: PasskeyAvgAggregateInputType
    _sum?: PasskeySumAggregateInputType
    _min?: PasskeyMinAggregateInputType
    _max?: PasskeyMaxAggregateInputType
  }

  export type PasskeyGroupByOutputType = {
    id: string
    userId: string
    name: string
    credentialId: string
    publicKey: string
    counter: number
    transports: string[]
    createdAt: Date
    lastUsedAt: Date | null
    _count: PasskeyCountAggregateOutputType | null
    _avg: PasskeyAvgAggregateOutputType | null
    _sum: PasskeySumAggregateOutputType | null
    _min: PasskeyMinAggregateOutputType | null
    _max: PasskeyMaxAggregateOutputType | null
  }

  type GetPasskeyGroupByPayload<T extends PasskeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasskeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasskeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasskeyGroupByOutputType[P]>
            : GetScalarType<T[P], PasskeyGroupByOutputType[P]>
        }
      >
    >


  export type PasskeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passkey"]>

  export type PasskeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passkey"]>

  export type PasskeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passkey"]>

  export type PasskeySelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    createdAt?: boolean
    lastUsedAt?: boolean
  }

  export type PasskeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "credentialId" | "publicKey" | "counter" | "transports" | "createdAt" | "lastUsedAt", ExtArgs["result"]["passkey"]>
  export type PasskeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasskeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasskeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasskeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Passkey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      credentialId: string
      publicKey: string
      counter: number
      transports: string[]
      createdAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["passkey"]>
    composites: {}
  }

  type PasskeyGetPayload<S extends boolean | null | undefined | PasskeyDefaultArgs> = $Result.GetResult<Prisma.$PasskeyPayload, S>

  type PasskeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasskeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasskeyCountAggregateInputType | true
    }

  export interface PasskeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passkey'], meta: { name: 'Passkey' } }
    /**
     * Find zero or one Passkey that matches the filter.
     * @param {PasskeyFindUniqueArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasskeyFindUniqueArgs>(args: SelectSubset<T, PasskeyFindUniqueArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passkey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasskeyFindUniqueOrThrowArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasskeyFindUniqueOrThrowArgs>(args: SelectSubset<T, PasskeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passkey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindFirstArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasskeyFindFirstArgs>(args?: SelectSubset<T, PasskeyFindFirstArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passkey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindFirstOrThrowArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasskeyFindFirstOrThrowArgs>(args?: SelectSubset<T, PasskeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passkeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passkeys
     * const passkeys = await prisma.passkey.findMany()
     * 
     * // Get first 10 Passkeys
     * const passkeys = await prisma.passkey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passkeyWithIdOnly = await prisma.passkey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasskeyFindManyArgs>(args?: SelectSubset<T, PasskeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passkey.
     * @param {PasskeyCreateArgs} args - Arguments to create a Passkey.
     * @example
     * // Create one Passkey
     * const Passkey = await prisma.passkey.create({
     *   data: {
     *     // ... data to create a Passkey
     *   }
     * })
     * 
     */
    create<T extends PasskeyCreateArgs>(args: SelectSubset<T, PasskeyCreateArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passkeys.
     * @param {PasskeyCreateManyArgs} args - Arguments to create many Passkeys.
     * @example
     * // Create many Passkeys
     * const passkey = await prisma.passkey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasskeyCreateManyArgs>(args?: SelectSubset<T, PasskeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passkeys and returns the data saved in the database.
     * @param {PasskeyCreateManyAndReturnArgs} args - Arguments to create many Passkeys.
     * @example
     * // Create many Passkeys
     * const passkey = await prisma.passkey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passkeys and only return the `id`
     * const passkeyWithIdOnly = await prisma.passkey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasskeyCreateManyAndReturnArgs>(args?: SelectSubset<T, PasskeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Passkey.
     * @param {PasskeyDeleteArgs} args - Arguments to delete one Passkey.
     * @example
     * // Delete one Passkey
     * const Passkey = await prisma.passkey.delete({
     *   where: {
     *     // ... filter to delete one Passkey
     *   }
     * })
     * 
     */
    delete<T extends PasskeyDeleteArgs>(args: SelectSubset<T, PasskeyDeleteArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passkey.
     * @param {PasskeyUpdateArgs} args - Arguments to update one Passkey.
     * @example
     * // Update one Passkey
     * const passkey = await prisma.passkey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasskeyUpdateArgs>(args: SelectSubset<T, PasskeyUpdateArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passkeys.
     * @param {PasskeyDeleteManyArgs} args - Arguments to filter Passkeys to delete.
     * @example
     * // Delete a few Passkeys
     * const { count } = await prisma.passkey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasskeyDeleteManyArgs>(args?: SelectSubset<T, PasskeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passkeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passkeys
     * const passkey = await prisma.passkey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasskeyUpdateManyArgs>(args: SelectSubset<T, PasskeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passkeys and returns the data updated in the database.
     * @param {PasskeyUpdateManyAndReturnArgs} args - Arguments to update many Passkeys.
     * @example
     * // Update many Passkeys
     * const passkey = await prisma.passkey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passkeys and only return the `id`
     * const passkeyWithIdOnly = await prisma.passkey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasskeyUpdateManyAndReturnArgs>(args: SelectSubset<T, PasskeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Passkey.
     * @param {PasskeyUpsertArgs} args - Arguments to update or create a Passkey.
     * @example
     * // Update or create a Passkey
     * const passkey = await prisma.passkey.upsert({
     *   create: {
     *     // ... data to create a Passkey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passkey we want to update
     *   }
     * })
     */
    upsert<T extends PasskeyUpsertArgs>(args: SelectSubset<T, PasskeyUpsertArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passkeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyCountArgs} args - Arguments to filter Passkeys to count.
     * @example
     * // Count the number of Passkeys
     * const count = await prisma.passkey.count({
     *   where: {
     *     // ... the filter for the Passkeys we want to count
     *   }
     * })
    **/
    count<T extends PasskeyCountArgs>(
      args?: Subset<T, PasskeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasskeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passkey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasskeyAggregateArgs>(args: Subset<T, PasskeyAggregateArgs>): Prisma.PrismaPromise<GetPasskeyAggregateType<T>>

    /**
     * Group by Passkey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasskeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasskeyGroupByArgs['orderBy'] }
        : { orderBy?: PasskeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasskeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasskeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Passkey model
   */
  readonly fields: PasskeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Passkey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasskeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Passkey model
   */
  interface PasskeyFieldRefs {
    readonly id: FieldRef<"Passkey", 'String'>
    readonly userId: FieldRef<"Passkey", 'String'>
    readonly name: FieldRef<"Passkey", 'String'>
    readonly credentialId: FieldRef<"Passkey", 'String'>
    readonly publicKey: FieldRef<"Passkey", 'String'>
    readonly counter: FieldRef<"Passkey", 'Int'>
    readonly transports: FieldRef<"Passkey", 'String[]'>
    readonly createdAt: FieldRef<"Passkey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"Passkey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Passkey findUnique
   */
  export type PasskeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey findUniqueOrThrow
   */
  export type PasskeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey findFirst
   */
  export type PasskeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passkeys.
     */
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey findFirstOrThrow
   */
  export type PasskeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passkeys.
     */
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey findMany
   */
  export type PasskeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkeys to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey create
   */
  export type PasskeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The data needed to create a Passkey.
     */
    data: XOR<PasskeyCreateInput, PasskeyUncheckedCreateInput>
  }

  /**
   * Passkey createMany
   */
  export type PasskeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passkeys.
     */
    data: PasskeyCreateManyInput | PasskeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passkey createManyAndReturn
   */
  export type PasskeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * The data used to create many Passkeys.
     */
    data: PasskeyCreateManyInput | PasskeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passkey update
   */
  export type PasskeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The data needed to update a Passkey.
     */
    data: XOR<PasskeyUpdateInput, PasskeyUncheckedUpdateInput>
    /**
     * Choose, which Passkey to update.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey updateMany
   */
  export type PasskeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passkeys.
     */
    data: XOR<PasskeyUpdateManyMutationInput, PasskeyUncheckedUpdateManyInput>
    /**
     * Filter which Passkeys to update
     */
    where?: PasskeyWhereInput
    /**
     * Limit how many Passkeys to update.
     */
    limit?: number
  }

  /**
   * Passkey updateManyAndReturn
   */
  export type PasskeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * The data used to update Passkeys.
     */
    data: XOR<PasskeyUpdateManyMutationInput, PasskeyUncheckedUpdateManyInput>
    /**
     * Filter which Passkeys to update
     */
    where?: PasskeyWhereInput
    /**
     * Limit how many Passkeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passkey upsert
   */
  export type PasskeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The filter to search for the Passkey to update in case it exists.
     */
    where: PasskeyWhereUniqueInput
    /**
     * In case the Passkey found by the `where` argument doesn't exist, create a new Passkey with this data.
     */
    create: XOR<PasskeyCreateInput, PasskeyUncheckedCreateInput>
    /**
     * In case the Passkey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasskeyUpdateInput, PasskeyUncheckedUpdateInput>
  }

  /**
   * Passkey delete
   */
  export type PasskeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter which Passkey to delete.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey deleteMany
   */
  export type PasskeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passkeys to delete
     */
    where?: PasskeyWhereInput
    /**
     * Limit how many Passkeys to delete.
     */
    limit?: number
  }

  /**
   * Passkey without action
   */
  export type PasskeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    userAgent: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "userAgent" | "ipAddress" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model UserEvent
   */

  export type AggregateUserEvent = {
    _count: UserEventCountAggregateOutputType | null
    _min: UserEventMinAggregateOutputType | null
    _max: UserEventMaxAggregateOutputType | null
  }

  export type UserEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    eventType: string | null
    resourceType: string | null
    resourceId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type UserEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    eventType: string | null
    resourceType: string | null
    resourceId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type UserEventCountAggregateOutputType = {
    id: number
    userId: number
    householdId: number
    eventType: number
    eventData: number
    resourceType: number
    resourceId: number
    sessionId: number
    ipAddress: number
    userAgent: number
    timestamp: number
    _all: number
  }


  export type UserEventMinAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    eventType?: true
    resourceType?: true
    resourceId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type UserEventMaxAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    eventType?: true
    resourceType?: true
    resourceId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type UserEventCountAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    eventType?: true
    eventData?: true
    resourceType?: true
    resourceId?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
    _all?: true
  }

  export type UserEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEvent to aggregate.
     */
    where?: UserEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEvents to fetch.
     */
    orderBy?: UserEventOrderByWithRelationInput | UserEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEvents
    **/
    _count?: true | UserEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEventMaxAggregateInputType
  }

  export type GetUserEventAggregateType<T extends UserEventAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEvent[P]>
      : GetScalarType<T[P], AggregateUserEvent[P]>
  }




  export type UserEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEventWhereInput
    orderBy?: UserEventOrderByWithAggregationInput | UserEventOrderByWithAggregationInput[]
    by: UserEventScalarFieldEnum[] | UserEventScalarFieldEnum
    having?: UserEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEventCountAggregateInputType | true
    _min?: UserEventMinAggregateInputType
    _max?: UserEventMaxAggregateInputType
  }

  export type UserEventGroupByOutputType = {
    id: string
    userId: string
    householdId: string
    eventType: string
    eventData: JsonValue
    resourceType: string | null
    resourceId: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date
    _count: UserEventCountAggregateOutputType | null
    _min: UserEventMinAggregateOutputType | null
    _max: UserEventMaxAggregateOutputType | null
  }

  type GetUserEventGroupByPayload<T extends UserEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEventGroupByOutputType[P]>
            : GetScalarType<T[P], UserEventGroupByOutputType[P]>
        }
      >
    >


  export type UserEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    eventType?: boolean
    eventData?: boolean
    resourceType?: boolean
    resourceId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEvent"]>

  export type UserEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    eventType?: boolean
    eventData?: boolean
    resourceType?: boolean
    resourceId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEvent"]>

  export type UserEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    eventType?: boolean
    eventData?: boolean
    resourceType?: boolean
    resourceId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEvent"]>

  export type UserEventSelectScalar = {
    id?: boolean
    userId?: boolean
    householdId?: boolean
    eventType?: boolean
    eventData?: boolean
    resourceType?: boolean
    resourceId?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }

  export type UserEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "householdId" | "eventType" | "eventData" | "resourceType" | "resourceId" | "sessionId" | "ipAddress" | "userAgent" | "timestamp", ExtArgs["result"]["userEvent"]>
  export type UserEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type UserEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type UserEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $UserEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      household: Prisma.$HouseholdPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      householdId: string
      eventType: string
      eventData: Prisma.JsonValue
      resourceType: string | null
      resourceId: string | null
      sessionId: string | null
      ipAddress: string | null
      userAgent: string | null
      timestamp: Date
    }, ExtArgs["result"]["userEvent"]>
    composites: {}
  }

  type UserEventGetPayload<S extends boolean | null | undefined | UserEventDefaultArgs> = $Result.GetResult<Prisma.$UserEventPayload, S>

  type UserEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserEventCountAggregateInputType | true
    }

  export interface UserEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserEvent'], meta: { name: 'UserEvent' } }
    /**
     * Find zero or one UserEvent that matches the filter.
     * @param {UserEventFindUniqueArgs} args - Arguments to find a UserEvent
     * @example
     * // Get one UserEvent
     * const userEvent = await prisma.userEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserEventFindUniqueArgs>(args: SelectSubset<T, UserEventFindUniqueArgs<ExtArgs>>): Prisma__UserEventClient<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserEventFindUniqueOrThrowArgs} args - Arguments to find a UserEvent
     * @example
     * // Get one UserEvent
     * const userEvent = await prisma.userEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserEventFindUniqueOrThrowArgs>(args: SelectSubset<T, UserEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserEventClient<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEventFindFirstArgs} args - Arguments to find a UserEvent
     * @example
     * // Get one UserEvent
     * const userEvent = await prisma.userEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserEventFindFirstArgs>(args?: SelectSubset<T, UserEventFindFirstArgs<ExtArgs>>): Prisma__UserEventClient<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEventFindFirstOrThrowArgs} args - Arguments to find a UserEvent
     * @example
     * // Get one UserEvent
     * const userEvent = await prisma.userEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserEventFindFirstOrThrowArgs>(args?: SelectSubset<T, UserEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserEventClient<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEvents
     * const userEvents = await prisma.userEvent.findMany()
     * 
     * // Get first 10 UserEvents
     * const userEvents = await prisma.userEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userEventWithIdOnly = await prisma.userEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserEventFindManyArgs>(args?: SelectSubset<T, UserEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserEvent.
     * @param {UserEventCreateArgs} args - Arguments to create a UserEvent.
     * @example
     * // Create one UserEvent
     * const UserEvent = await prisma.userEvent.create({
     *   data: {
     *     // ... data to create a UserEvent
     *   }
     * })
     * 
     */
    create<T extends UserEventCreateArgs>(args: SelectSubset<T, UserEventCreateArgs<ExtArgs>>): Prisma__UserEventClient<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserEvents.
     * @param {UserEventCreateManyArgs} args - Arguments to create many UserEvents.
     * @example
     * // Create many UserEvents
     * const userEvent = await prisma.userEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserEventCreateManyArgs>(args?: SelectSubset<T, UserEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserEvents and returns the data saved in the database.
     * @param {UserEventCreateManyAndReturnArgs} args - Arguments to create many UserEvents.
     * @example
     * // Create many UserEvents
     * const userEvent = await prisma.userEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserEvents and only return the `id`
     * const userEventWithIdOnly = await prisma.userEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserEventCreateManyAndReturnArgs>(args?: SelectSubset<T, UserEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserEvent.
     * @param {UserEventDeleteArgs} args - Arguments to delete one UserEvent.
     * @example
     * // Delete one UserEvent
     * const UserEvent = await prisma.userEvent.delete({
     *   where: {
     *     // ... filter to delete one UserEvent
     *   }
     * })
     * 
     */
    delete<T extends UserEventDeleteArgs>(args: SelectSubset<T, UserEventDeleteArgs<ExtArgs>>): Prisma__UserEventClient<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserEvent.
     * @param {UserEventUpdateArgs} args - Arguments to update one UserEvent.
     * @example
     * // Update one UserEvent
     * const userEvent = await prisma.userEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserEventUpdateArgs>(args: SelectSubset<T, UserEventUpdateArgs<ExtArgs>>): Prisma__UserEventClient<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserEvents.
     * @param {UserEventDeleteManyArgs} args - Arguments to filter UserEvents to delete.
     * @example
     * // Delete a few UserEvents
     * const { count } = await prisma.userEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserEventDeleteManyArgs>(args?: SelectSubset<T, UserEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEvents
     * const userEvent = await prisma.userEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserEventUpdateManyArgs>(args: SelectSubset<T, UserEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEvents and returns the data updated in the database.
     * @param {UserEventUpdateManyAndReturnArgs} args - Arguments to update many UserEvents.
     * @example
     * // Update many UserEvents
     * const userEvent = await prisma.userEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserEvents and only return the `id`
     * const userEventWithIdOnly = await prisma.userEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserEventUpdateManyAndReturnArgs>(args: SelectSubset<T, UserEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserEvent.
     * @param {UserEventUpsertArgs} args - Arguments to update or create a UserEvent.
     * @example
     * // Update or create a UserEvent
     * const userEvent = await prisma.userEvent.upsert({
     *   create: {
     *     // ... data to create a UserEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEvent we want to update
     *   }
     * })
     */
    upsert<T extends UserEventUpsertArgs>(args: SelectSubset<T, UserEventUpsertArgs<ExtArgs>>): Prisma__UserEventClient<$Result.GetResult<Prisma.$UserEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEventCountArgs} args - Arguments to filter UserEvents to count.
     * @example
     * // Count the number of UserEvents
     * const count = await prisma.userEvent.count({
     *   where: {
     *     // ... the filter for the UserEvents we want to count
     *   }
     * })
    **/
    count<T extends UserEventCountArgs>(
      args?: Subset<T, UserEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEventAggregateArgs>(args: Subset<T, UserEventAggregateArgs>): Prisma.PrismaPromise<GetUserEventAggregateType<T>>

    /**
     * Group by UserEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEventGroupByArgs['orderBy'] }
        : { orderBy?: UserEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserEvent model
   */
  readonly fields: UserEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserEvent model
   */
  interface UserEventFieldRefs {
    readonly id: FieldRef<"UserEvent", 'String'>
    readonly userId: FieldRef<"UserEvent", 'String'>
    readonly householdId: FieldRef<"UserEvent", 'String'>
    readonly eventType: FieldRef<"UserEvent", 'String'>
    readonly eventData: FieldRef<"UserEvent", 'Json'>
    readonly resourceType: FieldRef<"UserEvent", 'String'>
    readonly resourceId: FieldRef<"UserEvent", 'String'>
    readonly sessionId: FieldRef<"UserEvent", 'String'>
    readonly ipAddress: FieldRef<"UserEvent", 'String'>
    readonly userAgent: FieldRef<"UserEvent", 'String'>
    readonly timestamp: FieldRef<"UserEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserEvent findUnique
   */
  export type UserEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * Filter, which UserEvent to fetch.
     */
    where: UserEventWhereUniqueInput
  }

  /**
   * UserEvent findUniqueOrThrow
   */
  export type UserEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * Filter, which UserEvent to fetch.
     */
    where: UserEventWhereUniqueInput
  }

  /**
   * UserEvent findFirst
   */
  export type UserEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * Filter, which UserEvent to fetch.
     */
    where?: UserEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEvents to fetch.
     */
    orderBy?: UserEventOrderByWithRelationInput | UserEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEvents.
     */
    cursor?: UserEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEvents.
     */
    distinct?: UserEventScalarFieldEnum | UserEventScalarFieldEnum[]
  }

  /**
   * UserEvent findFirstOrThrow
   */
  export type UserEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * Filter, which UserEvent to fetch.
     */
    where?: UserEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEvents to fetch.
     */
    orderBy?: UserEventOrderByWithRelationInput | UserEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEvents.
     */
    cursor?: UserEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEvents.
     */
    distinct?: UserEventScalarFieldEnum | UserEventScalarFieldEnum[]
  }

  /**
   * UserEvent findMany
   */
  export type UserEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * Filter, which UserEvents to fetch.
     */
    where?: UserEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEvents to fetch.
     */
    orderBy?: UserEventOrderByWithRelationInput | UserEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEvents.
     */
    cursor?: UserEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEvents.
     */
    skip?: number
    distinct?: UserEventScalarFieldEnum | UserEventScalarFieldEnum[]
  }

  /**
   * UserEvent create
   */
  export type UserEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * The data needed to create a UserEvent.
     */
    data: XOR<UserEventCreateInput, UserEventUncheckedCreateInput>
  }

  /**
   * UserEvent createMany
   */
  export type UserEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserEvents.
     */
    data: UserEventCreateManyInput | UserEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserEvent createManyAndReturn
   */
  export type UserEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * The data used to create many UserEvents.
     */
    data: UserEventCreateManyInput | UserEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEvent update
   */
  export type UserEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * The data needed to update a UserEvent.
     */
    data: XOR<UserEventUpdateInput, UserEventUncheckedUpdateInput>
    /**
     * Choose, which UserEvent to update.
     */
    where: UserEventWhereUniqueInput
  }

  /**
   * UserEvent updateMany
   */
  export type UserEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserEvents.
     */
    data: XOR<UserEventUpdateManyMutationInput, UserEventUncheckedUpdateManyInput>
    /**
     * Filter which UserEvents to update
     */
    where?: UserEventWhereInput
    /**
     * Limit how many UserEvents to update.
     */
    limit?: number
  }

  /**
   * UserEvent updateManyAndReturn
   */
  export type UserEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * The data used to update UserEvents.
     */
    data: XOR<UserEventUpdateManyMutationInput, UserEventUncheckedUpdateManyInput>
    /**
     * Filter which UserEvents to update
     */
    where?: UserEventWhereInput
    /**
     * Limit how many UserEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEvent upsert
   */
  export type UserEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * The filter to search for the UserEvent to update in case it exists.
     */
    where: UserEventWhereUniqueInput
    /**
     * In case the UserEvent found by the `where` argument doesn't exist, create a new UserEvent with this data.
     */
    create: XOR<UserEventCreateInput, UserEventUncheckedCreateInput>
    /**
     * In case the UserEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEventUpdateInput, UserEventUncheckedUpdateInput>
  }

  /**
   * UserEvent delete
   */
  export type UserEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
    /**
     * Filter which UserEvent to delete.
     */
    where: UserEventWhereUniqueInput
  }

  /**
   * UserEvent deleteMany
   */
  export type UserEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEvents to delete
     */
    where?: UserEventWhereInput
    /**
     * Limit how many UserEvents to delete.
     */
    limit?: number
  }

  /**
   * UserEvent without action
   */
  export type UserEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEvent
     */
    select?: UserEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEvent
     */
    omit?: UserEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEventInclude<ExtArgs> | null
  }


  /**
   * Model SpendingPattern
   */

  export type AggregateSpendingPattern = {
    _count: SpendingPatternCountAggregateOutputType | null
    _avg: SpendingPatternAvgAggregateOutputType | null
    _sum: SpendingPatternSumAggregateOutputType | null
    _min: SpendingPatternMinAggregateOutputType | null
    _max: SpendingPatternMaxAggregateOutputType | null
  }

  export type SpendingPatternAvgAggregateOutputType = {
    dayOfWeek: number | null
    hourOfDay: number | null
    month: number | null
    averageAmountCents: number | null
    frequency: number | null
    confidenceScore: Decimal | null
  }

  export type SpendingPatternSumAggregateOutputType = {
    dayOfWeek: number | null
    hourOfDay: number | null
    month: number | null
    averageAmountCents: bigint | null
    frequency: number | null
    confidenceScore: Decimal | null
  }

  export type SpendingPatternMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    userId: string | null
    patternType: string | null
    categoryId: string | null
    merchant: string | null
    dayOfWeek: number | null
    hourOfDay: number | null
    month: number | null
    averageAmountCents: bigint | null
    frequency: number | null
    confidenceScore: Decimal | null
    lastUpdated: Date | null
  }

  export type SpendingPatternMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    userId: string | null
    patternType: string | null
    categoryId: string | null
    merchant: string | null
    dayOfWeek: number | null
    hourOfDay: number | null
    month: number | null
    averageAmountCents: bigint | null
    frequency: number | null
    confidenceScore: Decimal | null
    lastUpdated: Date | null
  }

  export type SpendingPatternCountAggregateOutputType = {
    id: number
    householdId: number
    userId: number
    patternType: number
    categoryId: number
    merchant: number
    dayOfWeek: number
    hourOfDay: number
    month: number
    averageAmountCents: number
    frequency: number
    confidenceScore: number
    lastUpdated: number
    _all: number
  }


  export type SpendingPatternAvgAggregateInputType = {
    dayOfWeek?: true
    hourOfDay?: true
    month?: true
    averageAmountCents?: true
    frequency?: true
    confidenceScore?: true
  }

  export type SpendingPatternSumAggregateInputType = {
    dayOfWeek?: true
    hourOfDay?: true
    month?: true
    averageAmountCents?: true
    frequency?: true
    confidenceScore?: true
  }

  export type SpendingPatternMinAggregateInputType = {
    id?: true
    householdId?: true
    userId?: true
    patternType?: true
    categoryId?: true
    merchant?: true
    dayOfWeek?: true
    hourOfDay?: true
    month?: true
    averageAmountCents?: true
    frequency?: true
    confidenceScore?: true
    lastUpdated?: true
  }

  export type SpendingPatternMaxAggregateInputType = {
    id?: true
    householdId?: true
    userId?: true
    patternType?: true
    categoryId?: true
    merchant?: true
    dayOfWeek?: true
    hourOfDay?: true
    month?: true
    averageAmountCents?: true
    frequency?: true
    confidenceScore?: true
    lastUpdated?: true
  }

  export type SpendingPatternCountAggregateInputType = {
    id?: true
    householdId?: true
    userId?: true
    patternType?: true
    categoryId?: true
    merchant?: true
    dayOfWeek?: true
    hourOfDay?: true
    month?: true
    averageAmountCents?: true
    frequency?: true
    confidenceScore?: true
    lastUpdated?: true
    _all?: true
  }

  export type SpendingPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpendingPattern to aggregate.
     */
    where?: SpendingPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingPatterns to fetch.
     */
    orderBy?: SpendingPatternOrderByWithRelationInput | SpendingPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpendingPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpendingPatterns
    **/
    _count?: true | SpendingPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpendingPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpendingPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpendingPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpendingPatternMaxAggregateInputType
  }

  export type GetSpendingPatternAggregateType<T extends SpendingPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateSpendingPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpendingPattern[P]>
      : GetScalarType<T[P], AggregateSpendingPattern[P]>
  }




  export type SpendingPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingPatternWhereInput
    orderBy?: SpendingPatternOrderByWithAggregationInput | SpendingPatternOrderByWithAggregationInput[]
    by: SpendingPatternScalarFieldEnum[] | SpendingPatternScalarFieldEnum
    having?: SpendingPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpendingPatternCountAggregateInputType | true
    _avg?: SpendingPatternAvgAggregateInputType
    _sum?: SpendingPatternSumAggregateInputType
    _min?: SpendingPatternMinAggregateInputType
    _max?: SpendingPatternMaxAggregateInputType
  }

  export type SpendingPatternGroupByOutputType = {
    id: string
    householdId: string
    userId: string | null
    patternType: string
    categoryId: string | null
    merchant: string | null
    dayOfWeek: number | null
    hourOfDay: number | null
    month: number | null
    averageAmountCents: bigint
    frequency: number
    confidenceScore: Decimal
    lastUpdated: Date
    _count: SpendingPatternCountAggregateOutputType | null
    _avg: SpendingPatternAvgAggregateOutputType | null
    _sum: SpendingPatternSumAggregateOutputType | null
    _min: SpendingPatternMinAggregateOutputType | null
    _max: SpendingPatternMaxAggregateOutputType | null
  }

  type GetSpendingPatternGroupByPayload<T extends SpendingPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpendingPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpendingPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpendingPatternGroupByOutputType[P]>
            : GetScalarType<T[P], SpendingPatternGroupByOutputType[P]>
        }
      >
    >


  export type SpendingPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    userId?: boolean
    patternType?: boolean
    categoryId?: boolean
    merchant?: boolean
    dayOfWeek?: boolean
    hourOfDay?: boolean
    month?: boolean
    averageAmountCents?: boolean
    frequency?: boolean
    confidenceScore?: boolean
    lastUpdated?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spendingPattern"]>

  export type SpendingPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    userId?: boolean
    patternType?: boolean
    categoryId?: boolean
    merchant?: boolean
    dayOfWeek?: boolean
    hourOfDay?: boolean
    month?: boolean
    averageAmountCents?: boolean
    frequency?: boolean
    confidenceScore?: boolean
    lastUpdated?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spendingPattern"]>

  export type SpendingPatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    userId?: boolean
    patternType?: boolean
    categoryId?: boolean
    merchant?: boolean
    dayOfWeek?: boolean
    hourOfDay?: boolean
    month?: boolean
    averageAmountCents?: boolean
    frequency?: boolean
    confidenceScore?: boolean
    lastUpdated?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spendingPattern"]>

  export type SpendingPatternSelectScalar = {
    id?: boolean
    householdId?: boolean
    userId?: boolean
    patternType?: boolean
    categoryId?: boolean
    merchant?: boolean
    dayOfWeek?: boolean
    hourOfDay?: boolean
    month?: boolean
    averageAmountCents?: boolean
    frequency?: boolean
    confidenceScore?: boolean
    lastUpdated?: boolean
  }

  export type SpendingPatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "userId" | "patternType" | "categoryId" | "merchant" | "dayOfWeek" | "hourOfDay" | "month" | "averageAmountCents" | "frequency" | "confidenceScore" | "lastUpdated", ExtArgs["result"]["spendingPattern"]>
  export type SpendingPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type SpendingPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type SpendingPatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $SpendingPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpendingPattern"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      userId: string | null
      patternType: string
      categoryId: string | null
      merchant: string | null
      dayOfWeek: number | null
      hourOfDay: number | null
      month: number | null
      averageAmountCents: bigint
      frequency: number
      confidenceScore: Prisma.Decimal
      lastUpdated: Date
    }, ExtArgs["result"]["spendingPattern"]>
    composites: {}
  }

  type SpendingPatternGetPayload<S extends boolean | null | undefined | SpendingPatternDefaultArgs> = $Result.GetResult<Prisma.$SpendingPatternPayload, S>

  type SpendingPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpendingPatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpendingPatternCountAggregateInputType | true
    }

  export interface SpendingPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpendingPattern'], meta: { name: 'SpendingPattern' } }
    /**
     * Find zero or one SpendingPattern that matches the filter.
     * @param {SpendingPatternFindUniqueArgs} args - Arguments to find a SpendingPattern
     * @example
     * // Get one SpendingPattern
     * const spendingPattern = await prisma.spendingPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpendingPatternFindUniqueArgs>(args: SelectSubset<T, SpendingPatternFindUniqueArgs<ExtArgs>>): Prisma__SpendingPatternClient<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpendingPattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpendingPatternFindUniqueOrThrowArgs} args - Arguments to find a SpendingPattern
     * @example
     * // Get one SpendingPattern
     * const spendingPattern = await prisma.spendingPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpendingPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, SpendingPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpendingPatternClient<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpendingPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingPatternFindFirstArgs} args - Arguments to find a SpendingPattern
     * @example
     * // Get one SpendingPattern
     * const spendingPattern = await prisma.spendingPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpendingPatternFindFirstArgs>(args?: SelectSubset<T, SpendingPatternFindFirstArgs<ExtArgs>>): Prisma__SpendingPatternClient<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpendingPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingPatternFindFirstOrThrowArgs} args - Arguments to find a SpendingPattern
     * @example
     * // Get one SpendingPattern
     * const spendingPattern = await prisma.spendingPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpendingPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, SpendingPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpendingPatternClient<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpendingPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpendingPatterns
     * const spendingPatterns = await prisma.spendingPattern.findMany()
     * 
     * // Get first 10 SpendingPatterns
     * const spendingPatterns = await prisma.spendingPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spendingPatternWithIdOnly = await prisma.spendingPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpendingPatternFindManyArgs>(args?: SelectSubset<T, SpendingPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpendingPattern.
     * @param {SpendingPatternCreateArgs} args - Arguments to create a SpendingPattern.
     * @example
     * // Create one SpendingPattern
     * const SpendingPattern = await prisma.spendingPattern.create({
     *   data: {
     *     // ... data to create a SpendingPattern
     *   }
     * })
     * 
     */
    create<T extends SpendingPatternCreateArgs>(args: SelectSubset<T, SpendingPatternCreateArgs<ExtArgs>>): Prisma__SpendingPatternClient<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpendingPatterns.
     * @param {SpendingPatternCreateManyArgs} args - Arguments to create many SpendingPatterns.
     * @example
     * // Create many SpendingPatterns
     * const spendingPattern = await prisma.spendingPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpendingPatternCreateManyArgs>(args?: SelectSubset<T, SpendingPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpendingPatterns and returns the data saved in the database.
     * @param {SpendingPatternCreateManyAndReturnArgs} args - Arguments to create many SpendingPatterns.
     * @example
     * // Create many SpendingPatterns
     * const spendingPattern = await prisma.spendingPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpendingPatterns and only return the `id`
     * const spendingPatternWithIdOnly = await prisma.spendingPattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpendingPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, SpendingPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpendingPattern.
     * @param {SpendingPatternDeleteArgs} args - Arguments to delete one SpendingPattern.
     * @example
     * // Delete one SpendingPattern
     * const SpendingPattern = await prisma.spendingPattern.delete({
     *   where: {
     *     // ... filter to delete one SpendingPattern
     *   }
     * })
     * 
     */
    delete<T extends SpendingPatternDeleteArgs>(args: SelectSubset<T, SpendingPatternDeleteArgs<ExtArgs>>): Prisma__SpendingPatternClient<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpendingPattern.
     * @param {SpendingPatternUpdateArgs} args - Arguments to update one SpendingPattern.
     * @example
     * // Update one SpendingPattern
     * const spendingPattern = await prisma.spendingPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpendingPatternUpdateArgs>(args: SelectSubset<T, SpendingPatternUpdateArgs<ExtArgs>>): Prisma__SpendingPatternClient<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpendingPatterns.
     * @param {SpendingPatternDeleteManyArgs} args - Arguments to filter SpendingPatterns to delete.
     * @example
     * // Delete a few SpendingPatterns
     * const { count } = await prisma.spendingPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpendingPatternDeleteManyArgs>(args?: SelectSubset<T, SpendingPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpendingPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpendingPatterns
     * const spendingPattern = await prisma.spendingPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpendingPatternUpdateManyArgs>(args: SelectSubset<T, SpendingPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpendingPatterns and returns the data updated in the database.
     * @param {SpendingPatternUpdateManyAndReturnArgs} args - Arguments to update many SpendingPatterns.
     * @example
     * // Update many SpendingPatterns
     * const spendingPattern = await prisma.spendingPattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpendingPatterns and only return the `id`
     * const spendingPatternWithIdOnly = await prisma.spendingPattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpendingPatternUpdateManyAndReturnArgs>(args: SelectSubset<T, SpendingPatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpendingPattern.
     * @param {SpendingPatternUpsertArgs} args - Arguments to update or create a SpendingPattern.
     * @example
     * // Update or create a SpendingPattern
     * const spendingPattern = await prisma.spendingPattern.upsert({
     *   create: {
     *     // ... data to create a SpendingPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpendingPattern we want to update
     *   }
     * })
     */
    upsert<T extends SpendingPatternUpsertArgs>(args: SelectSubset<T, SpendingPatternUpsertArgs<ExtArgs>>): Prisma__SpendingPatternClient<$Result.GetResult<Prisma.$SpendingPatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpendingPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingPatternCountArgs} args - Arguments to filter SpendingPatterns to count.
     * @example
     * // Count the number of SpendingPatterns
     * const count = await prisma.spendingPattern.count({
     *   where: {
     *     // ... the filter for the SpendingPatterns we want to count
     *   }
     * })
    **/
    count<T extends SpendingPatternCountArgs>(
      args?: Subset<T, SpendingPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpendingPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpendingPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpendingPatternAggregateArgs>(args: Subset<T, SpendingPatternAggregateArgs>): Prisma.PrismaPromise<GetSpendingPatternAggregateType<T>>

    /**
     * Group by SpendingPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpendingPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpendingPatternGroupByArgs['orderBy'] }
        : { orderBy?: SpendingPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpendingPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpendingPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpendingPattern model
   */
  readonly fields: SpendingPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpendingPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpendingPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpendingPattern model
   */
  interface SpendingPatternFieldRefs {
    readonly id: FieldRef<"SpendingPattern", 'String'>
    readonly householdId: FieldRef<"SpendingPattern", 'String'>
    readonly userId: FieldRef<"SpendingPattern", 'String'>
    readonly patternType: FieldRef<"SpendingPattern", 'String'>
    readonly categoryId: FieldRef<"SpendingPattern", 'String'>
    readonly merchant: FieldRef<"SpendingPattern", 'String'>
    readonly dayOfWeek: FieldRef<"SpendingPattern", 'Int'>
    readonly hourOfDay: FieldRef<"SpendingPattern", 'Int'>
    readonly month: FieldRef<"SpendingPattern", 'Int'>
    readonly averageAmountCents: FieldRef<"SpendingPattern", 'BigInt'>
    readonly frequency: FieldRef<"SpendingPattern", 'Int'>
    readonly confidenceScore: FieldRef<"SpendingPattern", 'Decimal'>
    readonly lastUpdated: FieldRef<"SpendingPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpendingPattern findUnique
   */
  export type SpendingPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * Filter, which SpendingPattern to fetch.
     */
    where: SpendingPatternWhereUniqueInput
  }

  /**
   * SpendingPattern findUniqueOrThrow
   */
  export type SpendingPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * Filter, which SpendingPattern to fetch.
     */
    where: SpendingPatternWhereUniqueInput
  }

  /**
   * SpendingPattern findFirst
   */
  export type SpendingPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * Filter, which SpendingPattern to fetch.
     */
    where?: SpendingPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingPatterns to fetch.
     */
    orderBy?: SpendingPatternOrderByWithRelationInput | SpendingPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpendingPatterns.
     */
    cursor?: SpendingPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpendingPatterns.
     */
    distinct?: SpendingPatternScalarFieldEnum | SpendingPatternScalarFieldEnum[]
  }

  /**
   * SpendingPattern findFirstOrThrow
   */
  export type SpendingPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * Filter, which SpendingPattern to fetch.
     */
    where?: SpendingPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingPatterns to fetch.
     */
    orderBy?: SpendingPatternOrderByWithRelationInput | SpendingPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpendingPatterns.
     */
    cursor?: SpendingPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpendingPatterns.
     */
    distinct?: SpendingPatternScalarFieldEnum | SpendingPatternScalarFieldEnum[]
  }

  /**
   * SpendingPattern findMany
   */
  export type SpendingPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * Filter, which SpendingPatterns to fetch.
     */
    where?: SpendingPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingPatterns to fetch.
     */
    orderBy?: SpendingPatternOrderByWithRelationInput | SpendingPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpendingPatterns.
     */
    cursor?: SpendingPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingPatterns.
     */
    skip?: number
    distinct?: SpendingPatternScalarFieldEnum | SpendingPatternScalarFieldEnum[]
  }

  /**
   * SpendingPattern create
   */
  export type SpendingPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a SpendingPattern.
     */
    data: XOR<SpendingPatternCreateInput, SpendingPatternUncheckedCreateInput>
  }

  /**
   * SpendingPattern createMany
   */
  export type SpendingPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpendingPatterns.
     */
    data: SpendingPatternCreateManyInput | SpendingPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpendingPattern createManyAndReturn
   */
  export type SpendingPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * The data used to create many SpendingPatterns.
     */
    data: SpendingPatternCreateManyInput | SpendingPatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpendingPattern update
   */
  export type SpendingPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a SpendingPattern.
     */
    data: XOR<SpendingPatternUpdateInput, SpendingPatternUncheckedUpdateInput>
    /**
     * Choose, which SpendingPattern to update.
     */
    where: SpendingPatternWhereUniqueInput
  }

  /**
   * SpendingPattern updateMany
   */
  export type SpendingPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpendingPatterns.
     */
    data: XOR<SpendingPatternUpdateManyMutationInput, SpendingPatternUncheckedUpdateManyInput>
    /**
     * Filter which SpendingPatterns to update
     */
    where?: SpendingPatternWhereInput
    /**
     * Limit how many SpendingPatterns to update.
     */
    limit?: number
  }

  /**
   * SpendingPattern updateManyAndReturn
   */
  export type SpendingPatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * The data used to update SpendingPatterns.
     */
    data: XOR<SpendingPatternUpdateManyMutationInput, SpendingPatternUncheckedUpdateManyInput>
    /**
     * Filter which SpendingPatterns to update
     */
    where?: SpendingPatternWhereInput
    /**
     * Limit how many SpendingPatterns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpendingPattern upsert
   */
  export type SpendingPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the SpendingPattern to update in case it exists.
     */
    where: SpendingPatternWhereUniqueInput
    /**
     * In case the SpendingPattern found by the `where` argument doesn't exist, create a new SpendingPattern with this data.
     */
    create: XOR<SpendingPatternCreateInput, SpendingPatternUncheckedCreateInput>
    /**
     * In case the SpendingPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpendingPatternUpdateInput, SpendingPatternUncheckedUpdateInput>
  }

  /**
   * SpendingPattern delete
   */
  export type SpendingPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
    /**
     * Filter which SpendingPattern to delete.
     */
    where: SpendingPatternWhereUniqueInput
  }

  /**
   * SpendingPattern deleteMany
   */
  export type SpendingPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpendingPatterns to delete
     */
    where?: SpendingPatternWhereInput
    /**
     * Limit how many SpendingPatterns to delete.
     */
    limit?: number
  }

  /**
   * SpendingPattern without action
   */
  export type SpendingPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingPattern
     */
    select?: SpendingPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpendingPattern
     */
    omit?: SpendingPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingPatternInclude<ExtArgs> | null
  }


  /**
   * Model FinancialInsight
   */

  export type AggregateFinancialInsight = {
    _count: FinancialInsightCountAggregateOutputType | null
    _min: FinancialInsightMinAggregateOutputType | null
    _max: FinancialInsightMaxAggregateOutputType | null
  }

  export type FinancialInsightMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    insightType: string | null
    title: string | null
    description: string | null
    priority: $Enums.InsightPriority | null
    isActionable: boolean | null
    isDismissed: boolean | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialInsightMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    insightType: string | null
    title: string | null
    description: string | null
    priority: $Enums.InsightPriority | null
    isActionable: boolean | null
    isDismissed: boolean | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialInsightCountAggregateOutputType = {
    id: number
    householdId: number
    insightType: number
    title: number
    description: number
    data: number
    priority: number
    isActionable: number
    isDismissed: number
    validUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinancialInsightMinAggregateInputType = {
    id?: true
    householdId?: true
    insightType?: true
    title?: true
    description?: true
    priority?: true
    isActionable?: true
    isDismissed?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialInsightMaxAggregateInputType = {
    id?: true
    householdId?: true
    insightType?: true
    title?: true
    description?: true
    priority?: true
    isActionable?: true
    isDismissed?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialInsightCountAggregateInputType = {
    id?: true
    householdId?: true
    insightType?: true
    title?: true
    description?: true
    data?: true
    priority?: true
    isActionable?: true
    isDismissed?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinancialInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialInsight to aggregate.
     */
    where?: FinancialInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialInsights to fetch.
     */
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialInsights
    **/
    _count?: true | FinancialInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialInsightMaxAggregateInputType
  }

  export type GetFinancialInsightAggregateType<T extends FinancialInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialInsight[P]>
      : GetScalarType<T[P], AggregateFinancialInsight[P]>
  }




  export type FinancialInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialInsightWhereInput
    orderBy?: FinancialInsightOrderByWithAggregationInput | FinancialInsightOrderByWithAggregationInput[]
    by: FinancialInsightScalarFieldEnum[] | FinancialInsightScalarFieldEnum
    having?: FinancialInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialInsightCountAggregateInputType | true
    _min?: FinancialInsightMinAggregateInputType
    _max?: FinancialInsightMaxAggregateInputType
  }

  export type FinancialInsightGroupByOutputType = {
    id: string
    householdId: string
    insightType: string
    title: string
    description: string
    data: JsonValue
    priority: $Enums.InsightPriority
    isActionable: boolean
    isDismissed: boolean
    validUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FinancialInsightCountAggregateOutputType | null
    _min: FinancialInsightMinAggregateOutputType | null
    _max: FinancialInsightMaxAggregateOutputType | null
  }

  type GetFinancialInsightGroupByPayload<T extends FinancialInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialInsightGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialInsightGroupByOutputType[P]>
        }
      >
    >


  export type FinancialInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    priority?: boolean
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialInsight"]>

  export type FinancialInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    priority?: boolean
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialInsight"]>

  export type FinancialInsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    priority?: boolean
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialInsight"]>

  export type FinancialInsightSelectScalar = {
    id?: boolean
    householdId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    priority?: boolean
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FinancialInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "insightType" | "title" | "description" | "data" | "priority" | "isActionable" | "isDismissed" | "validUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["financialInsight"]>
  export type FinancialInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type FinancialInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type FinancialInsightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $FinancialInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialInsight"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      insightType: string
      title: string
      description: string
      data: Prisma.JsonValue
      priority: $Enums.InsightPriority
      isActionable: boolean
      isDismissed: boolean
      validUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["financialInsight"]>
    composites: {}
  }

  type FinancialInsightGetPayload<S extends boolean | null | undefined | FinancialInsightDefaultArgs> = $Result.GetResult<Prisma.$FinancialInsightPayload, S>

  type FinancialInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialInsightCountAggregateInputType | true
    }

  export interface FinancialInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialInsight'], meta: { name: 'FinancialInsight' } }
    /**
     * Find zero or one FinancialInsight that matches the filter.
     * @param {FinancialInsightFindUniqueArgs} args - Arguments to find a FinancialInsight
     * @example
     * // Get one FinancialInsight
     * const financialInsight = await prisma.financialInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialInsightFindUniqueArgs>(args: SelectSubset<T, FinancialInsightFindUniqueArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialInsightFindUniqueOrThrowArgs} args - Arguments to find a FinancialInsight
     * @example
     * // Get one FinancialInsight
     * const financialInsight = await prisma.financialInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightFindFirstArgs} args - Arguments to find a FinancialInsight
     * @example
     * // Get one FinancialInsight
     * const financialInsight = await prisma.financialInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialInsightFindFirstArgs>(args?: SelectSubset<T, FinancialInsightFindFirstArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightFindFirstOrThrowArgs} args - Arguments to find a FinancialInsight
     * @example
     * // Get one FinancialInsight
     * const financialInsight = await prisma.financialInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialInsights
     * const financialInsights = await prisma.financialInsight.findMany()
     * 
     * // Get first 10 FinancialInsights
     * const financialInsights = await prisma.financialInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialInsightWithIdOnly = await prisma.financialInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialInsightFindManyArgs>(args?: SelectSubset<T, FinancialInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialInsight.
     * @param {FinancialInsightCreateArgs} args - Arguments to create a FinancialInsight.
     * @example
     * // Create one FinancialInsight
     * const FinancialInsight = await prisma.financialInsight.create({
     *   data: {
     *     // ... data to create a FinancialInsight
     *   }
     * })
     * 
     */
    create<T extends FinancialInsightCreateArgs>(args: SelectSubset<T, FinancialInsightCreateArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialInsights.
     * @param {FinancialInsightCreateManyArgs} args - Arguments to create many FinancialInsights.
     * @example
     * // Create many FinancialInsights
     * const financialInsight = await prisma.financialInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialInsightCreateManyArgs>(args?: SelectSubset<T, FinancialInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialInsights and returns the data saved in the database.
     * @param {FinancialInsightCreateManyAndReturnArgs} args - Arguments to create many FinancialInsights.
     * @example
     * // Create many FinancialInsights
     * const financialInsight = await prisma.financialInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialInsights and only return the `id`
     * const financialInsightWithIdOnly = await prisma.financialInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialInsight.
     * @param {FinancialInsightDeleteArgs} args - Arguments to delete one FinancialInsight.
     * @example
     * // Delete one FinancialInsight
     * const FinancialInsight = await prisma.financialInsight.delete({
     *   where: {
     *     // ... filter to delete one FinancialInsight
     *   }
     * })
     * 
     */
    delete<T extends FinancialInsightDeleteArgs>(args: SelectSubset<T, FinancialInsightDeleteArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialInsight.
     * @param {FinancialInsightUpdateArgs} args - Arguments to update one FinancialInsight.
     * @example
     * // Update one FinancialInsight
     * const financialInsight = await prisma.financialInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialInsightUpdateArgs>(args: SelectSubset<T, FinancialInsightUpdateArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialInsights.
     * @param {FinancialInsightDeleteManyArgs} args - Arguments to filter FinancialInsights to delete.
     * @example
     * // Delete a few FinancialInsights
     * const { count } = await prisma.financialInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialInsightDeleteManyArgs>(args?: SelectSubset<T, FinancialInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialInsights
     * const financialInsight = await prisma.financialInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialInsightUpdateManyArgs>(args: SelectSubset<T, FinancialInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialInsights and returns the data updated in the database.
     * @param {FinancialInsightUpdateManyAndReturnArgs} args - Arguments to update many FinancialInsights.
     * @example
     * // Update many FinancialInsights
     * const financialInsight = await prisma.financialInsight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialInsights and only return the `id`
     * const financialInsightWithIdOnly = await prisma.financialInsight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialInsightUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialInsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialInsight.
     * @param {FinancialInsightUpsertArgs} args - Arguments to update or create a FinancialInsight.
     * @example
     * // Update or create a FinancialInsight
     * const financialInsight = await prisma.financialInsight.upsert({
     *   create: {
     *     // ... data to create a FinancialInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialInsight we want to update
     *   }
     * })
     */
    upsert<T extends FinancialInsightUpsertArgs>(args: SelectSubset<T, FinancialInsightUpsertArgs<ExtArgs>>): Prisma__FinancialInsightClient<$Result.GetResult<Prisma.$FinancialInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightCountArgs} args - Arguments to filter FinancialInsights to count.
     * @example
     * // Count the number of FinancialInsights
     * const count = await prisma.financialInsight.count({
     *   where: {
     *     // ... the filter for the FinancialInsights we want to count
     *   }
     * })
    **/
    count<T extends FinancialInsightCountArgs>(
      args?: Subset<T, FinancialInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialInsightAggregateArgs>(args: Subset<T, FinancialInsightAggregateArgs>): Prisma.PrismaPromise<GetFinancialInsightAggregateType<T>>

    /**
     * Group by FinancialInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialInsightGroupByArgs['orderBy'] }
        : { orderBy?: FinancialInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialInsight model
   */
  readonly fields: FinancialInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialInsight model
   */
  interface FinancialInsightFieldRefs {
    readonly id: FieldRef<"FinancialInsight", 'String'>
    readonly householdId: FieldRef<"FinancialInsight", 'String'>
    readonly insightType: FieldRef<"FinancialInsight", 'String'>
    readonly title: FieldRef<"FinancialInsight", 'String'>
    readonly description: FieldRef<"FinancialInsight", 'String'>
    readonly data: FieldRef<"FinancialInsight", 'Json'>
    readonly priority: FieldRef<"FinancialInsight", 'InsightPriority'>
    readonly isActionable: FieldRef<"FinancialInsight", 'Boolean'>
    readonly isDismissed: FieldRef<"FinancialInsight", 'Boolean'>
    readonly validUntil: FieldRef<"FinancialInsight", 'DateTime'>
    readonly createdAt: FieldRef<"FinancialInsight", 'DateTime'>
    readonly updatedAt: FieldRef<"FinancialInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancialInsight findUnique
   */
  export type FinancialInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsight to fetch.
     */
    where: FinancialInsightWhereUniqueInput
  }

  /**
   * FinancialInsight findUniqueOrThrow
   */
  export type FinancialInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsight to fetch.
     */
    where: FinancialInsightWhereUniqueInput
  }

  /**
   * FinancialInsight findFirst
   */
  export type FinancialInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsight to fetch.
     */
    where?: FinancialInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialInsights to fetch.
     */
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialInsights.
     */
    cursor?: FinancialInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialInsights.
     */
    distinct?: FinancialInsightScalarFieldEnum | FinancialInsightScalarFieldEnum[]
  }

  /**
   * FinancialInsight findFirstOrThrow
   */
  export type FinancialInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsight to fetch.
     */
    where?: FinancialInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialInsights to fetch.
     */
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialInsights.
     */
    cursor?: FinancialInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialInsights.
     */
    distinct?: FinancialInsightScalarFieldEnum | FinancialInsightScalarFieldEnum[]
  }

  /**
   * FinancialInsight findMany
   */
  export type FinancialInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter, which FinancialInsights to fetch.
     */
    where?: FinancialInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialInsights to fetch.
     */
    orderBy?: FinancialInsightOrderByWithRelationInput | FinancialInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialInsights.
     */
    cursor?: FinancialInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialInsights.
     */
    skip?: number
    distinct?: FinancialInsightScalarFieldEnum | FinancialInsightScalarFieldEnum[]
  }

  /**
   * FinancialInsight create
   */
  export type FinancialInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialInsight.
     */
    data: XOR<FinancialInsightCreateInput, FinancialInsightUncheckedCreateInput>
  }

  /**
   * FinancialInsight createMany
   */
  export type FinancialInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialInsights.
     */
    data: FinancialInsightCreateManyInput | FinancialInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialInsight createManyAndReturn
   */
  export type FinancialInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialInsights.
     */
    data: FinancialInsightCreateManyInput | FinancialInsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialInsight update
   */
  export type FinancialInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialInsight.
     */
    data: XOR<FinancialInsightUpdateInput, FinancialInsightUncheckedUpdateInput>
    /**
     * Choose, which FinancialInsight to update.
     */
    where: FinancialInsightWhereUniqueInput
  }

  /**
   * FinancialInsight updateMany
   */
  export type FinancialInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialInsights.
     */
    data: XOR<FinancialInsightUpdateManyMutationInput, FinancialInsightUncheckedUpdateManyInput>
    /**
     * Filter which FinancialInsights to update
     */
    where?: FinancialInsightWhereInput
    /**
     * Limit how many FinancialInsights to update.
     */
    limit?: number
  }

  /**
   * FinancialInsight updateManyAndReturn
   */
  export type FinancialInsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * The data used to update FinancialInsights.
     */
    data: XOR<FinancialInsightUpdateManyMutationInput, FinancialInsightUncheckedUpdateManyInput>
    /**
     * Filter which FinancialInsights to update
     */
    where?: FinancialInsightWhereInput
    /**
     * Limit how many FinancialInsights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialInsight upsert
   */
  export type FinancialInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialInsight to update in case it exists.
     */
    where: FinancialInsightWhereUniqueInput
    /**
     * In case the FinancialInsight found by the `where` argument doesn't exist, create a new FinancialInsight with this data.
     */
    create: XOR<FinancialInsightCreateInput, FinancialInsightUncheckedCreateInput>
    /**
     * In case the FinancialInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialInsightUpdateInput, FinancialInsightUncheckedUpdateInput>
  }

  /**
   * FinancialInsight delete
   */
  export type FinancialInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
    /**
     * Filter which FinancialInsight to delete.
     */
    where: FinancialInsightWhereUniqueInput
  }

  /**
   * FinancialInsight deleteMany
   */
  export type FinancialInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialInsights to delete
     */
    where?: FinancialInsightWhereInput
    /**
     * Limit how many FinancialInsights to delete.
     */
    limit?: number
  }

  /**
   * FinancialInsight without action
   */
  export type FinancialInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialInsight
     */
    select?: FinancialInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialInsight
     */
    omit?: FinancialInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialInsightInclude<ExtArgs> | null
  }


  /**
   * Model RecurringTransaction
   */

  export type AggregateRecurringTransaction = {
    _count: RecurringTransactionCountAggregateOutputType | null
    _avg: RecurringTransactionAvgAggregateOutputType | null
    _sum: RecurringTransactionSumAggregateOutputType | null
    _min: RecurringTransactionMinAggregateOutputType | null
    _max: RecurringTransactionMaxAggregateOutputType | null
  }

  export type RecurringTransactionAvgAggregateOutputType = {
    amountCents: number | null
    intervalValue: number | null
    executionCount: number | null
    maxExecutions: number | null
  }

  export type RecurringTransactionSumAggregateOutputType = {
    amountCents: bigint | null
    intervalValue: number | null
    executionCount: number | null
    maxExecutions: number | null
  }

  export type RecurringTransactionMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    name: string | null
    description: string | null
    amountCents: bigint | null
    currency: string | null
    accountId: string | null
    transferAccountId: string | null
    categoryId: string | null
    merchant: string | null
    frequency: $Enums.RecurrenceFrequency | null
    intervalValue: number | null
    startDate: Date | null
    endDate: Date | null
    nextExecutionDate: Date | null
    lastExecutionDate: Date | null
    executionCount: number | null
    maxExecutions: number | null
    status: $Enums.RecurringTransactionStatus | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringTransactionMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    name: string | null
    description: string | null
    amountCents: bigint | null
    currency: string | null
    accountId: string | null
    transferAccountId: string | null
    categoryId: string | null
    merchant: string | null
    frequency: $Enums.RecurrenceFrequency | null
    intervalValue: number | null
    startDate: Date | null
    endDate: Date | null
    nextExecutionDate: Date | null
    lastExecutionDate: Date | null
    executionCount: number | null
    maxExecutions: number | null
    status: $Enums.RecurringTransactionStatus | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringTransactionCountAggregateOutputType = {
    id: number
    householdId: number
    name: number
    description: number
    amountCents: number
    currency: number
    accountId: number
    transferAccountId: number
    categoryId: number
    merchant: number
    frequency: number
    intervalValue: number
    startDate: number
    endDate: number
    nextExecutionDate: number
    lastExecutionDate: number
    executionCount: number
    maxExecutions: number
    status: number
    metadata: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringTransactionAvgAggregateInputType = {
    amountCents?: true
    intervalValue?: true
    executionCount?: true
    maxExecutions?: true
  }

  export type RecurringTransactionSumAggregateInputType = {
    amountCents?: true
    intervalValue?: true
    executionCount?: true
    maxExecutions?: true
  }

  export type RecurringTransactionMinAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    description?: true
    amountCents?: true
    currency?: true
    accountId?: true
    transferAccountId?: true
    categoryId?: true
    merchant?: true
    frequency?: true
    intervalValue?: true
    startDate?: true
    endDate?: true
    nextExecutionDate?: true
    lastExecutionDate?: true
    executionCount?: true
    maxExecutions?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringTransactionMaxAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    description?: true
    amountCents?: true
    currency?: true
    accountId?: true
    transferAccountId?: true
    categoryId?: true
    merchant?: true
    frequency?: true
    intervalValue?: true
    startDate?: true
    endDate?: true
    nextExecutionDate?: true
    lastExecutionDate?: true
    executionCount?: true
    maxExecutions?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringTransactionCountAggregateInputType = {
    id?: true
    householdId?: true
    name?: true
    description?: true
    amountCents?: true
    currency?: true
    accountId?: true
    transferAccountId?: true
    categoryId?: true
    merchant?: true
    frequency?: true
    intervalValue?: true
    startDate?: true
    endDate?: true
    nextExecutionDate?: true
    lastExecutionDate?: true
    executionCount?: true
    maxExecutions?: true
    status?: true
    metadata?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringTransaction to aggregate.
     */
    where?: RecurringTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTransactions to fetch.
     */
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringTransactions
    **/
    _count?: true | RecurringTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringTransactionMaxAggregateInputType
  }

  export type GetRecurringTransactionAggregateType<T extends RecurringTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringTransaction[P]>
      : GetScalarType<T[P], AggregateRecurringTransaction[P]>
  }




  export type RecurringTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionWhereInput
    orderBy?: RecurringTransactionOrderByWithAggregationInput | RecurringTransactionOrderByWithAggregationInput[]
    by: RecurringTransactionScalarFieldEnum[] | RecurringTransactionScalarFieldEnum
    having?: RecurringTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringTransactionCountAggregateInputType | true
    _avg?: RecurringTransactionAvgAggregateInputType
    _sum?: RecurringTransactionSumAggregateInputType
    _min?: RecurringTransactionMinAggregateInputType
    _max?: RecurringTransactionMaxAggregateInputType
  }

  export type RecurringTransactionGroupByOutputType = {
    id: string
    householdId: string
    name: string
    description: string
    amountCents: bigint
    currency: string
    accountId: string
    transferAccountId: string | null
    categoryId: string | null
    merchant: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue: number
    startDate: Date
    endDate: Date | null
    nextExecutionDate: Date
    lastExecutionDate: Date | null
    executionCount: number
    maxExecutions: number | null
    status: $Enums.RecurringTransactionStatus
    metadata: JsonValue
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: RecurringTransactionCountAggregateOutputType | null
    _avg: RecurringTransactionAvgAggregateOutputType | null
    _sum: RecurringTransactionSumAggregateOutputType | null
    _min: RecurringTransactionMinAggregateOutputType | null
    _max: RecurringTransactionMaxAggregateOutputType | null
  }

  type GetRecurringTransactionGroupByPayload<T extends RecurringTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringTransactionGroupByOutputType[P]>
        }
      >
    >


  export type RecurringTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    description?: boolean
    amountCents?: boolean
    currency?: boolean
    accountId?: boolean
    transferAccountId?: boolean
    categoryId?: boolean
    merchant?: boolean
    frequency?: boolean
    intervalValue?: boolean
    startDate?: boolean
    endDate?: boolean
    nextExecutionDate?: boolean
    lastExecutionDate?: boolean
    executionCount?: boolean
    maxExecutions?: boolean
    status?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | RecurringTransaction$transferAccountArgs<ExtArgs>
    category?: boolean | RecurringTransaction$categoryArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | RecurringTransaction$executionsArgs<ExtArgs>
    _count?: boolean | RecurringTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTransaction"]>

  export type RecurringTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    description?: boolean
    amountCents?: boolean
    currency?: boolean
    accountId?: boolean
    transferAccountId?: boolean
    categoryId?: boolean
    merchant?: boolean
    frequency?: boolean
    intervalValue?: boolean
    startDate?: boolean
    endDate?: boolean
    nextExecutionDate?: boolean
    lastExecutionDate?: boolean
    executionCount?: boolean
    maxExecutions?: boolean
    status?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | RecurringTransaction$transferAccountArgs<ExtArgs>
    category?: boolean | RecurringTransaction$categoryArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTransaction"]>

  export type RecurringTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    name?: boolean
    description?: boolean
    amountCents?: boolean
    currency?: boolean
    accountId?: boolean
    transferAccountId?: boolean
    categoryId?: boolean
    merchant?: boolean
    frequency?: boolean
    intervalValue?: boolean
    startDate?: boolean
    endDate?: boolean
    nextExecutionDate?: boolean
    lastExecutionDate?: boolean
    executionCount?: boolean
    maxExecutions?: boolean
    status?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | RecurringTransaction$transferAccountArgs<ExtArgs>
    category?: boolean | RecurringTransaction$categoryArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTransaction"]>

  export type RecurringTransactionSelectScalar = {
    id?: boolean
    householdId?: boolean
    name?: boolean
    description?: boolean
    amountCents?: boolean
    currency?: boolean
    accountId?: boolean
    transferAccountId?: boolean
    categoryId?: boolean
    merchant?: boolean
    frequency?: boolean
    intervalValue?: boolean
    startDate?: boolean
    endDate?: boolean
    nextExecutionDate?: boolean
    lastExecutionDate?: boolean
    executionCount?: boolean
    maxExecutions?: boolean
    status?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "name" | "description" | "amountCents" | "currency" | "accountId" | "transferAccountId" | "categoryId" | "merchant" | "frequency" | "intervalValue" | "startDate" | "endDate" | "nextExecutionDate" | "lastExecutionDate" | "executionCount" | "maxExecutions" | "status" | "metadata" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["recurringTransaction"]>
  export type RecurringTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | RecurringTransaction$transferAccountArgs<ExtArgs>
    category?: boolean | RecurringTransaction$categoryArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | RecurringTransaction$executionsArgs<ExtArgs>
    _count?: boolean | RecurringTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecurringTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | RecurringTransaction$transferAccountArgs<ExtArgs>
    category?: boolean | RecurringTransaction$categoryArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RecurringTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    transferAccount?: boolean | RecurringTransaction$transferAccountArgs<ExtArgs>
    category?: boolean | RecurringTransaction$categoryArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RecurringTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringTransaction"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      transferAccount: Prisma.$AccountPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$RecurringTransactionExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      name: string
      description: string
      amountCents: bigint
      currency: string
      accountId: string
      transferAccountId: string | null
      categoryId: string | null
      merchant: string | null
      frequency: $Enums.RecurrenceFrequency
      intervalValue: number
      startDate: Date
      endDate: Date | null
      nextExecutionDate: Date
      lastExecutionDate: Date | null
      executionCount: number
      maxExecutions: number | null
      status: $Enums.RecurringTransactionStatus
      metadata: Prisma.JsonValue
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringTransaction"]>
    composites: {}
  }

  type RecurringTransactionGetPayload<S extends boolean | null | undefined | RecurringTransactionDefaultArgs> = $Result.GetResult<Prisma.$RecurringTransactionPayload, S>

  type RecurringTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringTransactionCountAggregateInputType | true
    }

  export interface RecurringTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringTransaction'], meta: { name: 'RecurringTransaction' } }
    /**
     * Find zero or one RecurringTransaction that matches the filter.
     * @param {RecurringTransactionFindUniqueArgs} args - Arguments to find a RecurringTransaction
     * @example
     * // Get one RecurringTransaction
     * const recurringTransaction = await prisma.recurringTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringTransactionFindUniqueArgs>(args: SelectSubset<T, RecurringTransactionFindUniqueArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringTransactionFindUniqueOrThrowArgs} args - Arguments to find a RecurringTransaction
     * @example
     * // Get one RecurringTransaction
     * const recurringTransaction = await prisma.recurringTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionFindFirstArgs} args - Arguments to find a RecurringTransaction
     * @example
     * // Get one RecurringTransaction
     * const recurringTransaction = await prisma.recurringTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringTransactionFindFirstArgs>(args?: SelectSubset<T, RecurringTransactionFindFirstArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionFindFirstOrThrowArgs} args - Arguments to find a RecurringTransaction
     * @example
     * // Get one RecurringTransaction
     * const recurringTransaction = await prisma.recurringTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringTransactions
     * const recurringTransactions = await prisma.recurringTransaction.findMany()
     * 
     * // Get first 10 RecurringTransactions
     * const recurringTransactions = await prisma.recurringTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringTransactionWithIdOnly = await prisma.recurringTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringTransactionFindManyArgs>(args?: SelectSubset<T, RecurringTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringTransaction.
     * @param {RecurringTransactionCreateArgs} args - Arguments to create a RecurringTransaction.
     * @example
     * // Create one RecurringTransaction
     * const RecurringTransaction = await prisma.recurringTransaction.create({
     *   data: {
     *     // ... data to create a RecurringTransaction
     *   }
     * })
     * 
     */
    create<T extends RecurringTransactionCreateArgs>(args: SelectSubset<T, RecurringTransactionCreateArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringTransactions.
     * @param {RecurringTransactionCreateManyArgs} args - Arguments to create many RecurringTransactions.
     * @example
     * // Create many RecurringTransactions
     * const recurringTransaction = await prisma.recurringTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringTransactionCreateManyArgs>(args?: SelectSubset<T, RecurringTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringTransactions and returns the data saved in the database.
     * @param {RecurringTransactionCreateManyAndReturnArgs} args - Arguments to create many RecurringTransactions.
     * @example
     * // Create many RecurringTransactions
     * const recurringTransaction = await prisma.recurringTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringTransactions and only return the `id`
     * const recurringTransactionWithIdOnly = await prisma.recurringTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringTransaction.
     * @param {RecurringTransactionDeleteArgs} args - Arguments to delete one RecurringTransaction.
     * @example
     * // Delete one RecurringTransaction
     * const RecurringTransaction = await prisma.recurringTransaction.delete({
     *   where: {
     *     // ... filter to delete one RecurringTransaction
     *   }
     * })
     * 
     */
    delete<T extends RecurringTransactionDeleteArgs>(args: SelectSubset<T, RecurringTransactionDeleteArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringTransaction.
     * @param {RecurringTransactionUpdateArgs} args - Arguments to update one RecurringTransaction.
     * @example
     * // Update one RecurringTransaction
     * const recurringTransaction = await prisma.recurringTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringTransactionUpdateArgs>(args: SelectSubset<T, RecurringTransactionUpdateArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringTransactions.
     * @param {RecurringTransactionDeleteManyArgs} args - Arguments to filter RecurringTransactions to delete.
     * @example
     * // Delete a few RecurringTransactions
     * const { count } = await prisma.recurringTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringTransactionDeleteManyArgs>(args?: SelectSubset<T, RecurringTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringTransactions
     * const recurringTransaction = await prisma.recurringTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringTransactionUpdateManyArgs>(args: SelectSubset<T, RecurringTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringTransactions and returns the data updated in the database.
     * @param {RecurringTransactionUpdateManyAndReturnArgs} args - Arguments to update many RecurringTransactions.
     * @example
     * // Update many RecurringTransactions
     * const recurringTransaction = await prisma.recurringTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringTransactions and only return the `id`
     * const recurringTransactionWithIdOnly = await prisma.recurringTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringTransaction.
     * @param {RecurringTransactionUpsertArgs} args - Arguments to update or create a RecurringTransaction.
     * @example
     * // Update or create a RecurringTransaction
     * const recurringTransaction = await prisma.recurringTransaction.upsert({
     *   create: {
     *     // ... data to create a RecurringTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringTransaction we want to update
     *   }
     * })
     */
    upsert<T extends RecurringTransactionUpsertArgs>(args: SelectSubset<T, RecurringTransactionUpsertArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionCountArgs} args - Arguments to filter RecurringTransactions to count.
     * @example
     * // Count the number of RecurringTransactions
     * const count = await prisma.recurringTransaction.count({
     *   where: {
     *     // ... the filter for the RecurringTransactions we want to count
     *   }
     * })
    **/
    count<T extends RecurringTransactionCountArgs>(
      args?: Subset<T, RecurringTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringTransactionAggregateArgs>(args: Subset<T, RecurringTransactionAggregateArgs>): Prisma.PrismaPromise<GetRecurringTransactionAggregateType<T>>

    /**
     * Group by RecurringTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringTransactionGroupByArgs['orderBy'] }
        : { orderBy?: RecurringTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringTransaction model
   */
  readonly fields: RecurringTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transferAccount<T extends RecurringTransaction$transferAccountArgs<ExtArgs> = {}>(args?: Subset<T, RecurringTransaction$transferAccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends RecurringTransaction$categoryArgs<ExtArgs> = {}>(args?: Subset<T, RecurringTransaction$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executions<T extends RecurringTransaction$executionsArgs<ExtArgs> = {}>(args?: Subset<T, RecurringTransaction$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringTransaction model
   */
  interface RecurringTransactionFieldRefs {
    readonly id: FieldRef<"RecurringTransaction", 'String'>
    readonly householdId: FieldRef<"RecurringTransaction", 'String'>
    readonly name: FieldRef<"RecurringTransaction", 'String'>
    readonly description: FieldRef<"RecurringTransaction", 'String'>
    readonly amountCents: FieldRef<"RecurringTransaction", 'BigInt'>
    readonly currency: FieldRef<"RecurringTransaction", 'String'>
    readonly accountId: FieldRef<"RecurringTransaction", 'String'>
    readonly transferAccountId: FieldRef<"RecurringTransaction", 'String'>
    readonly categoryId: FieldRef<"RecurringTransaction", 'String'>
    readonly merchant: FieldRef<"RecurringTransaction", 'String'>
    readonly frequency: FieldRef<"RecurringTransaction", 'RecurrenceFrequency'>
    readonly intervalValue: FieldRef<"RecurringTransaction", 'Int'>
    readonly startDate: FieldRef<"RecurringTransaction", 'DateTime'>
    readonly endDate: FieldRef<"RecurringTransaction", 'DateTime'>
    readonly nextExecutionDate: FieldRef<"RecurringTransaction", 'DateTime'>
    readonly lastExecutionDate: FieldRef<"RecurringTransaction", 'DateTime'>
    readonly executionCount: FieldRef<"RecurringTransaction", 'Int'>
    readonly maxExecutions: FieldRef<"RecurringTransaction", 'Int'>
    readonly status: FieldRef<"RecurringTransaction", 'RecurringTransactionStatus'>
    readonly metadata: FieldRef<"RecurringTransaction", 'Json'>
    readonly createdBy: FieldRef<"RecurringTransaction", 'String'>
    readonly createdAt: FieldRef<"RecurringTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringTransaction findUnique
   */
  export type RecurringTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransaction to fetch.
     */
    where: RecurringTransactionWhereUniqueInput
  }

  /**
   * RecurringTransaction findUniqueOrThrow
   */
  export type RecurringTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransaction to fetch.
     */
    where: RecurringTransactionWhereUniqueInput
  }

  /**
   * RecurringTransaction findFirst
   */
  export type RecurringTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransaction to fetch.
     */
    where?: RecurringTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTransactions to fetch.
     */
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringTransactions.
     */
    cursor?: RecurringTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringTransactions.
     */
    distinct?: RecurringTransactionScalarFieldEnum | RecurringTransactionScalarFieldEnum[]
  }

  /**
   * RecurringTransaction findFirstOrThrow
   */
  export type RecurringTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransaction to fetch.
     */
    where?: RecurringTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTransactions to fetch.
     */
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringTransactions.
     */
    cursor?: RecurringTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringTransactions.
     */
    distinct?: RecurringTransactionScalarFieldEnum | RecurringTransactionScalarFieldEnum[]
  }

  /**
   * RecurringTransaction findMany
   */
  export type RecurringTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransactions to fetch.
     */
    where?: RecurringTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTransactions to fetch.
     */
    orderBy?: RecurringTransactionOrderByWithRelationInput | RecurringTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringTransactions.
     */
    cursor?: RecurringTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTransactions.
     */
    skip?: number
    distinct?: RecurringTransactionScalarFieldEnum | RecurringTransactionScalarFieldEnum[]
  }

  /**
   * RecurringTransaction create
   */
  export type RecurringTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringTransaction.
     */
    data: XOR<RecurringTransactionCreateInput, RecurringTransactionUncheckedCreateInput>
  }

  /**
   * RecurringTransaction createMany
   */
  export type RecurringTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringTransactions.
     */
    data: RecurringTransactionCreateManyInput | RecurringTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringTransaction createManyAndReturn
   */
  export type RecurringTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringTransactions.
     */
    data: RecurringTransactionCreateManyInput | RecurringTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringTransaction update
   */
  export type RecurringTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringTransaction.
     */
    data: XOR<RecurringTransactionUpdateInput, RecurringTransactionUncheckedUpdateInput>
    /**
     * Choose, which RecurringTransaction to update.
     */
    where: RecurringTransactionWhereUniqueInput
  }

  /**
   * RecurringTransaction updateMany
   */
  export type RecurringTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringTransactions.
     */
    data: XOR<RecurringTransactionUpdateManyMutationInput, RecurringTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RecurringTransactions to update
     */
    where?: RecurringTransactionWhereInput
    /**
     * Limit how many RecurringTransactions to update.
     */
    limit?: number
  }

  /**
   * RecurringTransaction updateManyAndReturn
   */
  export type RecurringTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * The data used to update RecurringTransactions.
     */
    data: XOR<RecurringTransactionUpdateManyMutationInput, RecurringTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RecurringTransactions to update
     */
    where?: RecurringTransactionWhereInput
    /**
     * Limit how many RecurringTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringTransaction upsert
   */
  export type RecurringTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringTransaction to update in case it exists.
     */
    where: RecurringTransactionWhereUniqueInput
    /**
     * In case the RecurringTransaction found by the `where` argument doesn't exist, create a new RecurringTransaction with this data.
     */
    create: XOR<RecurringTransactionCreateInput, RecurringTransactionUncheckedCreateInput>
    /**
     * In case the RecurringTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringTransactionUpdateInput, RecurringTransactionUncheckedUpdateInput>
  }

  /**
   * RecurringTransaction delete
   */
  export type RecurringTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
    /**
     * Filter which RecurringTransaction to delete.
     */
    where: RecurringTransactionWhereUniqueInput
  }

  /**
   * RecurringTransaction deleteMany
   */
  export type RecurringTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringTransactions to delete
     */
    where?: RecurringTransactionWhereInput
    /**
     * Limit how many RecurringTransactions to delete.
     */
    limit?: number
  }

  /**
   * RecurringTransaction.transferAccount
   */
  export type RecurringTransaction$transferAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * RecurringTransaction.category
   */
  export type RecurringTransaction$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * RecurringTransaction.executions
   */
  export type RecurringTransaction$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    where?: RecurringTransactionExecutionWhereInput
    orderBy?: RecurringTransactionExecutionOrderByWithRelationInput | RecurringTransactionExecutionOrderByWithRelationInput[]
    cursor?: RecurringTransactionExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringTransactionExecutionScalarFieldEnum | RecurringTransactionExecutionScalarFieldEnum[]
  }

  /**
   * RecurringTransaction without action
   */
  export type RecurringTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransaction
     */
    select?: RecurringTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransaction
     */
    omit?: RecurringTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionInclude<ExtArgs> | null
  }


  /**
   * Model RecurringTransactionExecution
   */

  export type AggregateRecurringTransactionExecution = {
    _count: RecurringTransactionExecutionCountAggregateOutputType | null
    _avg: RecurringTransactionExecutionAvgAggregateOutputType | null
    _sum: RecurringTransactionExecutionSumAggregateOutputType | null
    _min: RecurringTransactionExecutionMinAggregateOutputType | null
    _max: RecurringTransactionExecutionMaxAggregateOutputType | null
  }

  export type RecurringTransactionExecutionAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type RecurringTransactionExecutionSumAggregateOutputType = {
    retryCount: number | null
  }

  export type RecurringTransactionExecutionMinAggregateOutputType = {
    id: string | null
    recurringTransactionId: string | null
    transactionId: string | null
    scheduledDate: Date | null
    executedDate: Date | null
    status: string | null
    errorMessage: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringTransactionExecutionMaxAggregateOutputType = {
    id: string | null
    recurringTransactionId: string | null
    transactionId: string | null
    scheduledDate: Date | null
    executedDate: Date | null
    status: string | null
    errorMessage: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringTransactionExecutionCountAggregateOutputType = {
    id: number
    recurringTransactionId: number
    transactionId: number
    scheduledDate: number
    executedDate: number
    status: number
    errorMessage: number
    retryCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringTransactionExecutionAvgAggregateInputType = {
    retryCount?: true
  }

  export type RecurringTransactionExecutionSumAggregateInputType = {
    retryCount?: true
  }

  export type RecurringTransactionExecutionMinAggregateInputType = {
    id?: true
    recurringTransactionId?: true
    transactionId?: true
    scheduledDate?: true
    executedDate?: true
    status?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringTransactionExecutionMaxAggregateInputType = {
    id?: true
    recurringTransactionId?: true
    transactionId?: true
    scheduledDate?: true
    executedDate?: true
    status?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringTransactionExecutionCountAggregateInputType = {
    id?: true
    recurringTransactionId?: true
    transactionId?: true
    scheduledDate?: true
    executedDate?: true
    status?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringTransactionExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringTransactionExecution to aggregate.
     */
    where?: RecurringTransactionExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTransactionExecutions to fetch.
     */
    orderBy?: RecurringTransactionExecutionOrderByWithRelationInput | RecurringTransactionExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringTransactionExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTransactionExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTransactionExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringTransactionExecutions
    **/
    _count?: true | RecurringTransactionExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringTransactionExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringTransactionExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringTransactionExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringTransactionExecutionMaxAggregateInputType
  }

  export type GetRecurringTransactionExecutionAggregateType<T extends RecurringTransactionExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringTransactionExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringTransactionExecution[P]>
      : GetScalarType<T[P], AggregateRecurringTransactionExecution[P]>
  }




  export type RecurringTransactionExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringTransactionExecutionWhereInput
    orderBy?: RecurringTransactionExecutionOrderByWithAggregationInput | RecurringTransactionExecutionOrderByWithAggregationInput[]
    by: RecurringTransactionExecutionScalarFieldEnum[] | RecurringTransactionExecutionScalarFieldEnum
    having?: RecurringTransactionExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringTransactionExecutionCountAggregateInputType | true
    _avg?: RecurringTransactionExecutionAvgAggregateInputType
    _sum?: RecurringTransactionExecutionSumAggregateInputType
    _min?: RecurringTransactionExecutionMinAggregateInputType
    _max?: RecurringTransactionExecutionMaxAggregateInputType
  }

  export type RecurringTransactionExecutionGroupByOutputType = {
    id: string
    recurringTransactionId: string
    transactionId: string | null
    scheduledDate: Date
    executedDate: Date | null
    status: string
    errorMessage: string | null
    retryCount: number
    createdAt: Date
    updatedAt: Date
    _count: RecurringTransactionExecutionCountAggregateOutputType | null
    _avg: RecurringTransactionExecutionAvgAggregateOutputType | null
    _sum: RecurringTransactionExecutionSumAggregateOutputType | null
    _min: RecurringTransactionExecutionMinAggregateOutputType | null
    _max: RecurringTransactionExecutionMaxAggregateOutputType | null
  }

  type GetRecurringTransactionExecutionGroupByPayload<T extends RecurringTransactionExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringTransactionExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringTransactionExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringTransactionExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringTransactionExecutionGroupByOutputType[P]>
        }
      >
    >


  export type RecurringTransactionExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recurringTransactionId?: boolean
    transactionId?: boolean
    scheduledDate?: boolean
    executedDate?: boolean
    status?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recurringTransaction?: boolean | RecurringTransactionDefaultArgs<ExtArgs>
    transaction?: boolean | RecurringTransactionExecution$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTransactionExecution"]>

  export type RecurringTransactionExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recurringTransactionId?: boolean
    transactionId?: boolean
    scheduledDate?: boolean
    executedDate?: boolean
    status?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recurringTransaction?: boolean | RecurringTransactionDefaultArgs<ExtArgs>
    transaction?: boolean | RecurringTransactionExecution$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTransactionExecution"]>

  export type RecurringTransactionExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recurringTransactionId?: boolean
    transactionId?: boolean
    scheduledDate?: boolean
    executedDate?: boolean
    status?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recurringTransaction?: boolean | RecurringTransactionDefaultArgs<ExtArgs>
    transaction?: boolean | RecurringTransactionExecution$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["recurringTransactionExecution"]>

  export type RecurringTransactionExecutionSelectScalar = {
    id?: boolean
    recurringTransactionId?: boolean
    transactionId?: boolean
    scheduledDate?: boolean
    executedDate?: boolean
    status?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringTransactionExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recurringTransactionId" | "transactionId" | "scheduledDate" | "executedDate" | "status" | "errorMessage" | "retryCount" | "createdAt" | "updatedAt", ExtArgs["result"]["recurringTransactionExecution"]>
  export type RecurringTransactionExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recurringTransaction?: boolean | RecurringTransactionDefaultArgs<ExtArgs>
    transaction?: boolean | RecurringTransactionExecution$transactionArgs<ExtArgs>
  }
  export type RecurringTransactionExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recurringTransaction?: boolean | RecurringTransactionDefaultArgs<ExtArgs>
    transaction?: boolean | RecurringTransactionExecution$transactionArgs<ExtArgs>
  }
  export type RecurringTransactionExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recurringTransaction?: boolean | RecurringTransactionDefaultArgs<ExtArgs>
    transaction?: boolean | RecurringTransactionExecution$transactionArgs<ExtArgs>
  }

  export type $RecurringTransactionExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringTransactionExecution"
    objects: {
      recurringTransaction: Prisma.$RecurringTransactionPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recurringTransactionId: string
      transactionId: string | null
      scheduledDate: Date
      executedDate: Date | null
      status: string
      errorMessage: string | null
      retryCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringTransactionExecution"]>
    composites: {}
  }

  type RecurringTransactionExecutionGetPayload<S extends boolean | null | undefined | RecurringTransactionExecutionDefaultArgs> = $Result.GetResult<Prisma.$RecurringTransactionExecutionPayload, S>

  type RecurringTransactionExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringTransactionExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringTransactionExecutionCountAggregateInputType | true
    }

  export interface RecurringTransactionExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringTransactionExecution'], meta: { name: 'RecurringTransactionExecution' } }
    /**
     * Find zero or one RecurringTransactionExecution that matches the filter.
     * @param {RecurringTransactionExecutionFindUniqueArgs} args - Arguments to find a RecurringTransactionExecution
     * @example
     * // Get one RecurringTransactionExecution
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringTransactionExecutionFindUniqueArgs>(args: SelectSubset<T, RecurringTransactionExecutionFindUniqueArgs<ExtArgs>>): Prisma__RecurringTransactionExecutionClient<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringTransactionExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringTransactionExecutionFindUniqueOrThrowArgs} args - Arguments to find a RecurringTransactionExecution
     * @example
     * // Get one RecurringTransactionExecution
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringTransactionExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringTransactionExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringTransactionExecutionClient<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringTransactionExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionExecutionFindFirstArgs} args - Arguments to find a RecurringTransactionExecution
     * @example
     * // Get one RecurringTransactionExecution
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringTransactionExecutionFindFirstArgs>(args?: SelectSubset<T, RecurringTransactionExecutionFindFirstArgs<ExtArgs>>): Prisma__RecurringTransactionExecutionClient<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringTransactionExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionExecutionFindFirstOrThrowArgs} args - Arguments to find a RecurringTransactionExecution
     * @example
     * // Get one RecurringTransactionExecution
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringTransactionExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringTransactionExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringTransactionExecutionClient<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringTransactionExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringTransactionExecutions
     * const recurringTransactionExecutions = await prisma.recurringTransactionExecution.findMany()
     * 
     * // Get first 10 RecurringTransactionExecutions
     * const recurringTransactionExecutions = await prisma.recurringTransactionExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringTransactionExecutionWithIdOnly = await prisma.recurringTransactionExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringTransactionExecutionFindManyArgs>(args?: SelectSubset<T, RecurringTransactionExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringTransactionExecution.
     * @param {RecurringTransactionExecutionCreateArgs} args - Arguments to create a RecurringTransactionExecution.
     * @example
     * // Create one RecurringTransactionExecution
     * const RecurringTransactionExecution = await prisma.recurringTransactionExecution.create({
     *   data: {
     *     // ... data to create a RecurringTransactionExecution
     *   }
     * })
     * 
     */
    create<T extends RecurringTransactionExecutionCreateArgs>(args: SelectSubset<T, RecurringTransactionExecutionCreateArgs<ExtArgs>>): Prisma__RecurringTransactionExecutionClient<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringTransactionExecutions.
     * @param {RecurringTransactionExecutionCreateManyArgs} args - Arguments to create many RecurringTransactionExecutions.
     * @example
     * // Create many RecurringTransactionExecutions
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringTransactionExecutionCreateManyArgs>(args?: SelectSubset<T, RecurringTransactionExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringTransactionExecutions and returns the data saved in the database.
     * @param {RecurringTransactionExecutionCreateManyAndReturnArgs} args - Arguments to create many RecurringTransactionExecutions.
     * @example
     * // Create many RecurringTransactionExecutions
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringTransactionExecutions and only return the `id`
     * const recurringTransactionExecutionWithIdOnly = await prisma.recurringTransactionExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringTransactionExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringTransactionExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringTransactionExecution.
     * @param {RecurringTransactionExecutionDeleteArgs} args - Arguments to delete one RecurringTransactionExecution.
     * @example
     * // Delete one RecurringTransactionExecution
     * const RecurringTransactionExecution = await prisma.recurringTransactionExecution.delete({
     *   where: {
     *     // ... filter to delete one RecurringTransactionExecution
     *   }
     * })
     * 
     */
    delete<T extends RecurringTransactionExecutionDeleteArgs>(args: SelectSubset<T, RecurringTransactionExecutionDeleteArgs<ExtArgs>>): Prisma__RecurringTransactionExecutionClient<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringTransactionExecution.
     * @param {RecurringTransactionExecutionUpdateArgs} args - Arguments to update one RecurringTransactionExecution.
     * @example
     * // Update one RecurringTransactionExecution
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringTransactionExecutionUpdateArgs>(args: SelectSubset<T, RecurringTransactionExecutionUpdateArgs<ExtArgs>>): Prisma__RecurringTransactionExecutionClient<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringTransactionExecutions.
     * @param {RecurringTransactionExecutionDeleteManyArgs} args - Arguments to filter RecurringTransactionExecutions to delete.
     * @example
     * // Delete a few RecurringTransactionExecutions
     * const { count } = await prisma.recurringTransactionExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringTransactionExecutionDeleteManyArgs>(args?: SelectSubset<T, RecurringTransactionExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringTransactionExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringTransactionExecutions
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringTransactionExecutionUpdateManyArgs>(args: SelectSubset<T, RecurringTransactionExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringTransactionExecutions and returns the data updated in the database.
     * @param {RecurringTransactionExecutionUpdateManyAndReturnArgs} args - Arguments to update many RecurringTransactionExecutions.
     * @example
     * // Update many RecurringTransactionExecutions
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringTransactionExecutions and only return the `id`
     * const recurringTransactionExecutionWithIdOnly = await prisma.recurringTransactionExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringTransactionExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringTransactionExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringTransactionExecution.
     * @param {RecurringTransactionExecutionUpsertArgs} args - Arguments to update or create a RecurringTransactionExecution.
     * @example
     * // Update or create a RecurringTransactionExecution
     * const recurringTransactionExecution = await prisma.recurringTransactionExecution.upsert({
     *   create: {
     *     // ... data to create a RecurringTransactionExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringTransactionExecution we want to update
     *   }
     * })
     */
    upsert<T extends RecurringTransactionExecutionUpsertArgs>(args: SelectSubset<T, RecurringTransactionExecutionUpsertArgs<ExtArgs>>): Prisma__RecurringTransactionExecutionClient<$Result.GetResult<Prisma.$RecurringTransactionExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringTransactionExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionExecutionCountArgs} args - Arguments to filter RecurringTransactionExecutions to count.
     * @example
     * // Count the number of RecurringTransactionExecutions
     * const count = await prisma.recurringTransactionExecution.count({
     *   where: {
     *     // ... the filter for the RecurringTransactionExecutions we want to count
     *   }
     * })
    **/
    count<T extends RecurringTransactionExecutionCountArgs>(
      args?: Subset<T, RecurringTransactionExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringTransactionExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringTransactionExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringTransactionExecutionAggregateArgs>(args: Subset<T, RecurringTransactionExecutionAggregateArgs>): Prisma.PrismaPromise<GetRecurringTransactionExecutionAggregateType<T>>

    /**
     * Group by RecurringTransactionExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringTransactionExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringTransactionExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringTransactionExecutionGroupByArgs['orderBy'] }
        : { orderBy?: RecurringTransactionExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringTransactionExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringTransactionExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringTransactionExecution model
   */
  readonly fields: RecurringTransactionExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringTransactionExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringTransactionExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recurringTransaction<T extends RecurringTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecurringTransactionDefaultArgs<ExtArgs>>): Prisma__RecurringTransactionClient<$Result.GetResult<Prisma.$RecurringTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends RecurringTransactionExecution$transactionArgs<ExtArgs> = {}>(args?: Subset<T, RecurringTransactionExecution$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringTransactionExecution model
   */
  interface RecurringTransactionExecutionFieldRefs {
    readonly id: FieldRef<"RecurringTransactionExecution", 'String'>
    readonly recurringTransactionId: FieldRef<"RecurringTransactionExecution", 'String'>
    readonly transactionId: FieldRef<"RecurringTransactionExecution", 'String'>
    readonly scheduledDate: FieldRef<"RecurringTransactionExecution", 'DateTime'>
    readonly executedDate: FieldRef<"RecurringTransactionExecution", 'DateTime'>
    readonly status: FieldRef<"RecurringTransactionExecution", 'String'>
    readonly errorMessage: FieldRef<"RecurringTransactionExecution", 'String'>
    readonly retryCount: FieldRef<"RecurringTransactionExecution", 'Int'>
    readonly createdAt: FieldRef<"RecurringTransactionExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringTransactionExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringTransactionExecution findUnique
   */
  export type RecurringTransactionExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransactionExecution to fetch.
     */
    where: RecurringTransactionExecutionWhereUniqueInput
  }

  /**
   * RecurringTransactionExecution findUniqueOrThrow
   */
  export type RecurringTransactionExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransactionExecution to fetch.
     */
    where: RecurringTransactionExecutionWhereUniqueInput
  }

  /**
   * RecurringTransactionExecution findFirst
   */
  export type RecurringTransactionExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransactionExecution to fetch.
     */
    where?: RecurringTransactionExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTransactionExecutions to fetch.
     */
    orderBy?: RecurringTransactionExecutionOrderByWithRelationInput | RecurringTransactionExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringTransactionExecutions.
     */
    cursor?: RecurringTransactionExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTransactionExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTransactionExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringTransactionExecutions.
     */
    distinct?: RecurringTransactionExecutionScalarFieldEnum | RecurringTransactionExecutionScalarFieldEnum[]
  }

  /**
   * RecurringTransactionExecution findFirstOrThrow
   */
  export type RecurringTransactionExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransactionExecution to fetch.
     */
    where?: RecurringTransactionExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTransactionExecutions to fetch.
     */
    orderBy?: RecurringTransactionExecutionOrderByWithRelationInput | RecurringTransactionExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringTransactionExecutions.
     */
    cursor?: RecurringTransactionExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTransactionExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTransactionExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringTransactionExecutions.
     */
    distinct?: RecurringTransactionExecutionScalarFieldEnum | RecurringTransactionExecutionScalarFieldEnum[]
  }

  /**
   * RecurringTransactionExecution findMany
   */
  export type RecurringTransactionExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecurringTransactionExecutions to fetch.
     */
    where?: RecurringTransactionExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringTransactionExecutions to fetch.
     */
    orderBy?: RecurringTransactionExecutionOrderByWithRelationInput | RecurringTransactionExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringTransactionExecutions.
     */
    cursor?: RecurringTransactionExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringTransactionExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringTransactionExecutions.
     */
    skip?: number
    distinct?: RecurringTransactionExecutionScalarFieldEnum | RecurringTransactionExecutionScalarFieldEnum[]
  }

  /**
   * RecurringTransactionExecution create
   */
  export type RecurringTransactionExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringTransactionExecution.
     */
    data: XOR<RecurringTransactionExecutionCreateInput, RecurringTransactionExecutionUncheckedCreateInput>
  }

  /**
   * RecurringTransactionExecution createMany
   */
  export type RecurringTransactionExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringTransactionExecutions.
     */
    data: RecurringTransactionExecutionCreateManyInput | RecurringTransactionExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringTransactionExecution createManyAndReturn
   */
  export type RecurringTransactionExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringTransactionExecutions.
     */
    data: RecurringTransactionExecutionCreateManyInput | RecurringTransactionExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringTransactionExecution update
   */
  export type RecurringTransactionExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringTransactionExecution.
     */
    data: XOR<RecurringTransactionExecutionUpdateInput, RecurringTransactionExecutionUncheckedUpdateInput>
    /**
     * Choose, which RecurringTransactionExecution to update.
     */
    where: RecurringTransactionExecutionWhereUniqueInput
  }

  /**
   * RecurringTransactionExecution updateMany
   */
  export type RecurringTransactionExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringTransactionExecutions.
     */
    data: XOR<RecurringTransactionExecutionUpdateManyMutationInput, RecurringTransactionExecutionUncheckedUpdateManyInput>
    /**
     * Filter which RecurringTransactionExecutions to update
     */
    where?: RecurringTransactionExecutionWhereInput
    /**
     * Limit how many RecurringTransactionExecutions to update.
     */
    limit?: number
  }

  /**
   * RecurringTransactionExecution updateManyAndReturn
   */
  export type RecurringTransactionExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * The data used to update RecurringTransactionExecutions.
     */
    data: XOR<RecurringTransactionExecutionUpdateManyMutationInput, RecurringTransactionExecutionUncheckedUpdateManyInput>
    /**
     * Filter which RecurringTransactionExecutions to update
     */
    where?: RecurringTransactionExecutionWhereInput
    /**
     * Limit how many RecurringTransactionExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringTransactionExecution upsert
   */
  export type RecurringTransactionExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringTransactionExecution to update in case it exists.
     */
    where: RecurringTransactionExecutionWhereUniqueInput
    /**
     * In case the RecurringTransactionExecution found by the `where` argument doesn't exist, create a new RecurringTransactionExecution with this data.
     */
    create: XOR<RecurringTransactionExecutionCreateInput, RecurringTransactionExecutionUncheckedCreateInput>
    /**
     * In case the RecurringTransactionExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringTransactionExecutionUpdateInput, RecurringTransactionExecutionUncheckedUpdateInput>
  }

  /**
   * RecurringTransactionExecution delete
   */
  export type RecurringTransactionExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
    /**
     * Filter which RecurringTransactionExecution to delete.
     */
    where: RecurringTransactionExecutionWhereUniqueInput
  }

  /**
   * RecurringTransactionExecution deleteMany
   */
  export type RecurringTransactionExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringTransactionExecutions to delete
     */
    where?: RecurringTransactionExecutionWhereInput
    /**
     * Limit how many RecurringTransactionExecutions to delete.
     */
    limit?: number
  }

  /**
   * RecurringTransactionExecution.transaction
   */
  export type RecurringTransactionExecution$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * RecurringTransactionExecution without action
   */
  export type RecurringTransactionExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringTransactionExecution
     */
    select?: RecurringTransactionExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringTransactionExecution
     */
    omit?: RecurringTransactionExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringTransactionExecutionInclude<ExtArgs> | null
  }


  /**
   * Model DocumentUpload
   */

  export type AggregateDocumentUpload = {
    _count: DocumentUploadCountAggregateOutputType | null
    _avg: DocumentUploadAvgAggregateOutputType | null
    _sum: DocumentUploadSumAggregateOutputType | null
    _min: DocumentUploadMinAggregateOutputType | null
    _max: DocumentUploadMaxAggregateOutputType | null
  }

  export type DocumentUploadAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentUploadSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentUploadMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    documentType: $Enums.DocumentType | null
    status: $Enums.ProcessingStatus | null
    uploadedBy: string | null
    uploadedAt: Date | null
    processedAt: Date | null
    storageUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentUploadMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    documentType: $Enums.DocumentType | null
    status: $Enums.ProcessingStatus | null
    uploadedBy: string | null
    uploadedAt: Date | null
    processedAt: Date | null
    storageUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentUploadCountAggregateOutputType = {
    id: number
    householdId: number
    fileName: number
    fileSize: number
    mimeType: number
    documentType: number
    status: number
    uploadedBy: number
    uploadedAt: number
    processedAt: number
    storageUrl: number
    description: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentUploadAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentUploadSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentUploadMinAggregateInputType = {
    id?: true
    householdId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    documentType?: true
    status?: true
    uploadedBy?: true
    uploadedAt?: true
    processedAt?: true
    storageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentUploadMaxAggregateInputType = {
    id?: true
    householdId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    documentType?: true
    status?: true
    uploadedBy?: true
    uploadedAt?: true
    processedAt?: true
    storageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentUploadCountAggregateInputType = {
    id?: true
    householdId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    documentType?: true
    status?: true
    uploadedBy?: true
    uploadedAt?: true
    processedAt?: true
    storageUrl?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentUploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentUpload to aggregate.
     */
    where?: DocumentUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentUploads to fetch.
     */
    orderBy?: DocumentUploadOrderByWithRelationInput | DocumentUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentUploads
    **/
    _count?: true | DocumentUploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentUploadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentUploadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentUploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentUploadMaxAggregateInputType
  }

  export type GetDocumentUploadAggregateType<T extends DocumentUploadAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentUpload[P]>
      : GetScalarType<T[P], AggregateDocumentUpload[P]>
  }




  export type DocumentUploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentUploadWhereInput
    orderBy?: DocumentUploadOrderByWithAggregationInput | DocumentUploadOrderByWithAggregationInput[]
    by: DocumentUploadScalarFieldEnum[] | DocumentUploadScalarFieldEnum
    having?: DocumentUploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentUploadCountAggregateInputType | true
    _avg?: DocumentUploadAvgAggregateInputType
    _sum?: DocumentUploadSumAggregateInputType
    _min?: DocumentUploadMinAggregateInputType
    _max?: DocumentUploadMaxAggregateInputType
  }

  export type DocumentUploadGroupByOutputType = {
    id: string
    householdId: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status: $Enums.ProcessingStatus
    uploadedBy: string
    uploadedAt: Date
    processedAt: Date | null
    storageUrl: string
    description: string | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DocumentUploadCountAggregateOutputType | null
    _avg: DocumentUploadAvgAggregateOutputType | null
    _sum: DocumentUploadSumAggregateOutputType | null
    _min: DocumentUploadMinAggregateOutputType | null
    _max: DocumentUploadMaxAggregateOutputType | null
  }

  type GetDocumentUploadGroupByPayload<T extends DocumentUploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentUploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentUploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentUploadGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentUploadGroupByOutputType[P]>
        }
      >
    >


  export type DocumentUploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    documentType?: boolean
    status?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    processedAt?: boolean
    storageUrl?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    ocrResults?: boolean | DocumentUpload$ocrResultsArgs<ExtArgs>
    transactionSuggestions?: boolean | DocumentUpload$transactionSuggestionsArgs<ExtArgs>
    _count?: boolean | DocumentUploadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentUpload"]>

  export type DocumentUploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    documentType?: boolean
    status?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    processedAt?: boolean
    storageUrl?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentUpload"]>

  export type DocumentUploadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    documentType?: boolean
    status?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    processedAt?: boolean
    storageUrl?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentUpload"]>

  export type DocumentUploadSelectScalar = {
    id?: boolean
    householdId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    documentType?: boolean
    status?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    processedAt?: boolean
    storageUrl?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentUploadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "fileName" | "fileSize" | "mimeType" | "documentType" | "status" | "uploadedBy" | "uploadedAt" | "processedAt" | "storageUrl" | "description" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["documentUpload"]>
  export type DocumentUploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    ocrResults?: boolean | DocumentUpload$ocrResultsArgs<ExtArgs>
    transactionSuggestions?: boolean | DocumentUpload$transactionSuggestionsArgs<ExtArgs>
    _count?: boolean | DocumentUploadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentUploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentUploadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentUploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentUpload"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
      ocrResults: Prisma.$OcrResultPayload<ExtArgs>[]
      transactionSuggestions: Prisma.$TransactionSuggestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      fileName: string
      fileSize: number
      mimeType: string
      documentType: $Enums.DocumentType
      status: $Enums.ProcessingStatus
      uploadedBy: string
      uploadedAt: Date
      processedAt: Date | null
      storageUrl: string
      description: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentUpload"]>
    composites: {}
  }

  type DocumentUploadGetPayload<S extends boolean | null | undefined | DocumentUploadDefaultArgs> = $Result.GetResult<Prisma.$DocumentUploadPayload, S>

  type DocumentUploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentUploadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentUploadCountAggregateInputType | true
    }

  export interface DocumentUploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentUpload'], meta: { name: 'DocumentUpload' } }
    /**
     * Find zero or one DocumentUpload that matches the filter.
     * @param {DocumentUploadFindUniqueArgs} args - Arguments to find a DocumentUpload
     * @example
     * // Get one DocumentUpload
     * const documentUpload = await prisma.documentUpload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentUploadFindUniqueArgs>(args: SelectSubset<T, DocumentUploadFindUniqueArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentUpload that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentUploadFindUniqueOrThrowArgs} args - Arguments to find a DocumentUpload
     * @example
     * // Get one DocumentUpload
     * const documentUpload = await prisma.documentUpload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentUploadFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentUploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentUpload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUploadFindFirstArgs} args - Arguments to find a DocumentUpload
     * @example
     * // Get one DocumentUpload
     * const documentUpload = await prisma.documentUpload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentUploadFindFirstArgs>(args?: SelectSubset<T, DocumentUploadFindFirstArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentUpload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUploadFindFirstOrThrowArgs} args - Arguments to find a DocumentUpload
     * @example
     * // Get one DocumentUpload
     * const documentUpload = await prisma.documentUpload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentUploadFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentUploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentUploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentUploads
     * const documentUploads = await prisma.documentUpload.findMany()
     * 
     * // Get first 10 DocumentUploads
     * const documentUploads = await prisma.documentUpload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentUploadWithIdOnly = await prisma.documentUpload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentUploadFindManyArgs>(args?: SelectSubset<T, DocumentUploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentUpload.
     * @param {DocumentUploadCreateArgs} args - Arguments to create a DocumentUpload.
     * @example
     * // Create one DocumentUpload
     * const DocumentUpload = await prisma.documentUpload.create({
     *   data: {
     *     // ... data to create a DocumentUpload
     *   }
     * })
     * 
     */
    create<T extends DocumentUploadCreateArgs>(args: SelectSubset<T, DocumentUploadCreateArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentUploads.
     * @param {DocumentUploadCreateManyArgs} args - Arguments to create many DocumentUploads.
     * @example
     * // Create many DocumentUploads
     * const documentUpload = await prisma.documentUpload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentUploadCreateManyArgs>(args?: SelectSubset<T, DocumentUploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentUploads and returns the data saved in the database.
     * @param {DocumentUploadCreateManyAndReturnArgs} args - Arguments to create many DocumentUploads.
     * @example
     * // Create many DocumentUploads
     * const documentUpload = await prisma.documentUpload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentUploads and only return the `id`
     * const documentUploadWithIdOnly = await prisma.documentUpload.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentUploadCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentUploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentUpload.
     * @param {DocumentUploadDeleteArgs} args - Arguments to delete one DocumentUpload.
     * @example
     * // Delete one DocumentUpload
     * const DocumentUpload = await prisma.documentUpload.delete({
     *   where: {
     *     // ... filter to delete one DocumentUpload
     *   }
     * })
     * 
     */
    delete<T extends DocumentUploadDeleteArgs>(args: SelectSubset<T, DocumentUploadDeleteArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentUpload.
     * @param {DocumentUploadUpdateArgs} args - Arguments to update one DocumentUpload.
     * @example
     * // Update one DocumentUpload
     * const documentUpload = await prisma.documentUpload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUploadUpdateArgs>(args: SelectSubset<T, DocumentUploadUpdateArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentUploads.
     * @param {DocumentUploadDeleteManyArgs} args - Arguments to filter DocumentUploads to delete.
     * @example
     * // Delete a few DocumentUploads
     * const { count } = await prisma.documentUpload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentUploadDeleteManyArgs>(args?: SelectSubset<T, DocumentUploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentUploads
     * const documentUpload = await prisma.documentUpload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUploadUpdateManyArgs>(args: SelectSubset<T, DocumentUploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentUploads and returns the data updated in the database.
     * @param {DocumentUploadUpdateManyAndReturnArgs} args - Arguments to update many DocumentUploads.
     * @example
     * // Update many DocumentUploads
     * const documentUpload = await prisma.documentUpload.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentUploads and only return the `id`
     * const documentUploadWithIdOnly = await prisma.documentUpload.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUploadUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUploadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentUpload.
     * @param {DocumentUploadUpsertArgs} args - Arguments to update or create a DocumentUpload.
     * @example
     * // Update or create a DocumentUpload
     * const documentUpload = await prisma.documentUpload.upsert({
     *   create: {
     *     // ... data to create a DocumentUpload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentUpload we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUploadUpsertArgs>(args: SelectSubset<T, DocumentUploadUpsertArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUploadCountArgs} args - Arguments to filter DocumentUploads to count.
     * @example
     * // Count the number of DocumentUploads
     * const count = await prisma.documentUpload.count({
     *   where: {
     *     // ... the filter for the DocumentUploads we want to count
     *   }
     * })
    **/
    count<T extends DocumentUploadCountArgs>(
      args?: Subset<T, DocumentUploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentUploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentUploadAggregateArgs>(args: Subset<T, DocumentUploadAggregateArgs>): Prisma.PrismaPromise<GetDocumentUploadAggregateType<T>>

    /**
     * Group by DocumentUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentUploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentUploadGroupByArgs['orderBy'] }
        : { orderBy?: DocumentUploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentUploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentUpload model
   */
  readonly fields: DocumentUploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentUpload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentUploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ocrResults<T extends DocumentUpload$ocrResultsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentUpload$ocrResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionSuggestions<T extends DocumentUpload$transactionSuggestionsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentUpload$transactionSuggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentUpload model
   */
  interface DocumentUploadFieldRefs {
    readonly id: FieldRef<"DocumentUpload", 'String'>
    readonly householdId: FieldRef<"DocumentUpload", 'String'>
    readonly fileName: FieldRef<"DocumentUpload", 'String'>
    readonly fileSize: FieldRef<"DocumentUpload", 'Int'>
    readonly mimeType: FieldRef<"DocumentUpload", 'String'>
    readonly documentType: FieldRef<"DocumentUpload", 'DocumentType'>
    readonly status: FieldRef<"DocumentUpload", 'ProcessingStatus'>
    readonly uploadedBy: FieldRef<"DocumentUpload", 'String'>
    readonly uploadedAt: FieldRef<"DocumentUpload", 'DateTime'>
    readonly processedAt: FieldRef<"DocumentUpload", 'DateTime'>
    readonly storageUrl: FieldRef<"DocumentUpload", 'String'>
    readonly description: FieldRef<"DocumentUpload", 'String'>
    readonly metadata: FieldRef<"DocumentUpload", 'Json'>
    readonly createdAt: FieldRef<"DocumentUpload", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentUpload", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentUpload findUnique
   */
  export type DocumentUploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * Filter, which DocumentUpload to fetch.
     */
    where: DocumentUploadWhereUniqueInput
  }

  /**
   * DocumentUpload findUniqueOrThrow
   */
  export type DocumentUploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * Filter, which DocumentUpload to fetch.
     */
    where: DocumentUploadWhereUniqueInput
  }

  /**
   * DocumentUpload findFirst
   */
  export type DocumentUploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * Filter, which DocumentUpload to fetch.
     */
    where?: DocumentUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentUploads to fetch.
     */
    orderBy?: DocumentUploadOrderByWithRelationInput | DocumentUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentUploads.
     */
    cursor?: DocumentUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentUploads.
     */
    distinct?: DocumentUploadScalarFieldEnum | DocumentUploadScalarFieldEnum[]
  }

  /**
   * DocumentUpload findFirstOrThrow
   */
  export type DocumentUploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * Filter, which DocumentUpload to fetch.
     */
    where?: DocumentUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentUploads to fetch.
     */
    orderBy?: DocumentUploadOrderByWithRelationInput | DocumentUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentUploads.
     */
    cursor?: DocumentUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentUploads.
     */
    distinct?: DocumentUploadScalarFieldEnum | DocumentUploadScalarFieldEnum[]
  }

  /**
   * DocumentUpload findMany
   */
  export type DocumentUploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * Filter, which DocumentUploads to fetch.
     */
    where?: DocumentUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentUploads to fetch.
     */
    orderBy?: DocumentUploadOrderByWithRelationInput | DocumentUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentUploads.
     */
    cursor?: DocumentUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentUploads.
     */
    skip?: number
    distinct?: DocumentUploadScalarFieldEnum | DocumentUploadScalarFieldEnum[]
  }

  /**
   * DocumentUpload create
   */
  export type DocumentUploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentUpload.
     */
    data: XOR<DocumentUploadCreateInput, DocumentUploadUncheckedCreateInput>
  }

  /**
   * DocumentUpload createMany
   */
  export type DocumentUploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentUploads.
     */
    data: DocumentUploadCreateManyInput | DocumentUploadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentUpload createManyAndReturn
   */
  export type DocumentUploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentUploads.
     */
    data: DocumentUploadCreateManyInput | DocumentUploadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentUpload update
   */
  export type DocumentUploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentUpload.
     */
    data: XOR<DocumentUploadUpdateInput, DocumentUploadUncheckedUpdateInput>
    /**
     * Choose, which DocumentUpload to update.
     */
    where: DocumentUploadWhereUniqueInput
  }

  /**
   * DocumentUpload updateMany
   */
  export type DocumentUploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentUploads.
     */
    data: XOR<DocumentUploadUpdateManyMutationInput, DocumentUploadUncheckedUpdateManyInput>
    /**
     * Filter which DocumentUploads to update
     */
    where?: DocumentUploadWhereInput
    /**
     * Limit how many DocumentUploads to update.
     */
    limit?: number
  }

  /**
   * DocumentUpload updateManyAndReturn
   */
  export type DocumentUploadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * The data used to update DocumentUploads.
     */
    data: XOR<DocumentUploadUpdateManyMutationInput, DocumentUploadUncheckedUpdateManyInput>
    /**
     * Filter which DocumentUploads to update
     */
    where?: DocumentUploadWhereInput
    /**
     * Limit how many DocumentUploads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentUpload upsert
   */
  export type DocumentUploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentUpload to update in case it exists.
     */
    where: DocumentUploadWhereUniqueInput
    /**
     * In case the DocumentUpload found by the `where` argument doesn't exist, create a new DocumentUpload with this data.
     */
    create: XOR<DocumentUploadCreateInput, DocumentUploadUncheckedCreateInput>
    /**
     * In case the DocumentUpload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUploadUpdateInput, DocumentUploadUncheckedUpdateInput>
  }

  /**
   * DocumentUpload delete
   */
  export type DocumentUploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
    /**
     * Filter which DocumentUpload to delete.
     */
    where: DocumentUploadWhereUniqueInput
  }

  /**
   * DocumentUpload deleteMany
   */
  export type DocumentUploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentUploads to delete
     */
    where?: DocumentUploadWhereInput
    /**
     * Limit how many DocumentUploads to delete.
     */
    limit?: number
  }

  /**
   * DocumentUpload.ocrResults
   */
  export type DocumentUpload$ocrResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    where?: OcrResultWhereInput
    orderBy?: OcrResultOrderByWithRelationInput | OcrResultOrderByWithRelationInput[]
    cursor?: OcrResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OcrResultScalarFieldEnum | OcrResultScalarFieldEnum[]
  }

  /**
   * DocumentUpload.transactionSuggestions
   */
  export type DocumentUpload$transactionSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    where?: TransactionSuggestionWhereInput
    orderBy?: TransactionSuggestionOrderByWithRelationInput | TransactionSuggestionOrderByWithRelationInput[]
    cursor?: TransactionSuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionSuggestionScalarFieldEnum | TransactionSuggestionScalarFieldEnum[]
  }

  /**
   * DocumentUpload without action
   */
  export type DocumentUploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentUpload
     */
    select?: DocumentUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentUpload
     */
    omit?: DocumentUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentUploadInclude<ExtArgs> | null
  }


  /**
   * Model OcrResult
   */

  export type AggregateOcrResult = {
    _count: OcrResultCountAggregateOutputType | null
    _avg: OcrResultAvgAggregateOutputType | null
    _sum: OcrResultSumAggregateOutputType | null
    _min: OcrResultMinAggregateOutputType | null
    _max: OcrResultMaxAggregateOutputType | null
  }

  export type OcrResultAvgAggregateOutputType = {
    confidence: Decimal | null
  }

  export type OcrResultSumAggregateOutputType = {
    confidence: Decimal | null
  }

  export type OcrResultMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    documentType: $Enums.DocumentType | null
    confidence: Decimal | null
    rawText: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type OcrResultMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    documentType: $Enums.DocumentType | null
    confidence: Decimal | null
    rawText: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type OcrResultCountAggregateOutputType = {
    id: number
    documentId: number
    documentType: number
    confidence: number
    extractedData: number
    rawText: number
    processedAt: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type OcrResultAvgAggregateInputType = {
    confidence?: true
  }

  export type OcrResultSumAggregateInputType = {
    confidence?: true
  }

  export type OcrResultMinAggregateInputType = {
    id?: true
    documentId?: true
    documentType?: true
    confidence?: true
    rawText?: true
    processedAt?: true
    createdAt?: true
  }

  export type OcrResultMaxAggregateInputType = {
    id?: true
    documentId?: true
    documentType?: true
    confidence?: true
    rawText?: true
    processedAt?: true
    createdAt?: true
  }

  export type OcrResultCountAggregateInputType = {
    id?: true
    documentId?: true
    documentType?: true
    confidence?: true
    extractedData?: true
    rawText?: true
    processedAt?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type OcrResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OcrResult to aggregate.
     */
    where?: OcrResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OcrResults to fetch.
     */
    orderBy?: OcrResultOrderByWithRelationInput | OcrResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OcrResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OcrResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OcrResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OcrResults
    **/
    _count?: true | OcrResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OcrResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OcrResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OcrResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OcrResultMaxAggregateInputType
  }

  export type GetOcrResultAggregateType<T extends OcrResultAggregateArgs> = {
        [P in keyof T & keyof AggregateOcrResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOcrResult[P]>
      : GetScalarType<T[P], AggregateOcrResult[P]>
  }




  export type OcrResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OcrResultWhereInput
    orderBy?: OcrResultOrderByWithAggregationInput | OcrResultOrderByWithAggregationInput[]
    by: OcrResultScalarFieldEnum[] | OcrResultScalarFieldEnum
    having?: OcrResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OcrResultCountAggregateInputType | true
    _avg?: OcrResultAvgAggregateInputType
    _sum?: OcrResultSumAggregateInputType
    _min?: OcrResultMinAggregateInputType
    _max?: OcrResultMaxAggregateInputType
  }

  export type OcrResultGroupByOutputType = {
    id: string
    documentId: string
    documentType: $Enums.DocumentType
    confidence: Decimal
    extractedData: JsonValue
    rawText: string
    processedAt: Date
    metadata: JsonValue
    createdAt: Date
    _count: OcrResultCountAggregateOutputType | null
    _avg: OcrResultAvgAggregateOutputType | null
    _sum: OcrResultSumAggregateOutputType | null
    _min: OcrResultMinAggregateOutputType | null
    _max: OcrResultMaxAggregateOutputType | null
  }

  type GetOcrResultGroupByPayload<T extends OcrResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OcrResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OcrResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OcrResultGroupByOutputType[P]>
            : GetScalarType<T[P], OcrResultGroupByOutputType[P]>
        }
      >
    >


  export type OcrResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentType?: boolean
    confidence?: boolean
    extractedData?: boolean
    rawText?: boolean
    processedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
    transactionSuggestions?: boolean | OcrResult$transactionSuggestionsArgs<ExtArgs>
    _count?: boolean | OcrResultCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ocrResult"]>

  export type OcrResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentType?: boolean
    confidence?: boolean
    extractedData?: boolean
    rawText?: boolean
    processedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ocrResult"]>

  export type OcrResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentType?: boolean
    confidence?: boolean
    extractedData?: boolean
    rawText?: boolean
    processedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ocrResult"]>

  export type OcrResultSelectScalar = {
    id?: boolean
    documentId?: boolean
    documentType?: boolean
    confidence?: boolean
    extractedData?: boolean
    rawText?: boolean
    processedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type OcrResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "documentType" | "confidence" | "extractedData" | "rawText" | "processedAt" | "metadata" | "createdAt", ExtArgs["result"]["ocrResult"]>
  export type OcrResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
    transactionSuggestions?: boolean | OcrResult$transactionSuggestionsArgs<ExtArgs>
    _count?: boolean | OcrResultCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OcrResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
  }
  export type OcrResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
  }

  export type $OcrResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OcrResult"
    objects: {
      document: Prisma.$DocumentUploadPayload<ExtArgs>
      transactionSuggestions: Prisma.$TransactionSuggestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      documentType: $Enums.DocumentType
      confidence: Prisma.Decimal
      extractedData: Prisma.JsonValue
      rawText: string
      processedAt: Date
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["ocrResult"]>
    composites: {}
  }

  type OcrResultGetPayload<S extends boolean | null | undefined | OcrResultDefaultArgs> = $Result.GetResult<Prisma.$OcrResultPayload, S>

  type OcrResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OcrResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OcrResultCountAggregateInputType | true
    }

  export interface OcrResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OcrResult'], meta: { name: 'OcrResult' } }
    /**
     * Find zero or one OcrResult that matches the filter.
     * @param {OcrResultFindUniqueArgs} args - Arguments to find a OcrResult
     * @example
     * // Get one OcrResult
     * const ocrResult = await prisma.ocrResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OcrResultFindUniqueArgs>(args: SelectSubset<T, OcrResultFindUniqueArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OcrResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OcrResultFindUniqueOrThrowArgs} args - Arguments to find a OcrResult
     * @example
     * // Get one OcrResult
     * const ocrResult = await prisma.ocrResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OcrResultFindUniqueOrThrowArgs>(args: SelectSubset<T, OcrResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OcrResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcrResultFindFirstArgs} args - Arguments to find a OcrResult
     * @example
     * // Get one OcrResult
     * const ocrResult = await prisma.ocrResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OcrResultFindFirstArgs>(args?: SelectSubset<T, OcrResultFindFirstArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OcrResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcrResultFindFirstOrThrowArgs} args - Arguments to find a OcrResult
     * @example
     * // Get one OcrResult
     * const ocrResult = await prisma.ocrResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OcrResultFindFirstOrThrowArgs>(args?: SelectSubset<T, OcrResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OcrResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcrResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OcrResults
     * const ocrResults = await prisma.ocrResult.findMany()
     * 
     * // Get first 10 OcrResults
     * const ocrResults = await prisma.ocrResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ocrResultWithIdOnly = await prisma.ocrResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OcrResultFindManyArgs>(args?: SelectSubset<T, OcrResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OcrResult.
     * @param {OcrResultCreateArgs} args - Arguments to create a OcrResult.
     * @example
     * // Create one OcrResult
     * const OcrResult = await prisma.ocrResult.create({
     *   data: {
     *     // ... data to create a OcrResult
     *   }
     * })
     * 
     */
    create<T extends OcrResultCreateArgs>(args: SelectSubset<T, OcrResultCreateArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OcrResults.
     * @param {OcrResultCreateManyArgs} args - Arguments to create many OcrResults.
     * @example
     * // Create many OcrResults
     * const ocrResult = await prisma.ocrResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OcrResultCreateManyArgs>(args?: SelectSubset<T, OcrResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OcrResults and returns the data saved in the database.
     * @param {OcrResultCreateManyAndReturnArgs} args - Arguments to create many OcrResults.
     * @example
     * // Create many OcrResults
     * const ocrResult = await prisma.ocrResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OcrResults and only return the `id`
     * const ocrResultWithIdOnly = await prisma.ocrResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OcrResultCreateManyAndReturnArgs>(args?: SelectSubset<T, OcrResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OcrResult.
     * @param {OcrResultDeleteArgs} args - Arguments to delete one OcrResult.
     * @example
     * // Delete one OcrResult
     * const OcrResult = await prisma.ocrResult.delete({
     *   where: {
     *     // ... filter to delete one OcrResult
     *   }
     * })
     * 
     */
    delete<T extends OcrResultDeleteArgs>(args: SelectSubset<T, OcrResultDeleteArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OcrResult.
     * @param {OcrResultUpdateArgs} args - Arguments to update one OcrResult.
     * @example
     * // Update one OcrResult
     * const ocrResult = await prisma.ocrResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OcrResultUpdateArgs>(args: SelectSubset<T, OcrResultUpdateArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OcrResults.
     * @param {OcrResultDeleteManyArgs} args - Arguments to filter OcrResults to delete.
     * @example
     * // Delete a few OcrResults
     * const { count } = await prisma.ocrResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OcrResultDeleteManyArgs>(args?: SelectSubset<T, OcrResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OcrResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcrResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OcrResults
     * const ocrResult = await prisma.ocrResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OcrResultUpdateManyArgs>(args: SelectSubset<T, OcrResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OcrResults and returns the data updated in the database.
     * @param {OcrResultUpdateManyAndReturnArgs} args - Arguments to update many OcrResults.
     * @example
     * // Update many OcrResults
     * const ocrResult = await prisma.ocrResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OcrResults and only return the `id`
     * const ocrResultWithIdOnly = await prisma.ocrResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OcrResultUpdateManyAndReturnArgs>(args: SelectSubset<T, OcrResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OcrResult.
     * @param {OcrResultUpsertArgs} args - Arguments to update or create a OcrResult.
     * @example
     * // Update or create a OcrResult
     * const ocrResult = await prisma.ocrResult.upsert({
     *   create: {
     *     // ... data to create a OcrResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OcrResult we want to update
     *   }
     * })
     */
    upsert<T extends OcrResultUpsertArgs>(args: SelectSubset<T, OcrResultUpsertArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OcrResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcrResultCountArgs} args - Arguments to filter OcrResults to count.
     * @example
     * // Count the number of OcrResults
     * const count = await prisma.ocrResult.count({
     *   where: {
     *     // ... the filter for the OcrResults we want to count
     *   }
     * })
    **/
    count<T extends OcrResultCountArgs>(
      args?: Subset<T, OcrResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OcrResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OcrResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcrResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OcrResultAggregateArgs>(args: Subset<T, OcrResultAggregateArgs>): Prisma.PrismaPromise<GetOcrResultAggregateType<T>>

    /**
     * Group by OcrResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcrResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OcrResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OcrResultGroupByArgs['orderBy'] }
        : { orderBy?: OcrResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OcrResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOcrResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OcrResult model
   */
  readonly fields: OcrResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OcrResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OcrResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentUploadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentUploadDefaultArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactionSuggestions<T extends OcrResult$transactionSuggestionsArgs<ExtArgs> = {}>(args?: Subset<T, OcrResult$transactionSuggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OcrResult model
   */
  interface OcrResultFieldRefs {
    readonly id: FieldRef<"OcrResult", 'String'>
    readonly documentId: FieldRef<"OcrResult", 'String'>
    readonly documentType: FieldRef<"OcrResult", 'DocumentType'>
    readonly confidence: FieldRef<"OcrResult", 'Decimal'>
    readonly extractedData: FieldRef<"OcrResult", 'Json'>
    readonly rawText: FieldRef<"OcrResult", 'String'>
    readonly processedAt: FieldRef<"OcrResult", 'DateTime'>
    readonly metadata: FieldRef<"OcrResult", 'Json'>
    readonly createdAt: FieldRef<"OcrResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OcrResult findUnique
   */
  export type OcrResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * Filter, which OcrResult to fetch.
     */
    where: OcrResultWhereUniqueInput
  }

  /**
   * OcrResult findUniqueOrThrow
   */
  export type OcrResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * Filter, which OcrResult to fetch.
     */
    where: OcrResultWhereUniqueInput
  }

  /**
   * OcrResult findFirst
   */
  export type OcrResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * Filter, which OcrResult to fetch.
     */
    where?: OcrResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OcrResults to fetch.
     */
    orderBy?: OcrResultOrderByWithRelationInput | OcrResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OcrResults.
     */
    cursor?: OcrResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OcrResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OcrResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OcrResults.
     */
    distinct?: OcrResultScalarFieldEnum | OcrResultScalarFieldEnum[]
  }

  /**
   * OcrResult findFirstOrThrow
   */
  export type OcrResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * Filter, which OcrResult to fetch.
     */
    where?: OcrResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OcrResults to fetch.
     */
    orderBy?: OcrResultOrderByWithRelationInput | OcrResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OcrResults.
     */
    cursor?: OcrResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OcrResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OcrResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OcrResults.
     */
    distinct?: OcrResultScalarFieldEnum | OcrResultScalarFieldEnum[]
  }

  /**
   * OcrResult findMany
   */
  export type OcrResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * Filter, which OcrResults to fetch.
     */
    where?: OcrResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OcrResults to fetch.
     */
    orderBy?: OcrResultOrderByWithRelationInput | OcrResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OcrResults.
     */
    cursor?: OcrResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OcrResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OcrResults.
     */
    skip?: number
    distinct?: OcrResultScalarFieldEnum | OcrResultScalarFieldEnum[]
  }

  /**
   * OcrResult create
   */
  export type OcrResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * The data needed to create a OcrResult.
     */
    data: XOR<OcrResultCreateInput, OcrResultUncheckedCreateInput>
  }

  /**
   * OcrResult createMany
   */
  export type OcrResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OcrResults.
     */
    data: OcrResultCreateManyInput | OcrResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OcrResult createManyAndReturn
   */
  export type OcrResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * The data used to create many OcrResults.
     */
    data: OcrResultCreateManyInput | OcrResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OcrResult update
   */
  export type OcrResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * The data needed to update a OcrResult.
     */
    data: XOR<OcrResultUpdateInput, OcrResultUncheckedUpdateInput>
    /**
     * Choose, which OcrResult to update.
     */
    where: OcrResultWhereUniqueInput
  }

  /**
   * OcrResult updateMany
   */
  export type OcrResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OcrResults.
     */
    data: XOR<OcrResultUpdateManyMutationInput, OcrResultUncheckedUpdateManyInput>
    /**
     * Filter which OcrResults to update
     */
    where?: OcrResultWhereInput
    /**
     * Limit how many OcrResults to update.
     */
    limit?: number
  }

  /**
   * OcrResult updateManyAndReturn
   */
  export type OcrResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * The data used to update OcrResults.
     */
    data: XOR<OcrResultUpdateManyMutationInput, OcrResultUncheckedUpdateManyInput>
    /**
     * Filter which OcrResults to update
     */
    where?: OcrResultWhereInput
    /**
     * Limit how many OcrResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OcrResult upsert
   */
  export type OcrResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * The filter to search for the OcrResult to update in case it exists.
     */
    where: OcrResultWhereUniqueInput
    /**
     * In case the OcrResult found by the `where` argument doesn't exist, create a new OcrResult with this data.
     */
    create: XOR<OcrResultCreateInput, OcrResultUncheckedCreateInput>
    /**
     * In case the OcrResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OcrResultUpdateInput, OcrResultUncheckedUpdateInput>
  }

  /**
   * OcrResult delete
   */
  export type OcrResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    /**
     * Filter which OcrResult to delete.
     */
    where: OcrResultWhereUniqueInput
  }

  /**
   * OcrResult deleteMany
   */
  export type OcrResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OcrResults to delete
     */
    where?: OcrResultWhereInput
    /**
     * Limit how many OcrResults to delete.
     */
    limit?: number
  }

  /**
   * OcrResult.transactionSuggestions
   */
  export type OcrResult$transactionSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    where?: TransactionSuggestionWhereInput
    orderBy?: TransactionSuggestionOrderByWithRelationInput | TransactionSuggestionOrderByWithRelationInput[]
    cursor?: TransactionSuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionSuggestionScalarFieldEnum | TransactionSuggestionScalarFieldEnum[]
  }

  /**
   * OcrResult without action
   */
  export type OcrResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
  }


  /**
   * Model TransactionSuggestion
   */

  export type AggregateTransactionSuggestion = {
    _count: TransactionSuggestionCountAggregateOutputType | null
    _avg: TransactionSuggestionAvgAggregateOutputType | null
    _sum: TransactionSuggestionSumAggregateOutputType | null
    _min: TransactionSuggestionMinAggregateOutputType | null
    _max: TransactionSuggestionMaxAggregateOutputType | null
  }

  export type TransactionSuggestionAvgAggregateOutputType = {
    amountCents: number | null
    confidence: Decimal | null
  }

  export type TransactionSuggestionSumAggregateOutputType = {
    amountCents: bigint | null
    confidence: Decimal | null
  }

  export type TransactionSuggestionMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    ocrResultId: string | null
    description: string | null
    amountCents: bigint | null
    currency: string | null
    date: Date | null
    merchant: string | null
    suggestedCategoryId: string | null
    suggestedCategoryName: string | null
    confidence: Decimal | null
    source: string | null
    status: string | null
    isApproved: boolean | null
    approvedAt: Date | null
    createdTransactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionSuggestionMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    ocrResultId: string | null
    description: string | null
    amountCents: bigint | null
    currency: string | null
    date: Date | null
    merchant: string | null
    suggestedCategoryId: string | null
    suggestedCategoryName: string | null
    confidence: Decimal | null
    source: string | null
    status: string | null
    isApproved: boolean | null
    approvedAt: Date | null
    createdTransactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionSuggestionCountAggregateOutputType = {
    id: number
    documentId: number
    ocrResultId: number
    description: number
    amountCents: number
    currency: number
    date: number
    merchant: number
    suggestedCategoryId: number
    suggestedCategoryName: number
    confidence: number
    source: number
    status: number
    isApproved: number
    approvedAt: number
    metadata: number
    createdTransactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionSuggestionAvgAggregateInputType = {
    amountCents?: true
    confidence?: true
  }

  export type TransactionSuggestionSumAggregateInputType = {
    amountCents?: true
    confidence?: true
  }

  export type TransactionSuggestionMinAggregateInputType = {
    id?: true
    documentId?: true
    ocrResultId?: true
    description?: true
    amountCents?: true
    currency?: true
    date?: true
    merchant?: true
    suggestedCategoryId?: true
    suggestedCategoryName?: true
    confidence?: true
    source?: true
    status?: true
    isApproved?: true
    approvedAt?: true
    createdTransactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionSuggestionMaxAggregateInputType = {
    id?: true
    documentId?: true
    ocrResultId?: true
    description?: true
    amountCents?: true
    currency?: true
    date?: true
    merchant?: true
    suggestedCategoryId?: true
    suggestedCategoryName?: true
    confidence?: true
    source?: true
    status?: true
    isApproved?: true
    approvedAt?: true
    createdTransactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionSuggestionCountAggregateInputType = {
    id?: true
    documentId?: true
    ocrResultId?: true
    description?: true
    amountCents?: true
    currency?: true
    date?: true
    merchant?: true
    suggestedCategoryId?: true
    suggestedCategoryName?: true
    confidence?: true
    source?: true
    status?: true
    isApproved?: true
    approvedAt?: true
    metadata?: true
    createdTransactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionSuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionSuggestion to aggregate.
     */
    where?: TransactionSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionSuggestions to fetch.
     */
    orderBy?: TransactionSuggestionOrderByWithRelationInput | TransactionSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionSuggestions
    **/
    _count?: true | TransactionSuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionSuggestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSuggestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionSuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionSuggestionMaxAggregateInputType
  }

  export type GetTransactionSuggestionAggregateType<T extends TransactionSuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionSuggestion[P]>
      : GetScalarType<T[P], AggregateTransactionSuggestion[P]>
  }




  export type TransactionSuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionSuggestionWhereInput
    orderBy?: TransactionSuggestionOrderByWithAggregationInput | TransactionSuggestionOrderByWithAggregationInput[]
    by: TransactionSuggestionScalarFieldEnum[] | TransactionSuggestionScalarFieldEnum
    having?: TransactionSuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionSuggestionCountAggregateInputType | true
    _avg?: TransactionSuggestionAvgAggregateInputType
    _sum?: TransactionSuggestionSumAggregateInputType
    _min?: TransactionSuggestionMinAggregateInputType
    _max?: TransactionSuggestionMaxAggregateInputType
  }

  export type TransactionSuggestionGroupByOutputType = {
    id: string
    documentId: string
    ocrResultId: string | null
    description: string
    amountCents: bigint
    currency: string
    date: Date
    merchant: string | null
    suggestedCategoryId: string | null
    suggestedCategoryName: string | null
    confidence: Decimal
    source: string
    status: string
    isApproved: boolean
    approvedAt: Date | null
    metadata: JsonValue
    createdTransactionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionSuggestionCountAggregateOutputType | null
    _avg: TransactionSuggestionAvgAggregateOutputType | null
    _sum: TransactionSuggestionSumAggregateOutputType | null
    _min: TransactionSuggestionMinAggregateOutputType | null
    _max: TransactionSuggestionMaxAggregateOutputType | null
  }

  type GetTransactionSuggestionGroupByPayload<T extends TransactionSuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionSuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionSuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionSuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionSuggestionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    ocrResultId?: boolean
    description?: boolean
    amountCents?: boolean
    currency?: boolean
    date?: boolean
    merchant?: boolean
    suggestedCategoryId?: boolean
    suggestedCategoryName?: boolean
    confidence?: boolean
    source?: boolean
    status?: boolean
    isApproved?: boolean
    approvedAt?: boolean
    metadata?: boolean
    createdTransactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
    ocrResult?: boolean | TransactionSuggestion$ocrResultArgs<ExtArgs>
    suggestedCategory?: boolean | TransactionSuggestion$suggestedCategoryArgs<ExtArgs>
    createdTransaction?: boolean | TransactionSuggestion$createdTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["transactionSuggestion"]>

  export type TransactionSuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    ocrResultId?: boolean
    description?: boolean
    amountCents?: boolean
    currency?: boolean
    date?: boolean
    merchant?: boolean
    suggestedCategoryId?: boolean
    suggestedCategoryName?: boolean
    confidence?: boolean
    source?: boolean
    status?: boolean
    isApproved?: boolean
    approvedAt?: boolean
    metadata?: boolean
    createdTransactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
    ocrResult?: boolean | TransactionSuggestion$ocrResultArgs<ExtArgs>
    suggestedCategory?: boolean | TransactionSuggestion$suggestedCategoryArgs<ExtArgs>
    createdTransaction?: boolean | TransactionSuggestion$createdTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["transactionSuggestion"]>

  export type TransactionSuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    ocrResultId?: boolean
    description?: boolean
    amountCents?: boolean
    currency?: boolean
    date?: boolean
    merchant?: boolean
    suggestedCategoryId?: boolean
    suggestedCategoryName?: boolean
    confidence?: boolean
    source?: boolean
    status?: boolean
    isApproved?: boolean
    approvedAt?: boolean
    metadata?: boolean
    createdTransactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
    ocrResult?: boolean | TransactionSuggestion$ocrResultArgs<ExtArgs>
    suggestedCategory?: boolean | TransactionSuggestion$suggestedCategoryArgs<ExtArgs>
    createdTransaction?: boolean | TransactionSuggestion$createdTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["transactionSuggestion"]>

  export type TransactionSuggestionSelectScalar = {
    id?: boolean
    documentId?: boolean
    ocrResultId?: boolean
    description?: boolean
    amountCents?: boolean
    currency?: boolean
    date?: boolean
    merchant?: boolean
    suggestedCategoryId?: boolean
    suggestedCategoryName?: boolean
    confidence?: boolean
    source?: boolean
    status?: boolean
    isApproved?: boolean
    approvedAt?: boolean
    metadata?: boolean
    createdTransactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionSuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "ocrResultId" | "description" | "amountCents" | "currency" | "date" | "merchant" | "suggestedCategoryId" | "suggestedCategoryName" | "confidence" | "source" | "status" | "isApproved" | "approvedAt" | "metadata" | "createdTransactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionSuggestion"]>
  export type TransactionSuggestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
    ocrResult?: boolean | TransactionSuggestion$ocrResultArgs<ExtArgs>
    suggestedCategory?: boolean | TransactionSuggestion$suggestedCategoryArgs<ExtArgs>
    createdTransaction?: boolean | TransactionSuggestion$createdTransactionArgs<ExtArgs>
  }
  export type TransactionSuggestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
    ocrResult?: boolean | TransactionSuggestion$ocrResultArgs<ExtArgs>
    suggestedCategory?: boolean | TransactionSuggestion$suggestedCategoryArgs<ExtArgs>
    createdTransaction?: boolean | TransactionSuggestion$createdTransactionArgs<ExtArgs>
  }
  export type TransactionSuggestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentUploadDefaultArgs<ExtArgs>
    ocrResult?: boolean | TransactionSuggestion$ocrResultArgs<ExtArgs>
    suggestedCategory?: boolean | TransactionSuggestion$suggestedCategoryArgs<ExtArgs>
    createdTransaction?: boolean | TransactionSuggestion$createdTransactionArgs<ExtArgs>
  }

  export type $TransactionSuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionSuggestion"
    objects: {
      document: Prisma.$DocumentUploadPayload<ExtArgs>
      ocrResult: Prisma.$OcrResultPayload<ExtArgs> | null
      suggestedCategory: Prisma.$CategoryPayload<ExtArgs> | null
      createdTransaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      ocrResultId: string | null
      description: string
      amountCents: bigint
      currency: string
      date: Date
      merchant: string | null
      suggestedCategoryId: string | null
      suggestedCategoryName: string | null
      confidence: Prisma.Decimal
      source: string
      status: string
      isApproved: boolean
      approvedAt: Date | null
      metadata: Prisma.JsonValue
      createdTransactionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionSuggestion"]>
    composites: {}
  }

  type TransactionSuggestionGetPayload<S extends boolean | null | undefined | TransactionSuggestionDefaultArgs> = $Result.GetResult<Prisma.$TransactionSuggestionPayload, S>

  type TransactionSuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionSuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionSuggestionCountAggregateInputType | true
    }

  export interface TransactionSuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionSuggestion'], meta: { name: 'TransactionSuggestion' } }
    /**
     * Find zero or one TransactionSuggestion that matches the filter.
     * @param {TransactionSuggestionFindUniqueArgs} args - Arguments to find a TransactionSuggestion
     * @example
     * // Get one TransactionSuggestion
     * const transactionSuggestion = await prisma.transactionSuggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionSuggestionFindUniqueArgs>(args: SelectSubset<T, TransactionSuggestionFindUniqueArgs<ExtArgs>>): Prisma__TransactionSuggestionClient<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionSuggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionSuggestionFindUniqueOrThrowArgs} args - Arguments to find a TransactionSuggestion
     * @example
     * // Get one TransactionSuggestion
     * const transactionSuggestion = await prisma.transactionSuggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionSuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionSuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionSuggestionClient<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionSuggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSuggestionFindFirstArgs} args - Arguments to find a TransactionSuggestion
     * @example
     * // Get one TransactionSuggestion
     * const transactionSuggestion = await prisma.transactionSuggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionSuggestionFindFirstArgs>(args?: SelectSubset<T, TransactionSuggestionFindFirstArgs<ExtArgs>>): Prisma__TransactionSuggestionClient<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionSuggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSuggestionFindFirstOrThrowArgs} args - Arguments to find a TransactionSuggestion
     * @example
     * // Get one TransactionSuggestion
     * const transactionSuggestion = await prisma.transactionSuggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionSuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionSuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionSuggestionClient<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionSuggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionSuggestions
     * const transactionSuggestions = await prisma.transactionSuggestion.findMany()
     * 
     * // Get first 10 TransactionSuggestions
     * const transactionSuggestions = await prisma.transactionSuggestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionSuggestionWithIdOnly = await prisma.transactionSuggestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionSuggestionFindManyArgs>(args?: SelectSubset<T, TransactionSuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionSuggestion.
     * @param {TransactionSuggestionCreateArgs} args - Arguments to create a TransactionSuggestion.
     * @example
     * // Create one TransactionSuggestion
     * const TransactionSuggestion = await prisma.transactionSuggestion.create({
     *   data: {
     *     // ... data to create a TransactionSuggestion
     *   }
     * })
     * 
     */
    create<T extends TransactionSuggestionCreateArgs>(args: SelectSubset<T, TransactionSuggestionCreateArgs<ExtArgs>>): Prisma__TransactionSuggestionClient<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionSuggestions.
     * @param {TransactionSuggestionCreateManyArgs} args - Arguments to create many TransactionSuggestions.
     * @example
     * // Create many TransactionSuggestions
     * const transactionSuggestion = await prisma.transactionSuggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionSuggestionCreateManyArgs>(args?: SelectSubset<T, TransactionSuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionSuggestions and returns the data saved in the database.
     * @param {TransactionSuggestionCreateManyAndReturnArgs} args - Arguments to create many TransactionSuggestions.
     * @example
     * // Create many TransactionSuggestions
     * const transactionSuggestion = await prisma.transactionSuggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionSuggestions and only return the `id`
     * const transactionSuggestionWithIdOnly = await prisma.transactionSuggestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionSuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionSuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionSuggestion.
     * @param {TransactionSuggestionDeleteArgs} args - Arguments to delete one TransactionSuggestion.
     * @example
     * // Delete one TransactionSuggestion
     * const TransactionSuggestion = await prisma.transactionSuggestion.delete({
     *   where: {
     *     // ... filter to delete one TransactionSuggestion
     *   }
     * })
     * 
     */
    delete<T extends TransactionSuggestionDeleteArgs>(args: SelectSubset<T, TransactionSuggestionDeleteArgs<ExtArgs>>): Prisma__TransactionSuggestionClient<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionSuggestion.
     * @param {TransactionSuggestionUpdateArgs} args - Arguments to update one TransactionSuggestion.
     * @example
     * // Update one TransactionSuggestion
     * const transactionSuggestion = await prisma.transactionSuggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionSuggestionUpdateArgs>(args: SelectSubset<T, TransactionSuggestionUpdateArgs<ExtArgs>>): Prisma__TransactionSuggestionClient<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionSuggestions.
     * @param {TransactionSuggestionDeleteManyArgs} args - Arguments to filter TransactionSuggestions to delete.
     * @example
     * // Delete a few TransactionSuggestions
     * const { count } = await prisma.transactionSuggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionSuggestionDeleteManyArgs>(args?: SelectSubset<T, TransactionSuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionSuggestions
     * const transactionSuggestion = await prisma.transactionSuggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionSuggestionUpdateManyArgs>(args: SelectSubset<T, TransactionSuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionSuggestions and returns the data updated in the database.
     * @param {TransactionSuggestionUpdateManyAndReturnArgs} args - Arguments to update many TransactionSuggestions.
     * @example
     * // Update many TransactionSuggestions
     * const transactionSuggestion = await prisma.transactionSuggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionSuggestions and only return the `id`
     * const transactionSuggestionWithIdOnly = await prisma.transactionSuggestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionSuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionSuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionSuggestion.
     * @param {TransactionSuggestionUpsertArgs} args - Arguments to update or create a TransactionSuggestion.
     * @example
     * // Update or create a TransactionSuggestion
     * const transactionSuggestion = await prisma.transactionSuggestion.upsert({
     *   create: {
     *     // ... data to create a TransactionSuggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionSuggestion we want to update
     *   }
     * })
     */
    upsert<T extends TransactionSuggestionUpsertArgs>(args: SelectSubset<T, TransactionSuggestionUpsertArgs<ExtArgs>>): Prisma__TransactionSuggestionClient<$Result.GetResult<Prisma.$TransactionSuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSuggestionCountArgs} args - Arguments to filter TransactionSuggestions to count.
     * @example
     * // Count the number of TransactionSuggestions
     * const count = await prisma.transactionSuggestion.count({
     *   where: {
     *     // ... the filter for the TransactionSuggestions we want to count
     *   }
     * })
    **/
    count<T extends TransactionSuggestionCountArgs>(
      args?: Subset<T, TransactionSuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionSuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionSuggestionAggregateArgs>(args: Subset<T, TransactionSuggestionAggregateArgs>): Prisma.PrismaPromise<GetTransactionSuggestionAggregateType<T>>

    /**
     * Group by TransactionSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionSuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionSuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionSuggestionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionSuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionSuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionSuggestion model
   */
  readonly fields: TransactionSuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionSuggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionSuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentUploadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentUploadDefaultArgs<ExtArgs>>): Prisma__DocumentUploadClient<$Result.GetResult<Prisma.$DocumentUploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ocrResult<T extends TransactionSuggestion$ocrResultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionSuggestion$ocrResultArgs<ExtArgs>>): Prisma__OcrResultClient<$Result.GetResult<Prisma.$OcrResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    suggestedCategory<T extends TransactionSuggestion$suggestedCategoryArgs<ExtArgs> = {}>(args?: Subset<T, TransactionSuggestion$suggestedCategoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdTransaction<T extends TransactionSuggestion$createdTransactionArgs<ExtArgs> = {}>(args?: Subset<T, TransactionSuggestion$createdTransactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionSuggestion model
   */
  interface TransactionSuggestionFieldRefs {
    readonly id: FieldRef<"TransactionSuggestion", 'String'>
    readonly documentId: FieldRef<"TransactionSuggestion", 'String'>
    readonly ocrResultId: FieldRef<"TransactionSuggestion", 'String'>
    readonly description: FieldRef<"TransactionSuggestion", 'String'>
    readonly amountCents: FieldRef<"TransactionSuggestion", 'BigInt'>
    readonly currency: FieldRef<"TransactionSuggestion", 'String'>
    readonly date: FieldRef<"TransactionSuggestion", 'DateTime'>
    readonly merchant: FieldRef<"TransactionSuggestion", 'String'>
    readonly suggestedCategoryId: FieldRef<"TransactionSuggestion", 'String'>
    readonly suggestedCategoryName: FieldRef<"TransactionSuggestion", 'String'>
    readonly confidence: FieldRef<"TransactionSuggestion", 'Decimal'>
    readonly source: FieldRef<"TransactionSuggestion", 'String'>
    readonly status: FieldRef<"TransactionSuggestion", 'String'>
    readonly isApproved: FieldRef<"TransactionSuggestion", 'Boolean'>
    readonly approvedAt: FieldRef<"TransactionSuggestion", 'DateTime'>
    readonly metadata: FieldRef<"TransactionSuggestion", 'Json'>
    readonly createdTransactionId: FieldRef<"TransactionSuggestion", 'String'>
    readonly createdAt: FieldRef<"TransactionSuggestion", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionSuggestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionSuggestion findUnique
   */
  export type TransactionSuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSuggestion to fetch.
     */
    where: TransactionSuggestionWhereUniqueInput
  }

  /**
   * TransactionSuggestion findUniqueOrThrow
   */
  export type TransactionSuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSuggestion to fetch.
     */
    where: TransactionSuggestionWhereUniqueInput
  }

  /**
   * TransactionSuggestion findFirst
   */
  export type TransactionSuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSuggestion to fetch.
     */
    where?: TransactionSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionSuggestions to fetch.
     */
    orderBy?: TransactionSuggestionOrderByWithRelationInput | TransactionSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionSuggestions.
     */
    cursor?: TransactionSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionSuggestions.
     */
    distinct?: TransactionSuggestionScalarFieldEnum | TransactionSuggestionScalarFieldEnum[]
  }

  /**
   * TransactionSuggestion findFirstOrThrow
   */
  export type TransactionSuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSuggestion to fetch.
     */
    where?: TransactionSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionSuggestions to fetch.
     */
    orderBy?: TransactionSuggestionOrderByWithRelationInput | TransactionSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionSuggestions.
     */
    cursor?: TransactionSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionSuggestions.
     */
    distinct?: TransactionSuggestionScalarFieldEnum | TransactionSuggestionScalarFieldEnum[]
  }

  /**
   * TransactionSuggestion findMany
   */
  export type TransactionSuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which TransactionSuggestions to fetch.
     */
    where?: TransactionSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionSuggestions to fetch.
     */
    orderBy?: TransactionSuggestionOrderByWithRelationInput | TransactionSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionSuggestions.
     */
    cursor?: TransactionSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionSuggestions.
     */
    skip?: number
    distinct?: TransactionSuggestionScalarFieldEnum | TransactionSuggestionScalarFieldEnum[]
  }

  /**
   * TransactionSuggestion create
   */
  export type TransactionSuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionSuggestion.
     */
    data: XOR<TransactionSuggestionCreateInput, TransactionSuggestionUncheckedCreateInput>
  }

  /**
   * TransactionSuggestion createMany
   */
  export type TransactionSuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionSuggestions.
     */
    data: TransactionSuggestionCreateManyInput | TransactionSuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionSuggestion createManyAndReturn
   */
  export type TransactionSuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionSuggestions.
     */
    data: TransactionSuggestionCreateManyInput | TransactionSuggestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionSuggestion update
   */
  export type TransactionSuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionSuggestion.
     */
    data: XOR<TransactionSuggestionUpdateInput, TransactionSuggestionUncheckedUpdateInput>
    /**
     * Choose, which TransactionSuggestion to update.
     */
    where: TransactionSuggestionWhereUniqueInput
  }

  /**
   * TransactionSuggestion updateMany
   */
  export type TransactionSuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionSuggestions.
     */
    data: XOR<TransactionSuggestionUpdateManyMutationInput, TransactionSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which TransactionSuggestions to update
     */
    where?: TransactionSuggestionWhereInput
    /**
     * Limit how many TransactionSuggestions to update.
     */
    limit?: number
  }

  /**
   * TransactionSuggestion updateManyAndReturn
   */
  export type TransactionSuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * The data used to update TransactionSuggestions.
     */
    data: XOR<TransactionSuggestionUpdateManyMutationInput, TransactionSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which TransactionSuggestions to update
     */
    where?: TransactionSuggestionWhereInput
    /**
     * Limit how many TransactionSuggestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionSuggestion upsert
   */
  export type TransactionSuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionSuggestion to update in case it exists.
     */
    where: TransactionSuggestionWhereUniqueInput
    /**
     * In case the TransactionSuggestion found by the `where` argument doesn't exist, create a new TransactionSuggestion with this data.
     */
    create: XOR<TransactionSuggestionCreateInput, TransactionSuggestionUncheckedCreateInput>
    /**
     * In case the TransactionSuggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionSuggestionUpdateInput, TransactionSuggestionUncheckedUpdateInput>
  }

  /**
   * TransactionSuggestion delete
   */
  export type TransactionSuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
    /**
     * Filter which TransactionSuggestion to delete.
     */
    where: TransactionSuggestionWhereUniqueInput
  }

  /**
   * TransactionSuggestion deleteMany
   */
  export type TransactionSuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionSuggestions to delete
     */
    where?: TransactionSuggestionWhereInput
    /**
     * Limit how many TransactionSuggestions to delete.
     */
    limit?: number
  }

  /**
   * TransactionSuggestion.ocrResult
   */
  export type TransactionSuggestion$ocrResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcrResult
     */
    select?: OcrResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OcrResult
     */
    omit?: OcrResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcrResultInclude<ExtArgs> | null
    where?: OcrResultWhereInput
  }

  /**
   * TransactionSuggestion.suggestedCategory
   */
  export type TransactionSuggestion$suggestedCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * TransactionSuggestion.createdTransaction
   */
  export type TransactionSuggestion$createdTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * TransactionSuggestion without action
   */
  export type TransactionSuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionSuggestion
     */
    select?: TransactionSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionSuggestion
     */
    omit?: TransactionSuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionSuggestionInclude<ExtArgs> | null
  }


  /**
   * Model ZakatCalculation
   */

  export type AggregateZakatCalculation = {
    _count: ZakatCalculationCountAggregateOutputType | null
    _avg: ZakatCalculationAvgAggregateOutputType | null
    _sum: ZakatCalculationSumAggregateOutputType | null
    _min: ZakatCalculationMinAggregateOutputType | null
    _max: ZakatCalculationMaxAggregateOutputType | null
  }

  export type ZakatCalculationAvgAggregateOutputType = {
    hijriYear: number | null
    nisabThresholdCents: number | null
    totalZakatableAssetsCents: number | null
    zakatAmountCents: number | null
  }

  export type ZakatCalculationSumAggregateOutputType = {
    hijriYear: number | null
    nisabThresholdCents: bigint | null
    totalZakatableAssetsCents: bigint | null
    zakatAmountCents: bigint | null
  }

  export type ZakatCalculationMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    calculationDate: Date | null
    hijriYear: number | null
    nisabThresholdCents: bigint | null
    totalZakatableAssetsCents: bigint | null
    zakatAmountCents: bigint | null
    currency: string | null
    isZakatDue: boolean | null
    nextCalculationDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZakatCalculationMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    calculationDate: Date | null
    hijriYear: number | null
    nisabThresholdCents: bigint | null
    totalZakatableAssetsCents: bigint | null
    zakatAmountCents: bigint | null
    currency: string | null
    isZakatDue: boolean | null
    nextCalculationDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZakatCalculationCountAggregateOutputType = {
    id: number
    householdId: number
    calculationDate: number
    hijriYear: number
    nisabThresholdCents: number
    totalZakatableAssetsCents: number
    zakatAmountCents: number
    currency: number
    isZakatDue: number
    nextCalculationDate: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZakatCalculationAvgAggregateInputType = {
    hijriYear?: true
    nisabThresholdCents?: true
    totalZakatableAssetsCents?: true
    zakatAmountCents?: true
  }

  export type ZakatCalculationSumAggregateInputType = {
    hijriYear?: true
    nisabThresholdCents?: true
    totalZakatableAssetsCents?: true
    zakatAmountCents?: true
  }

  export type ZakatCalculationMinAggregateInputType = {
    id?: true
    householdId?: true
    calculationDate?: true
    hijriYear?: true
    nisabThresholdCents?: true
    totalZakatableAssetsCents?: true
    zakatAmountCents?: true
    currency?: true
    isZakatDue?: true
    nextCalculationDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZakatCalculationMaxAggregateInputType = {
    id?: true
    householdId?: true
    calculationDate?: true
    hijriYear?: true
    nisabThresholdCents?: true
    totalZakatableAssetsCents?: true
    zakatAmountCents?: true
    currency?: true
    isZakatDue?: true
    nextCalculationDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZakatCalculationCountAggregateInputType = {
    id?: true
    householdId?: true
    calculationDate?: true
    hijriYear?: true
    nisabThresholdCents?: true
    totalZakatableAssetsCents?: true
    zakatAmountCents?: true
    currency?: true
    isZakatDue?: true
    nextCalculationDate?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZakatCalculationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZakatCalculation to aggregate.
     */
    where?: ZakatCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatCalculations to fetch.
     */
    orderBy?: ZakatCalculationOrderByWithRelationInput | ZakatCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZakatCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZakatCalculations
    **/
    _count?: true | ZakatCalculationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZakatCalculationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZakatCalculationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZakatCalculationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZakatCalculationMaxAggregateInputType
  }

  export type GetZakatCalculationAggregateType<T extends ZakatCalculationAggregateArgs> = {
        [P in keyof T & keyof AggregateZakatCalculation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZakatCalculation[P]>
      : GetScalarType<T[P], AggregateZakatCalculation[P]>
  }




  export type ZakatCalculationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatCalculationWhereInput
    orderBy?: ZakatCalculationOrderByWithAggregationInput | ZakatCalculationOrderByWithAggregationInput[]
    by: ZakatCalculationScalarFieldEnum[] | ZakatCalculationScalarFieldEnum
    having?: ZakatCalculationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZakatCalculationCountAggregateInputType | true
    _avg?: ZakatCalculationAvgAggregateInputType
    _sum?: ZakatCalculationSumAggregateInputType
    _min?: ZakatCalculationMinAggregateInputType
    _max?: ZakatCalculationMaxAggregateInputType
  }

  export type ZakatCalculationGroupByOutputType = {
    id: string
    householdId: string
    calculationDate: Date
    hijriYear: number
    nisabThresholdCents: bigint
    totalZakatableAssetsCents: bigint
    zakatAmountCents: bigint
    currency: string
    isZakatDue: boolean
    nextCalculationDate: Date
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ZakatCalculationCountAggregateOutputType | null
    _avg: ZakatCalculationAvgAggregateOutputType | null
    _sum: ZakatCalculationSumAggregateOutputType | null
    _min: ZakatCalculationMinAggregateOutputType | null
    _max: ZakatCalculationMaxAggregateOutputType | null
  }

  type GetZakatCalculationGroupByPayload<T extends ZakatCalculationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZakatCalculationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZakatCalculationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZakatCalculationGroupByOutputType[P]>
            : GetScalarType<T[P], ZakatCalculationGroupByOutputType[P]>
        }
      >
    >


  export type ZakatCalculationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    calculationDate?: boolean
    hijriYear?: boolean
    nisabThresholdCents?: boolean
    totalZakatableAssetsCents?: boolean
    zakatAmountCents?: boolean
    currency?: boolean
    isZakatDue?: boolean
    nextCalculationDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    assetBreakdown?: boolean | ZakatCalculation$assetBreakdownArgs<ExtArgs>
    zakatPayments?: boolean | ZakatCalculation$zakatPaymentsArgs<ExtArgs>
    _count?: boolean | ZakatCalculationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zakatCalculation"]>

  export type ZakatCalculationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    calculationDate?: boolean
    hijriYear?: boolean
    nisabThresholdCents?: boolean
    totalZakatableAssetsCents?: boolean
    zakatAmountCents?: boolean
    currency?: boolean
    isZakatDue?: boolean
    nextCalculationDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zakatCalculation"]>

  export type ZakatCalculationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    calculationDate?: boolean
    hijriYear?: boolean
    nisabThresholdCents?: boolean
    totalZakatableAssetsCents?: boolean
    zakatAmountCents?: boolean
    currency?: boolean
    isZakatDue?: boolean
    nextCalculationDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zakatCalculation"]>

  export type ZakatCalculationSelectScalar = {
    id?: boolean
    householdId?: boolean
    calculationDate?: boolean
    hijriYear?: boolean
    nisabThresholdCents?: boolean
    totalZakatableAssetsCents?: boolean
    zakatAmountCents?: boolean
    currency?: boolean
    isZakatDue?: boolean
    nextCalculationDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZakatCalculationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "calculationDate" | "hijriYear" | "nisabThresholdCents" | "totalZakatableAssetsCents" | "zakatAmountCents" | "currency" | "isZakatDue" | "nextCalculationDate" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["zakatCalculation"]>
  export type ZakatCalculationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    assetBreakdown?: boolean | ZakatCalculation$assetBreakdownArgs<ExtArgs>
    zakatPayments?: boolean | ZakatCalculation$zakatPaymentsArgs<ExtArgs>
    _count?: boolean | ZakatCalculationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZakatCalculationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type ZakatCalculationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $ZakatCalculationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZakatCalculation"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      assetBreakdown: Prisma.$ZakatAssetBreakdownPayload<ExtArgs>[]
      zakatPayments: Prisma.$ZakatPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      calculationDate: Date
      hijriYear: number
      nisabThresholdCents: bigint
      totalZakatableAssetsCents: bigint
      zakatAmountCents: bigint
      currency: string
      isZakatDue: boolean
      nextCalculationDate: Date
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zakatCalculation"]>
    composites: {}
  }

  type ZakatCalculationGetPayload<S extends boolean | null | undefined | ZakatCalculationDefaultArgs> = $Result.GetResult<Prisma.$ZakatCalculationPayload, S>

  type ZakatCalculationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZakatCalculationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZakatCalculationCountAggregateInputType | true
    }

  export interface ZakatCalculationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZakatCalculation'], meta: { name: 'ZakatCalculation' } }
    /**
     * Find zero or one ZakatCalculation that matches the filter.
     * @param {ZakatCalculationFindUniqueArgs} args - Arguments to find a ZakatCalculation
     * @example
     * // Get one ZakatCalculation
     * const zakatCalculation = await prisma.zakatCalculation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZakatCalculationFindUniqueArgs>(args: SelectSubset<T, ZakatCalculationFindUniqueArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZakatCalculation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZakatCalculationFindUniqueOrThrowArgs} args - Arguments to find a ZakatCalculation
     * @example
     * // Get one ZakatCalculation
     * const zakatCalculation = await prisma.zakatCalculation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZakatCalculationFindUniqueOrThrowArgs>(args: SelectSubset<T, ZakatCalculationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZakatCalculation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatCalculationFindFirstArgs} args - Arguments to find a ZakatCalculation
     * @example
     * // Get one ZakatCalculation
     * const zakatCalculation = await prisma.zakatCalculation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZakatCalculationFindFirstArgs>(args?: SelectSubset<T, ZakatCalculationFindFirstArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZakatCalculation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatCalculationFindFirstOrThrowArgs} args - Arguments to find a ZakatCalculation
     * @example
     * // Get one ZakatCalculation
     * const zakatCalculation = await prisma.zakatCalculation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZakatCalculationFindFirstOrThrowArgs>(args?: SelectSubset<T, ZakatCalculationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZakatCalculations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatCalculationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZakatCalculations
     * const zakatCalculations = await prisma.zakatCalculation.findMany()
     * 
     * // Get first 10 ZakatCalculations
     * const zakatCalculations = await prisma.zakatCalculation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zakatCalculationWithIdOnly = await prisma.zakatCalculation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZakatCalculationFindManyArgs>(args?: SelectSubset<T, ZakatCalculationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZakatCalculation.
     * @param {ZakatCalculationCreateArgs} args - Arguments to create a ZakatCalculation.
     * @example
     * // Create one ZakatCalculation
     * const ZakatCalculation = await prisma.zakatCalculation.create({
     *   data: {
     *     // ... data to create a ZakatCalculation
     *   }
     * })
     * 
     */
    create<T extends ZakatCalculationCreateArgs>(args: SelectSubset<T, ZakatCalculationCreateArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZakatCalculations.
     * @param {ZakatCalculationCreateManyArgs} args - Arguments to create many ZakatCalculations.
     * @example
     * // Create many ZakatCalculations
     * const zakatCalculation = await prisma.zakatCalculation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZakatCalculationCreateManyArgs>(args?: SelectSubset<T, ZakatCalculationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZakatCalculations and returns the data saved in the database.
     * @param {ZakatCalculationCreateManyAndReturnArgs} args - Arguments to create many ZakatCalculations.
     * @example
     * // Create many ZakatCalculations
     * const zakatCalculation = await prisma.zakatCalculation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZakatCalculations and only return the `id`
     * const zakatCalculationWithIdOnly = await prisma.zakatCalculation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZakatCalculationCreateManyAndReturnArgs>(args?: SelectSubset<T, ZakatCalculationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZakatCalculation.
     * @param {ZakatCalculationDeleteArgs} args - Arguments to delete one ZakatCalculation.
     * @example
     * // Delete one ZakatCalculation
     * const ZakatCalculation = await prisma.zakatCalculation.delete({
     *   where: {
     *     // ... filter to delete one ZakatCalculation
     *   }
     * })
     * 
     */
    delete<T extends ZakatCalculationDeleteArgs>(args: SelectSubset<T, ZakatCalculationDeleteArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZakatCalculation.
     * @param {ZakatCalculationUpdateArgs} args - Arguments to update one ZakatCalculation.
     * @example
     * // Update one ZakatCalculation
     * const zakatCalculation = await prisma.zakatCalculation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZakatCalculationUpdateArgs>(args: SelectSubset<T, ZakatCalculationUpdateArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZakatCalculations.
     * @param {ZakatCalculationDeleteManyArgs} args - Arguments to filter ZakatCalculations to delete.
     * @example
     * // Delete a few ZakatCalculations
     * const { count } = await prisma.zakatCalculation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZakatCalculationDeleteManyArgs>(args?: SelectSubset<T, ZakatCalculationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZakatCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatCalculationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZakatCalculations
     * const zakatCalculation = await prisma.zakatCalculation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZakatCalculationUpdateManyArgs>(args: SelectSubset<T, ZakatCalculationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZakatCalculations and returns the data updated in the database.
     * @param {ZakatCalculationUpdateManyAndReturnArgs} args - Arguments to update many ZakatCalculations.
     * @example
     * // Update many ZakatCalculations
     * const zakatCalculation = await prisma.zakatCalculation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZakatCalculations and only return the `id`
     * const zakatCalculationWithIdOnly = await prisma.zakatCalculation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZakatCalculationUpdateManyAndReturnArgs>(args: SelectSubset<T, ZakatCalculationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZakatCalculation.
     * @param {ZakatCalculationUpsertArgs} args - Arguments to update or create a ZakatCalculation.
     * @example
     * // Update or create a ZakatCalculation
     * const zakatCalculation = await prisma.zakatCalculation.upsert({
     *   create: {
     *     // ... data to create a ZakatCalculation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZakatCalculation we want to update
     *   }
     * })
     */
    upsert<T extends ZakatCalculationUpsertArgs>(args: SelectSubset<T, ZakatCalculationUpsertArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZakatCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatCalculationCountArgs} args - Arguments to filter ZakatCalculations to count.
     * @example
     * // Count the number of ZakatCalculations
     * const count = await prisma.zakatCalculation.count({
     *   where: {
     *     // ... the filter for the ZakatCalculations we want to count
     *   }
     * })
    **/
    count<T extends ZakatCalculationCountArgs>(
      args?: Subset<T, ZakatCalculationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZakatCalculationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZakatCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatCalculationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZakatCalculationAggregateArgs>(args: Subset<T, ZakatCalculationAggregateArgs>): Prisma.PrismaPromise<GetZakatCalculationAggregateType<T>>

    /**
     * Group by ZakatCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatCalculationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZakatCalculationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZakatCalculationGroupByArgs['orderBy'] }
        : { orderBy?: ZakatCalculationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZakatCalculationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZakatCalculationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZakatCalculation model
   */
  readonly fields: ZakatCalculationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZakatCalculation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZakatCalculationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assetBreakdown<T extends ZakatCalculation$assetBreakdownArgs<ExtArgs> = {}>(args?: Subset<T, ZakatCalculation$assetBreakdownArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zakatPayments<T extends ZakatCalculation$zakatPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, ZakatCalculation$zakatPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZakatCalculation model
   */
  interface ZakatCalculationFieldRefs {
    readonly id: FieldRef<"ZakatCalculation", 'String'>
    readonly householdId: FieldRef<"ZakatCalculation", 'String'>
    readonly calculationDate: FieldRef<"ZakatCalculation", 'DateTime'>
    readonly hijriYear: FieldRef<"ZakatCalculation", 'Int'>
    readonly nisabThresholdCents: FieldRef<"ZakatCalculation", 'BigInt'>
    readonly totalZakatableAssetsCents: FieldRef<"ZakatCalculation", 'BigInt'>
    readonly zakatAmountCents: FieldRef<"ZakatCalculation", 'BigInt'>
    readonly currency: FieldRef<"ZakatCalculation", 'String'>
    readonly isZakatDue: FieldRef<"ZakatCalculation", 'Boolean'>
    readonly nextCalculationDate: FieldRef<"ZakatCalculation", 'DateTime'>
    readonly metadata: FieldRef<"ZakatCalculation", 'Json'>
    readonly createdAt: FieldRef<"ZakatCalculation", 'DateTime'>
    readonly updatedAt: FieldRef<"ZakatCalculation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZakatCalculation findUnique
   */
  export type ZakatCalculationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * Filter, which ZakatCalculation to fetch.
     */
    where: ZakatCalculationWhereUniqueInput
  }

  /**
   * ZakatCalculation findUniqueOrThrow
   */
  export type ZakatCalculationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * Filter, which ZakatCalculation to fetch.
     */
    where: ZakatCalculationWhereUniqueInput
  }

  /**
   * ZakatCalculation findFirst
   */
  export type ZakatCalculationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * Filter, which ZakatCalculation to fetch.
     */
    where?: ZakatCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatCalculations to fetch.
     */
    orderBy?: ZakatCalculationOrderByWithRelationInput | ZakatCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZakatCalculations.
     */
    cursor?: ZakatCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZakatCalculations.
     */
    distinct?: ZakatCalculationScalarFieldEnum | ZakatCalculationScalarFieldEnum[]
  }

  /**
   * ZakatCalculation findFirstOrThrow
   */
  export type ZakatCalculationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * Filter, which ZakatCalculation to fetch.
     */
    where?: ZakatCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatCalculations to fetch.
     */
    orderBy?: ZakatCalculationOrderByWithRelationInput | ZakatCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZakatCalculations.
     */
    cursor?: ZakatCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZakatCalculations.
     */
    distinct?: ZakatCalculationScalarFieldEnum | ZakatCalculationScalarFieldEnum[]
  }

  /**
   * ZakatCalculation findMany
   */
  export type ZakatCalculationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * Filter, which ZakatCalculations to fetch.
     */
    where?: ZakatCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatCalculations to fetch.
     */
    orderBy?: ZakatCalculationOrderByWithRelationInput | ZakatCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZakatCalculations.
     */
    cursor?: ZakatCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatCalculations.
     */
    skip?: number
    distinct?: ZakatCalculationScalarFieldEnum | ZakatCalculationScalarFieldEnum[]
  }

  /**
   * ZakatCalculation create
   */
  export type ZakatCalculationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * The data needed to create a ZakatCalculation.
     */
    data: XOR<ZakatCalculationCreateInput, ZakatCalculationUncheckedCreateInput>
  }

  /**
   * ZakatCalculation createMany
   */
  export type ZakatCalculationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZakatCalculations.
     */
    data: ZakatCalculationCreateManyInput | ZakatCalculationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZakatCalculation createManyAndReturn
   */
  export type ZakatCalculationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * The data used to create many ZakatCalculations.
     */
    data: ZakatCalculationCreateManyInput | ZakatCalculationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZakatCalculation update
   */
  export type ZakatCalculationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * The data needed to update a ZakatCalculation.
     */
    data: XOR<ZakatCalculationUpdateInput, ZakatCalculationUncheckedUpdateInput>
    /**
     * Choose, which ZakatCalculation to update.
     */
    where: ZakatCalculationWhereUniqueInput
  }

  /**
   * ZakatCalculation updateMany
   */
  export type ZakatCalculationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZakatCalculations.
     */
    data: XOR<ZakatCalculationUpdateManyMutationInput, ZakatCalculationUncheckedUpdateManyInput>
    /**
     * Filter which ZakatCalculations to update
     */
    where?: ZakatCalculationWhereInput
    /**
     * Limit how many ZakatCalculations to update.
     */
    limit?: number
  }

  /**
   * ZakatCalculation updateManyAndReturn
   */
  export type ZakatCalculationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * The data used to update ZakatCalculations.
     */
    data: XOR<ZakatCalculationUpdateManyMutationInput, ZakatCalculationUncheckedUpdateManyInput>
    /**
     * Filter which ZakatCalculations to update
     */
    where?: ZakatCalculationWhereInput
    /**
     * Limit how many ZakatCalculations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZakatCalculation upsert
   */
  export type ZakatCalculationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * The filter to search for the ZakatCalculation to update in case it exists.
     */
    where: ZakatCalculationWhereUniqueInput
    /**
     * In case the ZakatCalculation found by the `where` argument doesn't exist, create a new ZakatCalculation with this data.
     */
    create: XOR<ZakatCalculationCreateInput, ZakatCalculationUncheckedCreateInput>
    /**
     * In case the ZakatCalculation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZakatCalculationUpdateInput, ZakatCalculationUncheckedUpdateInput>
  }

  /**
   * ZakatCalculation delete
   */
  export type ZakatCalculationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    /**
     * Filter which ZakatCalculation to delete.
     */
    where: ZakatCalculationWhereUniqueInput
  }

  /**
   * ZakatCalculation deleteMany
   */
  export type ZakatCalculationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZakatCalculations to delete
     */
    where?: ZakatCalculationWhereInput
    /**
     * Limit how many ZakatCalculations to delete.
     */
    limit?: number
  }

  /**
   * ZakatCalculation.assetBreakdown
   */
  export type ZakatCalculation$assetBreakdownArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    where?: ZakatAssetBreakdownWhereInput
    orderBy?: ZakatAssetBreakdownOrderByWithRelationInput | ZakatAssetBreakdownOrderByWithRelationInput[]
    cursor?: ZakatAssetBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZakatAssetBreakdownScalarFieldEnum | ZakatAssetBreakdownScalarFieldEnum[]
  }

  /**
   * ZakatCalculation.zakatPayments
   */
  export type ZakatCalculation$zakatPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    where?: ZakatPaymentWhereInput
    orderBy?: ZakatPaymentOrderByWithRelationInput | ZakatPaymentOrderByWithRelationInput[]
    cursor?: ZakatPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZakatPaymentScalarFieldEnum | ZakatPaymentScalarFieldEnum[]
  }

  /**
   * ZakatCalculation without action
   */
  export type ZakatCalculationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
  }


  /**
   * Model ZakatAssetBreakdown
   */

  export type AggregateZakatAssetBreakdown = {
    _count: ZakatAssetBreakdownCountAggregateOutputType | null
    _avg: ZakatAssetBreakdownAvgAggregateOutputType | null
    _sum: ZakatAssetBreakdownSumAggregateOutputType | null
    _min: ZakatAssetBreakdownMinAggregateOutputType | null
    _max: ZakatAssetBreakdownMaxAggregateOutputType | null
  }

  export type ZakatAssetBreakdownAvgAggregateOutputType = {
    amountCents: number | null
    zakatRate: Decimal | null
    zakatAmountCents: number | null
  }

  export type ZakatAssetBreakdownSumAggregateOutputType = {
    amountCents: bigint | null
    zakatRate: Decimal | null
    zakatAmountCents: bigint | null
  }

  export type ZakatAssetBreakdownMinAggregateOutputType = {
    id: string | null
    zakatCalculationId: string | null
    assetType: $Enums.ZakatAssetType | null
    accountId: string | null
    accountName: string | null
    amountCents: bigint | null
    currency: string | null
    zakatRate: Decimal | null
    zakatAmountCents: bigint | null
    haulCompleted: boolean | null
    haulStartDate: Date | null
    createdAt: Date | null
  }

  export type ZakatAssetBreakdownMaxAggregateOutputType = {
    id: string | null
    zakatCalculationId: string | null
    assetType: $Enums.ZakatAssetType | null
    accountId: string | null
    accountName: string | null
    amountCents: bigint | null
    currency: string | null
    zakatRate: Decimal | null
    zakatAmountCents: bigint | null
    haulCompleted: boolean | null
    haulStartDate: Date | null
    createdAt: Date | null
  }

  export type ZakatAssetBreakdownCountAggregateOutputType = {
    id: number
    zakatCalculationId: number
    assetType: number
    accountId: number
    accountName: number
    amountCents: number
    currency: number
    zakatRate: number
    zakatAmountCents: number
    haulCompleted: number
    haulStartDate: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ZakatAssetBreakdownAvgAggregateInputType = {
    amountCents?: true
    zakatRate?: true
    zakatAmountCents?: true
  }

  export type ZakatAssetBreakdownSumAggregateInputType = {
    amountCents?: true
    zakatRate?: true
    zakatAmountCents?: true
  }

  export type ZakatAssetBreakdownMinAggregateInputType = {
    id?: true
    zakatCalculationId?: true
    assetType?: true
    accountId?: true
    accountName?: true
    amountCents?: true
    currency?: true
    zakatRate?: true
    zakatAmountCents?: true
    haulCompleted?: true
    haulStartDate?: true
    createdAt?: true
  }

  export type ZakatAssetBreakdownMaxAggregateInputType = {
    id?: true
    zakatCalculationId?: true
    assetType?: true
    accountId?: true
    accountName?: true
    amountCents?: true
    currency?: true
    zakatRate?: true
    zakatAmountCents?: true
    haulCompleted?: true
    haulStartDate?: true
    createdAt?: true
  }

  export type ZakatAssetBreakdownCountAggregateInputType = {
    id?: true
    zakatCalculationId?: true
    assetType?: true
    accountId?: true
    accountName?: true
    amountCents?: true
    currency?: true
    zakatRate?: true
    zakatAmountCents?: true
    haulCompleted?: true
    haulStartDate?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ZakatAssetBreakdownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZakatAssetBreakdown to aggregate.
     */
    where?: ZakatAssetBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatAssetBreakdowns to fetch.
     */
    orderBy?: ZakatAssetBreakdownOrderByWithRelationInput | ZakatAssetBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZakatAssetBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatAssetBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatAssetBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZakatAssetBreakdowns
    **/
    _count?: true | ZakatAssetBreakdownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZakatAssetBreakdownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZakatAssetBreakdownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZakatAssetBreakdownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZakatAssetBreakdownMaxAggregateInputType
  }

  export type GetZakatAssetBreakdownAggregateType<T extends ZakatAssetBreakdownAggregateArgs> = {
        [P in keyof T & keyof AggregateZakatAssetBreakdown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZakatAssetBreakdown[P]>
      : GetScalarType<T[P], AggregateZakatAssetBreakdown[P]>
  }




  export type ZakatAssetBreakdownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatAssetBreakdownWhereInput
    orderBy?: ZakatAssetBreakdownOrderByWithAggregationInput | ZakatAssetBreakdownOrderByWithAggregationInput[]
    by: ZakatAssetBreakdownScalarFieldEnum[] | ZakatAssetBreakdownScalarFieldEnum
    having?: ZakatAssetBreakdownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZakatAssetBreakdownCountAggregateInputType | true
    _avg?: ZakatAssetBreakdownAvgAggregateInputType
    _sum?: ZakatAssetBreakdownSumAggregateInputType
    _min?: ZakatAssetBreakdownMinAggregateInputType
    _max?: ZakatAssetBreakdownMaxAggregateInputType
  }

  export type ZakatAssetBreakdownGroupByOutputType = {
    id: string
    zakatCalculationId: string
    assetType: $Enums.ZakatAssetType
    accountId: string | null
    accountName: string | null
    amountCents: bigint
    currency: string
    zakatRate: Decimal
    zakatAmountCents: bigint
    haulCompleted: boolean
    haulStartDate: Date | null
    metadata: JsonValue
    createdAt: Date
    _count: ZakatAssetBreakdownCountAggregateOutputType | null
    _avg: ZakatAssetBreakdownAvgAggregateOutputType | null
    _sum: ZakatAssetBreakdownSumAggregateOutputType | null
    _min: ZakatAssetBreakdownMinAggregateOutputType | null
    _max: ZakatAssetBreakdownMaxAggregateOutputType | null
  }

  type GetZakatAssetBreakdownGroupByPayload<T extends ZakatAssetBreakdownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZakatAssetBreakdownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZakatAssetBreakdownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZakatAssetBreakdownGroupByOutputType[P]>
            : GetScalarType<T[P], ZakatAssetBreakdownGroupByOutputType[P]>
        }
      >
    >


  export type ZakatAssetBreakdownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zakatCalculationId?: boolean
    assetType?: boolean
    accountId?: boolean
    accountName?: boolean
    amountCents?: boolean
    currency?: boolean
    zakatRate?: boolean
    zakatAmountCents?: boolean
    haulCompleted?: boolean
    haulStartDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    zakatCalculation?: boolean | ZakatCalculationDefaultArgs<ExtArgs>
    account?: boolean | ZakatAssetBreakdown$accountArgs<ExtArgs>
  }, ExtArgs["result"]["zakatAssetBreakdown"]>

  export type ZakatAssetBreakdownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zakatCalculationId?: boolean
    assetType?: boolean
    accountId?: boolean
    accountName?: boolean
    amountCents?: boolean
    currency?: boolean
    zakatRate?: boolean
    zakatAmountCents?: boolean
    haulCompleted?: boolean
    haulStartDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    zakatCalculation?: boolean | ZakatCalculationDefaultArgs<ExtArgs>
    account?: boolean | ZakatAssetBreakdown$accountArgs<ExtArgs>
  }, ExtArgs["result"]["zakatAssetBreakdown"]>

  export type ZakatAssetBreakdownSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zakatCalculationId?: boolean
    assetType?: boolean
    accountId?: boolean
    accountName?: boolean
    amountCents?: boolean
    currency?: boolean
    zakatRate?: boolean
    zakatAmountCents?: boolean
    haulCompleted?: boolean
    haulStartDate?: boolean
    metadata?: boolean
    createdAt?: boolean
    zakatCalculation?: boolean | ZakatCalculationDefaultArgs<ExtArgs>
    account?: boolean | ZakatAssetBreakdown$accountArgs<ExtArgs>
  }, ExtArgs["result"]["zakatAssetBreakdown"]>

  export type ZakatAssetBreakdownSelectScalar = {
    id?: boolean
    zakatCalculationId?: boolean
    assetType?: boolean
    accountId?: boolean
    accountName?: boolean
    amountCents?: boolean
    currency?: boolean
    zakatRate?: boolean
    zakatAmountCents?: boolean
    haulCompleted?: boolean
    haulStartDate?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ZakatAssetBreakdownOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zakatCalculationId" | "assetType" | "accountId" | "accountName" | "amountCents" | "currency" | "zakatRate" | "zakatAmountCents" | "haulCompleted" | "haulStartDate" | "metadata" | "createdAt", ExtArgs["result"]["zakatAssetBreakdown"]>
  export type ZakatAssetBreakdownInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zakatCalculation?: boolean | ZakatCalculationDefaultArgs<ExtArgs>
    account?: boolean | ZakatAssetBreakdown$accountArgs<ExtArgs>
  }
  export type ZakatAssetBreakdownIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zakatCalculation?: boolean | ZakatCalculationDefaultArgs<ExtArgs>
    account?: boolean | ZakatAssetBreakdown$accountArgs<ExtArgs>
  }
  export type ZakatAssetBreakdownIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zakatCalculation?: boolean | ZakatCalculationDefaultArgs<ExtArgs>
    account?: boolean | ZakatAssetBreakdown$accountArgs<ExtArgs>
  }

  export type $ZakatAssetBreakdownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZakatAssetBreakdown"
    objects: {
      zakatCalculation: Prisma.$ZakatCalculationPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zakatCalculationId: string
      assetType: $Enums.ZakatAssetType
      accountId: string | null
      accountName: string | null
      amountCents: bigint
      currency: string
      zakatRate: Prisma.Decimal
      zakatAmountCents: bigint
      haulCompleted: boolean
      haulStartDate: Date | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["zakatAssetBreakdown"]>
    composites: {}
  }

  type ZakatAssetBreakdownGetPayload<S extends boolean | null | undefined | ZakatAssetBreakdownDefaultArgs> = $Result.GetResult<Prisma.$ZakatAssetBreakdownPayload, S>

  type ZakatAssetBreakdownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZakatAssetBreakdownFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZakatAssetBreakdownCountAggregateInputType | true
    }

  export interface ZakatAssetBreakdownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZakatAssetBreakdown'], meta: { name: 'ZakatAssetBreakdown' } }
    /**
     * Find zero or one ZakatAssetBreakdown that matches the filter.
     * @param {ZakatAssetBreakdownFindUniqueArgs} args - Arguments to find a ZakatAssetBreakdown
     * @example
     * // Get one ZakatAssetBreakdown
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZakatAssetBreakdownFindUniqueArgs>(args: SelectSubset<T, ZakatAssetBreakdownFindUniqueArgs<ExtArgs>>): Prisma__ZakatAssetBreakdownClient<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZakatAssetBreakdown that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZakatAssetBreakdownFindUniqueOrThrowArgs} args - Arguments to find a ZakatAssetBreakdown
     * @example
     * // Get one ZakatAssetBreakdown
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZakatAssetBreakdownFindUniqueOrThrowArgs>(args: SelectSubset<T, ZakatAssetBreakdownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZakatAssetBreakdownClient<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZakatAssetBreakdown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatAssetBreakdownFindFirstArgs} args - Arguments to find a ZakatAssetBreakdown
     * @example
     * // Get one ZakatAssetBreakdown
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZakatAssetBreakdownFindFirstArgs>(args?: SelectSubset<T, ZakatAssetBreakdownFindFirstArgs<ExtArgs>>): Prisma__ZakatAssetBreakdownClient<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZakatAssetBreakdown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatAssetBreakdownFindFirstOrThrowArgs} args - Arguments to find a ZakatAssetBreakdown
     * @example
     * // Get one ZakatAssetBreakdown
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZakatAssetBreakdownFindFirstOrThrowArgs>(args?: SelectSubset<T, ZakatAssetBreakdownFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZakatAssetBreakdownClient<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZakatAssetBreakdowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatAssetBreakdownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZakatAssetBreakdowns
     * const zakatAssetBreakdowns = await prisma.zakatAssetBreakdown.findMany()
     * 
     * // Get first 10 ZakatAssetBreakdowns
     * const zakatAssetBreakdowns = await prisma.zakatAssetBreakdown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zakatAssetBreakdownWithIdOnly = await prisma.zakatAssetBreakdown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZakatAssetBreakdownFindManyArgs>(args?: SelectSubset<T, ZakatAssetBreakdownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZakatAssetBreakdown.
     * @param {ZakatAssetBreakdownCreateArgs} args - Arguments to create a ZakatAssetBreakdown.
     * @example
     * // Create one ZakatAssetBreakdown
     * const ZakatAssetBreakdown = await prisma.zakatAssetBreakdown.create({
     *   data: {
     *     // ... data to create a ZakatAssetBreakdown
     *   }
     * })
     * 
     */
    create<T extends ZakatAssetBreakdownCreateArgs>(args: SelectSubset<T, ZakatAssetBreakdownCreateArgs<ExtArgs>>): Prisma__ZakatAssetBreakdownClient<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZakatAssetBreakdowns.
     * @param {ZakatAssetBreakdownCreateManyArgs} args - Arguments to create many ZakatAssetBreakdowns.
     * @example
     * // Create many ZakatAssetBreakdowns
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZakatAssetBreakdownCreateManyArgs>(args?: SelectSubset<T, ZakatAssetBreakdownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZakatAssetBreakdowns and returns the data saved in the database.
     * @param {ZakatAssetBreakdownCreateManyAndReturnArgs} args - Arguments to create many ZakatAssetBreakdowns.
     * @example
     * // Create many ZakatAssetBreakdowns
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZakatAssetBreakdowns and only return the `id`
     * const zakatAssetBreakdownWithIdOnly = await prisma.zakatAssetBreakdown.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZakatAssetBreakdownCreateManyAndReturnArgs>(args?: SelectSubset<T, ZakatAssetBreakdownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZakatAssetBreakdown.
     * @param {ZakatAssetBreakdownDeleteArgs} args - Arguments to delete one ZakatAssetBreakdown.
     * @example
     * // Delete one ZakatAssetBreakdown
     * const ZakatAssetBreakdown = await prisma.zakatAssetBreakdown.delete({
     *   where: {
     *     // ... filter to delete one ZakatAssetBreakdown
     *   }
     * })
     * 
     */
    delete<T extends ZakatAssetBreakdownDeleteArgs>(args: SelectSubset<T, ZakatAssetBreakdownDeleteArgs<ExtArgs>>): Prisma__ZakatAssetBreakdownClient<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZakatAssetBreakdown.
     * @param {ZakatAssetBreakdownUpdateArgs} args - Arguments to update one ZakatAssetBreakdown.
     * @example
     * // Update one ZakatAssetBreakdown
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZakatAssetBreakdownUpdateArgs>(args: SelectSubset<T, ZakatAssetBreakdownUpdateArgs<ExtArgs>>): Prisma__ZakatAssetBreakdownClient<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZakatAssetBreakdowns.
     * @param {ZakatAssetBreakdownDeleteManyArgs} args - Arguments to filter ZakatAssetBreakdowns to delete.
     * @example
     * // Delete a few ZakatAssetBreakdowns
     * const { count } = await prisma.zakatAssetBreakdown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZakatAssetBreakdownDeleteManyArgs>(args?: SelectSubset<T, ZakatAssetBreakdownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZakatAssetBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatAssetBreakdownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZakatAssetBreakdowns
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZakatAssetBreakdownUpdateManyArgs>(args: SelectSubset<T, ZakatAssetBreakdownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZakatAssetBreakdowns and returns the data updated in the database.
     * @param {ZakatAssetBreakdownUpdateManyAndReturnArgs} args - Arguments to update many ZakatAssetBreakdowns.
     * @example
     * // Update many ZakatAssetBreakdowns
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZakatAssetBreakdowns and only return the `id`
     * const zakatAssetBreakdownWithIdOnly = await prisma.zakatAssetBreakdown.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZakatAssetBreakdownUpdateManyAndReturnArgs>(args: SelectSubset<T, ZakatAssetBreakdownUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZakatAssetBreakdown.
     * @param {ZakatAssetBreakdownUpsertArgs} args - Arguments to update or create a ZakatAssetBreakdown.
     * @example
     * // Update or create a ZakatAssetBreakdown
     * const zakatAssetBreakdown = await prisma.zakatAssetBreakdown.upsert({
     *   create: {
     *     // ... data to create a ZakatAssetBreakdown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZakatAssetBreakdown we want to update
     *   }
     * })
     */
    upsert<T extends ZakatAssetBreakdownUpsertArgs>(args: SelectSubset<T, ZakatAssetBreakdownUpsertArgs<ExtArgs>>): Prisma__ZakatAssetBreakdownClient<$Result.GetResult<Prisma.$ZakatAssetBreakdownPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZakatAssetBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatAssetBreakdownCountArgs} args - Arguments to filter ZakatAssetBreakdowns to count.
     * @example
     * // Count the number of ZakatAssetBreakdowns
     * const count = await prisma.zakatAssetBreakdown.count({
     *   where: {
     *     // ... the filter for the ZakatAssetBreakdowns we want to count
     *   }
     * })
    **/
    count<T extends ZakatAssetBreakdownCountArgs>(
      args?: Subset<T, ZakatAssetBreakdownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZakatAssetBreakdownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZakatAssetBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatAssetBreakdownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZakatAssetBreakdownAggregateArgs>(args: Subset<T, ZakatAssetBreakdownAggregateArgs>): Prisma.PrismaPromise<GetZakatAssetBreakdownAggregateType<T>>

    /**
     * Group by ZakatAssetBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatAssetBreakdownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZakatAssetBreakdownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZakatAssetBreakdownGroupByArgs['orderBy'] }
        : { orderBy?: ZakatAssetBreakdownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZakatAssetBreakdownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZakatAssetBreakdownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZakatAssetBreakdown model
   */
  readonly fields: ZakatAssetBreakdownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZakatAssetBreakdown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZakatAssetBreakdownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zakatCalculation<T extends ZakatCalculationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZakatCalculationDefaultArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends ZakatAssetBreakdown$accountArgs<ExtArgs> = {}>(args?: Subset<T, ZakatAssetBreakdown$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZakatAssetBreakdown model
   */
  interface ZakatAssetBreakdownFieldRefs {
    readonly id: FieldRef<"ZakatAssetBreakdown", 'String'>
    readonly zakatCalculationId: FieldRef<"ZakatAssetBreakdown", 'String'>
    readonly assetType: FieldRef<"ZakatAssetBreakdown", 'ZakatAssetType'>
    readonly accountId: FieldRef<"ZakatAssetBreakdown", 'String'>
    readonly accountName: FieldRef<"ZakatAssetBreakdown", 'String'>
    readonly amountCents: FieldRef<"ZakatAssetBreakdown", 'BigInt'>
    readonly currency: FieldRef<"ZakatAssetBreakdown", 'String'>
    readonly zakatRate: FieldRef<"ZakatAssetBreakdown", 'Decimal'>
    readonly zakatAmountCents: FieldRef<"ZakatAssetBreakdown", 'BigInt'>
    readonly haulCompleted: FieldRef<"ZakatAssetBreakdown", 'Boolean'>
    readonly haulStartDate: FieldRef<"ZakatAssetBreakdown", 'DateTime'>
    readonly metadata: FieldRef<"ZakatAssetBreakdown", 'Json'>
    readonly createdAt: FieldRef<"ZakatAssetBreakdown", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZakatAssetBreakdown findUnique
   */
  export type ZakatAssetBreakdownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which ZakatAssetBreakdown to fetch.
     */
    where: ZakatAssetBreakdownWhereUniqueInput
  }

  /**
   * ZakatAssetBreakdown findUniqueOrThrow
   */
  export type ZakatAssetBreakdownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which ZakatAssetBreakdown to fetch.
     */
    where: ZakatAssetBreakdownWhereUniqueInput
  }

  /**
   * ZakatAssetBreakdown findFirst
   */
  export type ZakatAssetBreakdownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which ZakatAssetBreakdown to fetch.
     */
    where?: ZakatAssetBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatAssetBreakdowns to fetch.
     */
    orderBy?: ZakatAssetBreakdownOrderByWithRelationInput | ZakatAssetBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZakatAssetBreakdowns.
     */
    cursor?: ZakatAssetBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatAssetBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatAssetBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZakatAssetBreakdowns.
     */
    distinct?: ZakatAssetBreakdownScalarFieldEnum | ZakatAssetBreakdownScalarFieldEnum[]
  }

  /**
   * ZakatAssetBreakdown findFirstOrThrow
   */
  export type ZakatAssetBreakdownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which ZakatAssetBreakdown to fetch.
     */
    where?: ZakatAssetBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatAssetBreakdowns to fetch.
     */
    orderBy?: ZakatAssetBreakdownOrderByWithRelationInput | ZakatAssetBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZakatAssetBreakdowns.
     */
    cursor?: ZakatAssetBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatAssetBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatAssetBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZakatAssetBreakdowns.
     */
    distinct?: ZakatAssetBreakdownScalarFieldEnum | ZakatAssetBreakdownScalarFieldEnum[]
  }

  /**
   * ZakatAssetBreakdown findMany
   */
  export type ZakatAssetBreakdownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which ZakatAssetBreakdowns to fetch.
     */
    where?: ZakatAssetBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatAssetBreakdowns to fetch.
     */
    orderBy?: ZakatAssetBreakdownOrderByWithRelationInput | ZakatAssetBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZakatAssetBreakdowns.
     */
    cursor?: ZakatAssetBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatAssetBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatAssetBreakdowns.
     */
    skip?: number
    distinct?: ZakatAssetBreakdownScalarFieldEnum | ZakatAssetBreakdownScalarFieldEnum[]
  }

  /**
   * ZakatAssetBreakdown create
   */
  export type ZakatAssetBreakdownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to create a ZakatAssetBreakdown.
     */
    data: XOR<ZakatAssetBreakdownCreateInput, ZakatAssetBreakdownUncheckedCreateInput>
  }

  /**
   * ZakatAssetBreakdown createMany
   */
  export type ZakatAssetBreakdownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZakatAssetBreakdowns.
     */
    data: ZakatAssetBreakdownCreateManyInput | ZakatAssetBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZakatAssetBreakdown createManyAndReturn
   */
  export type ZakatAssetBreakdownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * The data used to create many ZakatAssetBreakdowns.
     */
    data: ZakatAssetBreakdownCreateManyInput | ZakatAssetBreakdownCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZakatAssetBreakdown update
   */
  export type ZakatAssetBreakdownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to update a ZakatAssetBreakdown.
     */
    data: XOR<ZakatAssetBreakdownUpdateInput, ZakatAssetBreakdownUncheckedUpdateInput>
    /**
     * Choose, which ZakatAssetBreakdown to update.
     */
    where: ZakatAssetBreakdownWhereUniqueInput
  }

  /**
   * ZakatAssetBreakdown updateMany
   */
  export type ZakatAssetBreakdownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZakatAssetBreakdowns.
     */
    data: XOR<ZakatAssetBreakdownUpdateManyMutationInput, ZakatAssetBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which ZakatAssetBreakdowns to update
     */
    where?: ZakatAssetBreakdownWhereInput
    /**
     * Limit how many ZakatAssetBreakdowns to update.
     */
    limit?: number
  }

  /**
   * ZakatAssetBreakdown updateManyAndReturn
   */
  export type ZakatAssetBreakdownUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * The data used to update ZakatAssetBreakdowns.
     */
    data: XOR<ZakatAssetBreakdownUpdateManyMutationInput, ZakatAssetBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which ZakatAssetBreakdowns to update
     */
    where?: ZakatAssetBreakdownWhereInput
    /**
     * Limit how many ZakatAssetBreakdowns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZakatAssetBreakdown upsert
   */
  export type ZakatAssetBreakdownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * The filter to search for the ZakatAssetBreakdown to update in case it exists.
     */
    where: ZakatAssetBreakdownWhereUniqueInput
    /**
     * In case the ZakatAssetBreakdown found by the `where` argument doesn't exist, create a new ZakatAssetBreakdown with this data.
     */
    create: XOR<ZakatAssetBreakdownCreateInput, ZakatAssetBreakdownUncheckedCreateInput>
    /**
     * In case the ZakatAssetBreakdown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZakatAssetBreakdownUpdateInput, ZakatAssetBreakdownUncheckedUpdateInput>
  }

  /**
   * ZakatAssetBreakdown delete
   */
  export type ZakatAssetBreakdownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
    /**
     * Filter which ZakatAssetBreakdown to delete.
     */
    where: ZakatAssetBreakdownWhereUniqueInput
  }

  /**
   * ZakatAssetBreakdown deleteMany
   */
  export type ZakatAssetBreakdownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZakatAssetBreakdowns to delete
     */
    where?: ZakatAssetBreakdownWhereInput
    /**
     * Limit how many ZakatAssetBreakdowns to delete.
     */
    limit?: number
  }

  /**
   * ZakatAssetBreakdown.account
   */
  export type ZakatAssetBreakdown$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * ZakatAssetBreakdown without action
   */
  export type ZakatAssetBreakdownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatAssetBreakdown
     */
    select?: ZakatAssetBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatAssetBreakdown
     */
    omit?: ZakatAssetBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatAssetBreakdownInclude<ExtArgs> | null
  }


  /**
   * Model ZakatReminder
   */

  export type AggregateZakatReminder = {
    _count: ZakatReminderCountAggregateOutputType | null
    _avg: ZakatReminderAvgAggregateOutputType | null
    _sum: ZakatReminderSumAggregateOutputType | null
    _min: ZakatReminderMinAggregateOutputType | null
    _max: ZakatReminderMaxAggregateOutputType | null
  }

  export type ZakatReminderAvgAggregateOutputType = {
    zakatAmountCents: number | null
  }

  export type ZakatReminderSumAggregateOutputType = {
    zakatAmountCents: bigint | null
  }

  export type ZakatReminderMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    reminderType: $Enums.ZakatReminderType | null
    scheduledDate: Date | null
    hijriDate: string | null
    zakatAmountCents: bigint | null
    currency: string | null
    message: string | null
    isActive: boolean | null
    isSent: boolean | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZakatReminderMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    reminderType: $Enums.ZakatReminderType | null
    scheduledDate: Date | null
    hijriDate: string | null
    zakatAmountCents: bigint | null
    currency: string | null
    message: string | null
    isActive: boolean | null
    isSent: boolean | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZakatReminderCountAggregateOutputType = {
    id: number
    householdId: number
    reminderType: number
    scheduledDate: number
    hijriDate: number
    zakatAmountCents: number
    currency: number
    message: number
    isActive: number
    isSent: number
    sentAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZakatReminderAvgAggregateInputType = {
    zakatAmountCents?: true
  }

  export type ZakatReminderSumAggregateInputType = {
    zakatAmountCents?: true
  }

  export type ZakatReminderMinAggregateInputType = {
    id?: true
    householdId?: true
    reminderType?: true
    scheduledDate?: true
    hijriDate?: true
    zakatAmountCents?: true
    currency?: true
    message?: true
    isActive?: true
    isSent?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZakatReminderMaxAggregateInputType = {
    id?: true
    householdId?: true
    reminderType?: true
    scheduledDate?: true
    hijriDate?: true
    zakatAmountCents?: true
    currency?: true
    message?: true
    isActive?: true
    isSent?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZakatReminderCountAggregateInputType = {
    id?: true
    householdId?: true
    reminderType?: true
    scheduledDate?: true
    hijriDate?: true
    zakatAmountCents?: true
    currency?: true
    message?: true
    isActive?: true
    isSent?: true
    sentAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZakatReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZakatReminder to aggregate.
     */
    where?: ZakatReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatReminders to fetch.
     */
    orderBy?: ZakatReminderOrderByWithRelationInput | ZakatReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZakatReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZakatReminders
    **/
    _count?: true | ZakatReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZakatReminderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZakatReminderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZakatReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZakatReminderMaxAggregateInputType
  }

  export type GetZakatReminderAggregateType<T extends ZakatReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateZakatReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZakatReminder[P]>
      : GetScalarType<T[P], AggregateZakatReminder[P]>
  }




  export type ZakatReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatReminderWhereInput
    orderBy?: ZakatReminderOrderByWithAggregationInput | ZakatReminderOrderByWithAggregationInput[]
    by: ZakatReminderScalarFieldEnum[] | ZakatReminderScalarFieldEnum
    having?: ZakatReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZakatReminderCountAggregateInputType | true
    _avg?: ZakatReminderAvgAggregateInputType
    _sum?: ZakatReminderSumAggregateInputType
    _min?: ZakatReminderMinAggregateInputType
    _max?: ZakatReminderMaxAggregateInputType
  }

  export type ZakatReminderGroupByOutputType = {
    id: string
    householdId: string
    reminderType: $Enums.ZakatReminderType
    scheduledDate: Date
    hijriDate: string
    zakatAmountCents: bigint | null
    currency: string | null
    message: string
    isActive: boolean
    isSent: boolean
    sentAt: Date | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ZakatReminderCountAggregateOutputType | null
    _avg: ZakatReminderAvgAggregateOutputType | null
    _sum: ZakatReminderSumAggregateOutputType | null
    _min: ZakatReminderMinAggregateOutputType | null
    _max: ZakatReminderMaxAggregateOutputType | null
  }

  type GetZakatReminderGroupByPayload<T extends ZakatReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZakatReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZakatReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZakatReminderGroupByOutputType[P]>
            : GetScalarType<T[P], ZakatReminderGroupByOutputType[P]>
        }
      >
    >


  export type ZakatReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    reminderType?: boolean
    scheduledDate?: boolean
    hijriDate?: boolean
    zakatAmountCents?: boolean
    currency?: boolean
    message?: boolean
    isActive?: boolean
    isSent?: boolean
    sentAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zakatReminder"]>

  export type ZakatReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    reminderType?: boolean
    scheduledDate?: boolean
    hijriDate?: boolean
    zakatAmountCents?: boolean
    currency?: boolean
    message?: boolean
    isActive?: boolean
    isSent?: boolean
    sentAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zakatReminder"]>

  export type ZakatReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    reminderType?: boolean
    scheduledDate?: boolean
    hijriDate?: boolean
    zakatAmountCents?: boolean
    currency?: boolean
    message?: boolean
    isActive?: boolean
    isSent?: boolean
    sentAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zakatReminder"]>

  export type ZakatReminderSelectScalar = {
    id?: boolean
    householdId?: boolean
    reminderType?: boolean
    scheduledDate?: boolean
    hijriDate?: boolean
    zakatAmountCents?: boolean
    currency?: boolean
    message?: boolean
    isActive?: boolean
    isSent?: boolean
    sentAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZakatReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "reminderType" | "scheduledDate" | "hijriDate" | "zakatAmountCents" | "currency" | "message" | "isActive" | "isSent" | "sentAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["zakatReminder"]>
  export type ZakatReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type ZakatReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type ZakatReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $ZakatReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZakatReminder"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      reminderType: $Enums.ZakatReminderType
      scheduledDate: Date
      hijriDate: string
      zakatAmountCents: bigint | null
      currency: string | null
      message: string
      isActive: boolean
      isSent: boolean
      sentAt: Date | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zakatReminder"]>
    composites: {}
  }

  type ZakatReminderGetPayload<S extends boolean | null | undefined | ZakatReminderDefaultArgs> = $Result.GetResult<Prisma.$ZakatReminderPayload, S>

  type ZakatReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZakatReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZakatReminderCountAggregateInputType | true
    }

  export interface ZakatReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZakatReminder'], meta: { name: 'ZakatReminder' } }
    /**
     * Find zero or one ZakatReminder that matches the filter.
     * @param {ZakatReminderFindUniqueArgs} args - Arguments to find a ZakatReminder
     * @example
     * // Get one ZakatReminder
     * const zakatReminder = await prisma.zakatReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZakatReminderFindUniqueArgs>(args: SelectSubset<T, ZakatReminderFindUniqueArgs<ExtArgs>>): Prisma__ZakatReminderClient<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZakatReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZakatReminderFindUniqueOrThrowArgs} args - Arguments to find a ZakatReminder
     * @example
     * // Get one ZakatReminder
     * const zakatReminder = await prisma.zakatReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZakatReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, ZakatReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZakatReminderClient<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZakatReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatReminderFindFirstArgs} args - Arguments to find a ZakatReminder
     * @example
     * // Get one ZakatReminder
     * const zakatReminder = await prisma.zakatReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZakatReminderFindFirstArgs>(args?: SelectSubset<T, ZakatReminderFindFirstArgs<ExtArgs>>): Prisma__ZakatReminderClient<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZakatReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatReminderFindFirstOrThrowArgs} args - Arguments to find a ZakatReminder
     * @example
     * // Get one ZakatReminder
     * const zakatReminder = await prisma.zakatReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZakatReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, ZakatReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZakatReminderClient<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZakatReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZakatReminders
     * const zakatReminders = await prisma.zakatReminder.findMany()
     * 
     * // Get first 10 ZakatReminders
     * const zakatReminders = await prisma.zakatReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zakatReminderWithIdOnly = await prisma.zakatReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZakatReminderFindManyArgs>(args?: SelectSubset<T, ZakatReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZakatReminder.
     * @param {ZakatReminderCreateArgs} args - Arguments to create a ZakatReminder.
     * @example
     * // Create one ZakatReminder
     * const ZakatReminder = await prisma.zakatReminder.create({
     *   data: {
     *     // ... data to create a ZakatReminder
     *   }
     * })
     * 
     */
    create<T extends ZakatReminderCreateArgs>(args: SelectSubset<T, ZakatReminderCreateArgs<ExtArgs>>): Prisma__ZakatReminderClient<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZakatReminders.
     * @param {ZakatReminderCreateManyArgs} args - Arguments to create many ZakatReminders.
     * @example
     * // Create many ZakatReminders
     * const zakatReminder = await prisma.zakatReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZakatReminderCreateManyArgs>(args?: SelectSubset<T, ZakatReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZakatReminders and returns the data saved in the database.
     * @param {ZakatReminderCreateManyAndReturnArgs} args - Arguments to create many ZakatReminders.
     * @example
     * // Create many ZakatReminders
     * const zakatReminder = await prisma.zakatReminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZakatReminders and only return the `id`
     * const zakatReminderWithIdOnly = await prisma.zakatReminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZakatReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, ZakatReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZakatReminder.
     * @param {ZakatReminderDeleteArgs} args - Arguments to delete one ZakatReminder.
     * @example
     * // Delete one ZakatReminder
     * const ZakatReminder = await prisma.zakatReminder.delete({
     *   where: {
     *     // ... filter to delete one ZakatReminder
     *   }
     * })
     * 
     */
    delete<T extends ZakatReminderDeleteArgs>(args: SelectSubset<T, ZakatReminderDeleteArgs<ExtArgs>>): Prisma__ZakatReminderClient<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZakatReminder.
     * @param {ZakatReminderUpdateArgs} args - Arguments to update one ZakatReminder.
     * @example
     * // Update one ZakatReminder
     * const zakatReminder = await prisma.zakatReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZakatReminderUpdateArgs>(args: SelectSubset<T, ZakatReminderUpdateArgs<ExtArgs>>): Prisma__ZakatReminderClient<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZakatReminders.
     * @param {ZakatReminderDeleteManyArgs} args - Arguments to filter ZakatReminders to delete.
     * @example
     * // Delete a few ZakatReminders
     * const { count } = await prisma.zakatReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZakatReminderDeleteManyArgs>(args?: SelectSubset<T, ZakatReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZakatReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZakatReminders
     * const zakatReminder = await prisma.zakatReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZakatReminderUpdateManyArgs>(args: SelectSubset<T, ZakatReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZakatReminders and returns the data updated in the database.
     * @param {ZakatReminderUpdateManyAndReturnArgs} args - Arguments to update many ZakatReminders.
     * @example
     * // Update many ZakatReminders
     * const zakatReminder = await prisma.zakatReminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZakatReminders and only return the `id`
     * const zakatReminderWithIdOnly = await prisma.zakatReminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZakatReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, ZakatReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZakatReminder.
     * @param {ZakatReminderUpsertArgs} args - Arguments to update or create a ZakatReminder.
     * @example
     * // Update or create a ZakatReminder
     * const zakatReminder = await prisma.zakatReminder.upsert({
     *   create: {
     *     // ... data to create a ZakatReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZakatReminder we want to update
     *   }
     * })
     */
    upsert<T extends ZakatReminderUpsertArgs>(args: SelectSubset<T, ZakatReminderUpsertArgs<ExtArgs>>): Prisma__ZakatReminderClient<$Result.GetResult<Prisma.$ZakatReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZakatReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatReminderCountArgs} args - Arguments to filter ZakatReminders to count.
     * @example
     * // Count the number of ZakatReminders
     * const count = await prisma.zakatReminder.count({
     *   where: {
     *     // ... the filter for the ZakatReminders we want to count
     *   }
     * })
    **/
    count<T extends ZakatReminderCountArgs>(
      args?: Subset<T, ZakatReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZakatReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZakatReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZakatReminderAggregateArgs>(args: Subset<T, ZakatReminderAggregateArgs>): Prisma.PrismaPromise<GetZakatReminderAggregateType<T>>

    /**
     * Group by ZakatReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZakatReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZakatReminderGroupByArgs['orderBy'] }
        : { orderBy?: ZakatReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZakatReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZakatReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZakatReminder model
   */
  readonly fields: ZakatReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZakatReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZakatReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZakatReminder model
   */
  interface ZakatReminderFieldRefs {
    readonly id: FieldRef<"ZakatReminder", 'String'>
    readonly householdId: FieldRef<"ZakatReminder", 'String'>
    readonly reminderType: FieldRef<"ZakatReminder", 'ZakatReminderType'>
    readonly scheduledDate: FieldRef<"ZakatReminder", 'DateTime'>
    readonly hijriDate: FieldRef<"ZakatReminder", 'String'>
    readonly zakatAmountCents: FieldRef<"ZakatReminder", 'BigInt'>
    readonly currency: FieldRef<"ZakatReminder", 'String'>
    readonly message: FieldRef<"ZakatReminder", 'String'>
    readonly isActive: FieldRef<"ZakatReminder", 'Boolean'>
    readonly isSent: FieldRef<"ZakatReminder", 'Boolean'>
    readonly sentAt: FieldRef<"ZakatReminder", 'DateTime'>
    readonly metadata: FieldRef<"ZakatReminder", 'Json'>
    readonly createdAt: FieldRef<"ZakatReminder", 'DateTime'>
    readonly updatedAt: FieldRef<"ZakatReminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZakatReminder findUnique
   */
  export type ZakatReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * Filter, which ZakatReminder to fetch.
     */
    where: ZakatReminderWhereUniqueInput
  }

  /**
   * ZakatReminder findUniqueOrThrow
   */
  export type ZakatReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * Filter, which ZakatReminder to fetch.
     */
    where: ZakatReminderWhereUniqueInput
  }

  /**
   * ZakatReminder findFirst
   */
  export type ZakatReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * Filter, which ZakatReminder to fetch.
     */
    where?: ZakatReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatReminders to fetch.
     */
    orderBy?: ZakatReminderOrderByWithRelationInput | ZakatReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZakatReminders.
     */
    cursor?: ZakatReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZakatReminders.
     */
    distinct?: ZakatReminderScalarFieldEnum | ZakatReminderScalarFieldEnum[]
  }

  /**
   * ZakatReminder findFirstOrThrow
   */
  export type ZakatReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * Filter, which ZakatReminder to fetch.
     */
    where?: ZakatReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatReminders to fetch.
     */
    orderBy?: ZakatReminderOrderByWithRelationInput | ZakatReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZakatReminders.
     */
    cursor?: ZakatReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZakatReminders.
     */
    distinct?: ZakatReminderScalarFieldEnum | ZakatReminderScalarFieldEnum[]
  }

  /**
   * ZakatReminder findMany
   */
  export type ZakatReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * Filter, which ZakatReminders to fetch.
     */
    where?: ZakatReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatReminders to fetch.
     */
    orderBy?: ZakatReminderOrderByWithRelationInput | ZakatReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZakatReminders.
     */
    cursor?: ZakatReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatReminders.
     */
    skip?: number
    distinct?: ZakatReminderScalarFieldEnum | ZakatReminderScalarFieldEnum[]
  }

  /**
   * ZakatReminder create
   */
  export type ZakatReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a ZakatReminder.
     */
    data: XOR<ZakatReminderCreateInput, ZakatReminderUncheckedCreateInput>
  }

  /**
   * ZakatReminder createMany
   */
  export type ZakatReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZakatReminders.
     */
    data: ZakatReminderCreateManyInput | ZakatReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZakatReminder createManyAndReturn
   */
  export type ZakatReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * The data used to create many ZakatReminders.
     */
    data: ZakatReminderCreateManyInput | ZakatReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZakatReminder update
   */
  export type ZakatReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a ZakatReminder.
     */
    data: XOR<ZakatReminderUpdateInput, ZakatReminderUncheckedUpdateInput>
    /**
     * Choose, which ZakatReminder to update.
     */
    where: ZakatReminderWhereUniqueInput
  }

  /**
   * ZakatReminder updateMany
   */
  export type ZakatReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZakatReminders.
     */
    data: XOR<ZakatReminderUpdateManyMutationInput, ZakatReminderUncheckedUpdateManyInput>
    /**
     * Filter which ZakatReminders to update
     */
    where?: ZakatReminderWhereInput
    /**
     * Limit how many ZakatReminders to update.
     */
    limit?: number
  }

  /**
   * ZakatReminder updateManyAndReturn
   */
  export type ZakatReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * The data used to update ZakatReminders.
     */
    data: XOR<ZakatReminderUpdateManyMutationInput, ZakatReminderUncheckedUpdateManyInput>
    /**
     * Filter which ZakatReminders to update
     */
    where?: ZakatReminderWhereInput
    /**
     * Limit how many ZakatReminders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZakatReminder upsert
   */
  export type ZakatReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the ZakatReminder to update in case it exists.
     */
    where: ZakatReminderWhereUniqueInput
    /**
     * In case the ZakatReminder found by the `where` argument doesn't exist, create a new ZakatReminder with this data.
     */
    create: XOR<ZakatReminderCreateInput, ZakatReminderUncheckedCreateInput>
    /**
     * In case the ZakatReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZakatReminderUpdateInput, ZakatReminderUncheckedUpdateInput>
  }

  /**
   * ZakatReminder delete
   */
  export type ZakatReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
    /**
     * Filter which ZakatReminder to delete.
     */
    where: ZakatReminderWhereUniqueInput
  }

  /**
   * ZakatReminder deleteMany
   */
  export type ZakatReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZakatReminders to delete
     */
    where?: ZakatReminderWhereInput
    /**
     * Limit how many ZakatReminders to delete.
     */
    limit?: number
  }

  /**
   * ZakatReminder without action
   */
  export type ZakatReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatReminder
     */
    select?: ZakatReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatReminder
     */
    omit?: ZakatReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatReminderInclude<ExtArgs> | null
  }


  /**
   * Model ZakatPayment
   */

  export type AggregateZakatPayment = {
    _count: ZakatPaymentCountAggregateOutputType | null
    _avg: ZakatPaymentAvgAggregateOutputType | null
    _sum: ZakatPaymentSumAggregateOutputType | null
    _min: ZakatPaymentMinAggregateOutputType | null
    _max: ZakatPaymentMaxAggregateOutputType | null
  }

  export type ZakatPaymentAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type ZakatPaymentSumAggregateOutputType = {
    amountCents: bigint | null
  }

  export type ZakatPaymentMinAggregateOutputType = {
    id: string | null
    zakatCalculationId: string | null
    householdId: string | null
    amountCents: bigint | null
    currency: string | null
    paymentDate: Date | null
    hijriDate: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ZakatPaymentMaxAggregateOutputType = {
    id: string | null
    zakatCalculationId: string | null
    householdId: string | null
    amountCents: bigint | null
    currency: string | null
    paymentDate: Date | null
    hijriDate: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ZakatPaymentCountAggregateOutputType = {
    id: number
    zakatCalculationId: number
    householdId: number
    amountCents: number
    currency: number
    paymentDate: number
    hijriDate: number
    transactionId: number
    notes: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ZakatPaymentAvgAggregateInputType = {
    amountCents?: true
  }

  export type ZakatPaymentSumAggregateInputType = {
    amountCents?: true
  }

  export type ZakatPaymentMinAggregateInputType = {
    id?: true
    zakatCalculationId?: true
    householdId?: true
    amountCents?: true
    currency?: true
    paymentDate?: true
    hijriDate?: true
    transactionId?: true
    notes?: true
    createdAt?: true
  }

  export type ZakatPaymentMaxAggregateInputType = {
    id?: true
    zakatCalculationId?: true
    householdId?: true
    amountCents?: true
    currency?: true
    paymentDate?: true
    hijriDate?: true
    transactionId?: true
    notes?: true
    createdAt?: true
  }

  export type ZakatPaymentCountAggregateInputType = {
    id?: true
    zakatCalculationId?: true
    householdId?: true
    amountCents?: true
    currency?: true
    paymentDate?: true
    hijriDate?: true
    transactionId?: true
    notes?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ZakatPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZakatPayment to aggregate.
     */
    where?: ZakatPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatPayments to fetch.
     */
    orderBy?: ZakatPaymentOrderByWithRelationInput | ZakatPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZakatPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZakatPayments
    **/
    _count?: true | ZakatPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZakatPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZakatPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZakatPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZakatPaymentMaxAggregateInputType
  }

  export type GetZakatPaymentAggregateType<T extends ZakatPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateZakatPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZakatPayment[P]>
      : GetScalarType<T[P], AggregateZakatPayment[P]>
  }




  export type ZakatPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZakatPaymentWhereInput
    orderBy?: ZakatPaymentOrderByWithAggregationInput | ZakatPaymentOrderByWithAggregationInput[]
    by: ZakatPaymentScalarFieldEnum[] | ZakatPaymentScalarFieldEnum
    having?: ZakatPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZakatPaymentCountAggregateInputType | true
    _avg?: ZakatPaymentAvgAggregateInputType
    _sum?: ZakatPaymentSumAggregateInputType
    _min?: ZakatPaymentMinAggregateInputType
    _max?: ZakatPaymentMaxAggregateInputType
  }

  export type ZakatPaymentGroupByOutputType = {
    id: string
    zakatCalculationId: string | null
    householdId: string
    amountCents: bigint
    currency: string
    paymentDate: Date
    hijriDate: string
    transactionId: string | null
    notes: string | null
    metadata: JsonValue
    createdAt: Date
    _count: ZakatPaymentCountAggregateOutputType | null
    _avg: ZakatPaymentAvgAggregateOutputType | null
    _sum: ZakatPaymentSumAggregateOutputType | null
    _min: ZakatPaymentMinAggregateOutputType | null
    _max: ZakatPaymentMaxAggregateOutputType | null
  }

  type GetZakatPaymentGroupByPayload<T extends ZakatPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZakatPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZakatPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZakatPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ZakatPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ZakatPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zakatCalculationId?: boolean
    householdId?: boolean
    amountCents?: boolean
    currency?: boolean
    paymentDate?: boolean
    hijriDate?: boolean
    transactionId?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    zakatCalculation?: boolean | ZakatPayment$zakatCalculationArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    transaction?: boolean | ZakatPayment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["zakatPayment"]>

  export type ZakatPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zakatCalculationId?: boolean
    householdId?: boolean
    amountCents?: boolean
    currency?: boolean
    paymentDate?: boolean
    hijriDate?: boolean
    transactionId?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    zakatCalculation?: boolean | ZakatPayment$zakatCalculationArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    transaction?: boolean | ZakatPayment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["zakatPayment"]>

  export type ZakatPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zakatCalculationId?: boolean
    householdId?: boolean
    amountCents?: boolean
    currency?: boolean
    paymentDate?: boolean
    hijriDate?: boolean
    transactionId?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    zakatCalculation?: boolean | ZakatPayment$zakatCalculationArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    transaction?: boolean | ZakatPayment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["zakatPayment"]>

  export type ZakatPaymentSelectScalar = {
    id?: boolean
    zakatCalculationId?: boolean
    householdId?: boolean
    amountCents?: boolean
    currency?: boolean
    paymentDate?: boolean
    hijriDate?: boolean
    transactionId?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ZakatPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zakatCalculationId" | "householdId" | "amountCents" | "currency" | "paymentDate" | "hijriDate" | "transactionId" | "notes" | "metadata" | "createdAt", ExtArgs["result"]["zakatPayment"]>
  export type ZakatPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zakatCalculation?: boolean | ZakatPayment$zakatCalculationArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    transaction?: boolean | ZakatPayment$transactionArgs<ExtArgs>
  }
  export type ZakatPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zakatCalculation?: boolean | ZakatPayment$zakatCalculationArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    transaction?: boolean | ZakatPayment$transactionArgs<ExtArgs>
  }
  export type ZakatPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zakatCalculation?: boolean | ZakatPayment$zakatCalculationArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    transaction?: boolean | ZakatPayment$transactionArgs<ExtArgs>
  }

  export type $ZakatPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZakatPayment"
    objects: {
      zakatCalculation: Prisma.$ZakatCalculationPayload<ExtArgs> | null
      household: Prisma.$HouseholdPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zakatCalculationId: string | null
      householdId: string
      amountCents: bigint
      currency: string
      paymentDate: Date
      hijriDate: string
      transactionId: string | null
      notes: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["zakatPayment"]>
    composites: {}
  }

  type ZakatPaymentGetPayload<S extends boolean | null | undefined | ZakatPaymentDefaultArgs> = $Result.GetResult<Prisma.$ZakatPaymentPayload, S>

  type ZakatPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZakatPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZakatPaymentCountAggregateInputType | true
    }

  export interface ZakatPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZakatPayment'], meta: { name: 'ZakatPayment' } }
    /**
     * Find zero or one ZakatPayment that matches the filter.
     * @param {ZakatPaymentFindUniqueArgs} args - Arguments to find a ZakatPayment
     * @example
     * // Get one ZakatPayment
     * const zakatPayment = await prisma.zakatPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZakatPaymentFindUniqueArgs>(args: SelectSubset<T, ZakatPaymentFindUniqueArgs<ExtArgs>>): Prisma__ZakatPaymentClient<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZakatPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZakatPaymentFindUniqueOrThrowArgs} args - Arguments to find a ZakatPayment
     * @example
     * // Get one ZakatPayment
     * const zakatPayment = await prisma.zakatPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZakatPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, ZakatPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZakatPaymentClient<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZakatPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatPaymentFindFirstArgs} args - Arguments to find a ZakatPayment
     * @example
     * // Get one ZakatPayment
     * const zakatPayment = await prisma.zakatPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZakatPaymentFindFirstArgs>(args?: SelectSubset<T, ZakatPaymentFindFirstArgs<ExtArgs>>): Prisma__ZakatPaymentClient<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZakatPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatPaymentFindFirstOrThrowArgs} args - Arguments to find a ZakatPayment
     * @example
     * // Get one ZakatPayment
     * const zakatPayment = await prisma.zakatPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZakatPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, ZakatPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZakatPaymentClient<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZakatPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZakatPayments
     * const zakatPayments = await prisma.zakatPayment.findMany()
     * 
     * // Get first 10 ZakatPayments
     * const zakatPayments = await prisma.zakatPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zakatPaymentWithIdOnly = await prisma.zakatPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZakatPaymentFindManyArgs>(args?: SelectSubset<T, ZakatPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZakatPayment.
     * @param {ZakatPaymentCreateArgs} args - Arguments to create a ZakatPayment.
     * @example
     * // Create one ZakatPayment
     * const ZakatPayment = await prisma.zakatPayment.create({
     *   data: {
     *     // ... data to create a ZakatPayment
     *   }
     * })
     * 
     */
    create<T extends ZakatPaymentCreateArgs>(args: SelectSubset<T, ZakatPaymentCreateArgs<ExtArgs>>): Prisma__ZakatPaymentClient<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZakatPayments.
     * @param {ZakatPaymentCreateManyArgs} args - Arguments to create many ZakatPayments.
     * @example
     * // Create many ZakatPayments
     * const zakatPayment = await prisma.zakatPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZakatPaymentCreateManyArgs>(args?: SelectSubset<T, ZakatPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZakatPayments and returns the data saved in the database.
     * @param {ZakatPaymentCreateManyAndReturnArgs} args - Arguments to create many ZakatPayments.
     * @example
     * // Create many ZakatPayments
     * const zakatPayment = await prisma.zakatPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZakatPayments and only return the `id`
     * const zakatPaymentWithIdOnly = await prisma.zakatPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZakatPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, ZakatPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZakatPayment.
     * @param {ZakatPaymentDeleteArgs} args - Arguments to delete one ZakatPayment.
     * @example
     * // Delete one ZakatPayment
     * const ZakatPayment = await prisma.zakatPayment.delete({
     *   where: {
     *     // ... filter to delete one ZakatPayment
     *   }
     * })
     * 
     */
    delete<T extends ZakatPaymentDeleteArgs>(args: SelectSubset<T, ZakatPaymentDeleteArgs<ExtArgs>>): Prisma__ZakatPaymentClient<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZakatPayment.
     * @param {ZakatPaymentUpdateArgs} args - Arguments to update one ZakatPayment.
     * @example
     * // Update one ZakatPayment
     * const zakatPayment = await prisma.zakatPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZakatPaymentUpdateArgs>(args: SelectSubset<T, ZakatPaymentUpdateArgs<ExtArgs>>): Prisma__ZakatPaymentClient<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZakatPayments.
     * @param {ZakatPaymentDeleteManyArgs} args - Arguments to filter ZakatPayments to delete.
     * @example
     * // Delete a few ZakatPayments
     * const { count } = await prisma.zakatPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZakatPaymentDeleteManyArgs>(args?: SelectSubset<T, ZakatPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZakatPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZakatPayments
     * const zakatPayment = await prisma.zakatPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZakatPaymentUpdateManyArgs>(args: SelectSubset<T, ZakatPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZakatPayments and returns the data updated in the database.
     * @param {ZakatPaymentUpdateManyAndReturnArgs} args - Arguments to update many ZakatPayments.
     * @example
     * // Update many ZakatPayments
     * const zakatPayment = await prisma.zakatPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZakatPayments and only return the `id`
     * const zakatPaymentWithIdOnly = await prisma.zakatPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZakatPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, ZakatPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZakatPayment.
     * @param {ZakatPaymentUpsertArgs} args - Arguments to update or create a ZakatPayment.
     * @example
     * // Update or create a ZakatPayment
     * const zakatPayment = await prisma.zakatPayment.upsert({
     *   create: {
     *     // ... data to create a ZakatPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZakatPayment we want to update
     *   }
     * })
     */
    upsert<T extends ZakatPaymentUpsertArgs>(args: SelectSubset<T, ZakatPaymentUpsertArgs<ExtArgs>>): Prisma__ZakatPaymentClient<$Result.GetResult<Prisma.$ZakatPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZakatPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatPaymentCountArgs} args - Arguments to filter ZakatPayments to count.
     * @example
     * // Count the number of ZakatPayments
     * const count = await prisma.zakatPayment.count({
     *   where: {
     *     // ... the filter for the ZakatPayments we want to count
     *   }
     * })
    **/
    count<T extends ZakatPaymentCountArgs>(
      args?: Subset<T, ZakatPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZakatPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZakatPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZakatPaymentAggregateArgs>(args: Subset<T, ZakatPaymentAggregateArgs>): Prisma.PrismaPromise<GetZakatPaymentAggregateType<T>>

    /**
     * Group by ZakatPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZakatPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZakatPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZakatPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ZakatPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZakatPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZakatPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZakatPayment model
   */
  readonly fields: ZakatPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZakatPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZakatPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zakatCalculation<T extends ZakatPayment$zakatCalculationArgs<ExtArgs> = {}>(args?: Subset<T, ZakatPayment$zakatCalculationArgs<ExtArgs>>): Prisma__ZakatCalculationClient<$Result.GetResult<Prisma.$ZakatCalculationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends ZakatPayment$transactionArgs<ExtArgs> = {}>(args?: Subset<T, ZakatPayment$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZakatPayment model
   */
  interface ZakatPaymentFieldRefs {
    readonly id: FieldRef<"ZakatPayment", 'String'>
    readonly zakatCalculationId: FieldRef<"ZakatPayment", 'String'>
    readonly householdId: FieldRef<"ZakatPayment", 'String'>
    readonly amountCents: FieldRef<"ZakatPayment", 'BigInt'>
    readonly currency: FieldRef<"ZakatPayment", 'String'>
    readonly paymentDate: FieldRef<"ZakatPayment", 'DateTime'>
    readonly hijriDate: FieldRef<"ZakatPayment", 'String'>
    readonly transactionId: FieldRef<"ZakatPayment", 'String'>
    readonly notes: FieldRef<"ZakatPayment", 'String'>
    readonly metadata: FieldRef<"ZakatPayment", 'Json'>
    readonly createdAt: FieldRef<"ZakatPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZakatPayment findUnique
   */
  export type ZakatPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ZakatPayment to fetch.
     */
    where: ZakatPaymentWhereUniqueInput
  }

  /**
   * ZakatPayment findUniqueOrThrow
   */
  export type ZakatPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ZakatPayment to fetch.
     */
    where: ZakatPaymentWhereUniqueInput
  }

  /**
   * ZakatPayment findFirst
   */
  export type ZakatPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ZakatPayment to fetch.
     */
    where?: ZakatPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatPayments to fetch.
     */
    orderBy?: ZakatPaymentOrderByWithRelationInput | ZakatPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZakatPayments.
     */
    cursor?: ZakatPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZakatPayments.
     */
    distinct?: ZakatPaymentScalarFieldEnum | ZakatPaymentScalarFieldEnum[]
  }

  /**
   * ZakatPayment findFirstOrThrow
   */
  export type ZakatPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ZakatPayment to fetch.
     */
    where?: ZakatPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatPayments to fetch.
     */
    orderBy?: ZakatPaymentOrderByWithRelationInput | ZakatPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZakatPayments.
     */
    cursor?: ZakatPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZakatPayments.
     */
    distinct?: ZakatPaymentScalarFieldEnum | ZakatPaymentScalarFieldEnum[]
  }

  /**
   * ZakatPayment findMany
   */
  export type ZakatPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ZakatPayments to fetch.
     */
    where?: ZakatPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZakatPayments to fetch.
     */
    orderBy?: ZakatPaymentOrderByWithRelationInput | ZakatPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZakatPayments.
     */
    cursor?: ZakatPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZakatPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZakatPayments.
     */
    skip?: number
    distinct?: ZakatPaymentScalarFieldEnum | ZakatPaymentScalarFieldEnum[]
  }

  /**
   * ZakatPayment create
   */
  export type ZakatPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ZakatPayment.
     */
    data: XOR<ZakatPaymentCreateInput, ZakatPaymentUncheckedCreateInput>
  }

  /**
   * ZakatPayment createMany
   */
  export type ZakatPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZakatPayments.
     */
    data: ZakatPaymentCreateManyInput | ZakatPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZakatPayment createManyAndReturn
   */
  export type ZakatPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many ZakatPayments.
     */
    data: ZakatPaymentCreateManyInput | ZakatPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZakatPayment update
   */
  export type ZakatPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ZakatPayment.
     */
    data: XOR<ZakatPaymentUpdateInput, ZakatPaymentUncheckedUpdateInput>
    /**
     * Choose, which ZakatPayment to update.
     */
    where: ZakatPaymentWhereUniqueInput
  }

  /**
   * ZakatPayment updateMany
   */
  export type ZakatPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZakatPayments.
     */
    data: XOR<ZakatPaymentUpdateManyMutationInput, ZakatPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ZakatPayments to update
     */
    where?: ZakatPaymentWhereInput
    /**
     * Limit how many ZakatPayments to update.
     */
    limit?: number
  }

  /**
   * ZakatPayment updateManyAndReturn
   */
  export type ZakatPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * The data used to update ZakatPayments.
     */
    data: XOR<ZakatPaymentUpdateManyMutationInput, ZakatPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ZakatPayments to update
     */
    where?: ZakatPaymentWhereInput
    /**
     * Limit how many ZakatPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZakatPayment upsert
   */
  export type ZakatPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ZakatPayment to update in case it exists.
     */
    where: ZakatPaymentWhereUniqueInput
    /**
     * In case the ZakatPayment found by the `where` argument doesn't exist, create a new ZakatPayment with this data.
     */
    create: XOR<ZakatPaymentCreateInput, ZakatPaymentUncheckedCreateInput>
    /**
     * In case the ZakatPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZakatPaymentUpdateInput, ZakatPaymentUncheckedUpdateInput>
  }

  /**
   * ZakatPayment delete
   */
  export type ZakatPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
    /**
     * Filter which ZakatPayment to delete.
     */
    where: ZakatPaymentWhereUniqueInput
  }

  /**
   * ZakatPayment deleteMany
   */
  export type ZakatPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZakatPayments to delete
     */
    where?: ZakatPaymentWhereInput
    /**
     * Limit how many ZakatPayments to delete.
     */
    limit?: number
  }

  /**
   * ZakatPayment.zakatCalculation
   */
  export type ZakatPayment$zakatCalculationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatCalculation
     */
    select?: ZakatCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatCalculation
     */
    omit?: ZakatCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatCalculationInclude<ExtArgs> | null
    where?: ZakatCalculationWhereInput
  }

  /**
   * ZakatPayment.transaction
   */
  export type ZakatPayment$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * ZakatPayment without action
   */
  export type ZakatPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZakatPayment
     */
    select?: ZakatPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZakatPayment
     */
    omit?: ZakatPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZakatPaymentInclude<ExtArgs> | null
  }


  /**
   * Model ShariaCompliantAccount
   */

  export type AggregateShariaCompliantAccount = {
    _count: ShariaCompliantAccountCountAggregateOutputType | null
    _min: ShariaCompliantAccountMinAggregateOutputType | null
    _max: ShariaCompliantAccountMaxAggregateOutputType | null
  }

  export type ShariaCompliantAccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    complianceStatus: $Enums.ShariaComplianceStatus | null
    complianceNotes: string | null
    lastReviewDate: Date | null
    nextReviewDate: Date | null
    reviewedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShariaCompliantAccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    complianceStatus: $Enums.ShariaComplianceStatus | null
    complianceNotes: string | null
    lastReviewDate: Date | null
    nextReviewDate: Date | null
    reviewedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShariaCompliantAccountCountAggregateOutputType = {
    id: number
    accountId: number
    complianceStatus: number
    complianceNotes: number
    lastReviewDate: number
    nextReviewDate: number
    reviewedBy: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShariaCompliantAccountMinAggregateInputType = {
    id?: true
    accountId?: true
    complianceStatus?: true
    complianceNotes?: true
    lastReviewDate?: true
    nextReviewDate?: true
    reviewedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShariaCompliantAccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    complianceStatus?: true
    complianceNotes?: true
    lastReviewDate?: true
    nextReviewDate?: true
    reviewedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShariaCompliantAccountCountAggregateInputType = {
    id?: true
    accountId?: true
    complianceStatus?: true
    complianceNotes?: true
    lastReviewDate?: true
    nextReviewDate?: true
    reviewedBy?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShariaCompliantAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShariaCompliantAccount to aggregate.
     */
    where?: ShariaCompliantAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShariaCompliantAccounts to fetch.
     */
    orderBy?: ShariaCompliantAccountOrderByWithRelationInput | ShariaCompliantAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShariaCompliantAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShariaCompliantAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShariaCompliantAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShariaCompliantAccounts
    **/
    _count?: true | ShariaCompliantAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShariaCompliantAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShariaCompliantAccountMaxAggregateInputType
  }

  export type GetShariaCompliantAccountAggregateType<T extends ShariaCompliantAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateShariaCompliantAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShariaCompliantAccount[P]>
      : GetScalarType<T[P], AggregateShariaCompliantAccount[P]>
  }




  export type ShariaCompliantAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShariaCompliantAccountWhereInput
    orderBy?: ShariaCompliantAccountOrderByWithAggregationInput | ShariaCompliantAccountOrderByWithAggregationInput[]
    by: ShariaCompliantAccountScalarFieldEnum[] | ShariaCompliantAccountScalarFieldEnum
    having?: ShariaCompliantAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShariaCompliantAccountCountAggregateInputType | true
    _min?: ShariaCompliantAccountMinAggregateInputType
    _max?: ShariaCompliantAccountMaxAggregateInputType
  }

  export type ShariaCompliantAccountGroupByOutputType = {
    id: string
    accountId: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes: string | null
    lastReviewDate: Date
    nextReviewDate: Date
    reviewedBy: string | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ShariaCompliantAccountCountAggregateOutputType | null
    _min: ShariaCompliantAccountMinAggregateOutputType | null
    _max: ShariaCompliantAccountMaxAggregateOutputType | null
  }

  type GetShariaCompliantAccountGroupByPayload<T extends ShariaCompliantAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShariaCompliantAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShariaCompliantAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShariaCompliantAccountGroupByOutputType[P]>
            : GetScalarType<T[P], ShariaCompliantAccountGroupByOutputType[P]>
        }
      >
    >


  export type ShariaCompliantAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    complianceStatus?: boolean
    complianceNotes?: boolean
    lastReviewDate?: boolean
    nextReviewDate?: boolean
    reviewedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    reviewer?: boolean | ShariaCompliantAccount$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["shariaCompliantAccount"]>

  export type ShariaCompliantAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    complianceStatus?: boolean
    complianceNotes?: boolean
    lastReviewDate?: boolean
    nextReviewDate?: boolean
    reviewedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    reviewer?: boolean | ShariaCompliantAccount$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["shariaCompliantAccount"]>

  export type ShariaCompliantAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    complianceStatus?: boolean
    complianceNotes?: boolean
    lastReviewDate?: boolean
    nextReviewDate?: boolean
    reviewedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    reviewer?: boolean | ShariaCompliantAccount$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["shariaCompliantAccount"]>

  export type ShariaCompliantAccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    complianceStatus?: boolean
    complianceNotes?: boolean
    lastReviewDate?: boolean
    nextReviewDate?: boolean
    reviewedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShariaCompliantAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "complianceStatus" | "complianceNotes" | "lastReviewDate" | "nextReviewDate" | "reviewedBy" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["shariaCompliantAccount"]>
  export type ShariaCompliantAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    reviewer?: boolean | ShariaCompliantAccount$reviewerArgs<ExtArgs>
  }
  export type ShariaCompliantAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    reviewer?: boolean | ShariaCompliantAccount$reviewerArgs<ExtArgs>
  }
  export type ShariaCompliantAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    reviewer?: boolean | ShariaCompliantAccount$reviewerArgs<ExtArgs>
  }

  export type $ShariaCompliantAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShariaCompliantAccount"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      complianceStatus: $Enums.ShariaComplianceStatus
      complianceNotes: string | null
      lastReviewDate: Date
      nextReviewDate: Date
      reviewedBy: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shariaCompliantAccount"]>
    composites: {}
  }

  type ShariaCompliantAccountGetPayload<S extends boolean | null | undefined | ShariaCompliantAccountDefaultArgs> = $Result.GetResult<Prisma.$ShariaCompliantAccountPayload, S>

  type ShariaCompliantAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShariaCompliantAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShariaCompliantAccountCountAggregateInputType | true
    }

  export interface ShariaCompliantAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShariaCompliantAccount'], meta: { name: 'ShariaCompliantAccount' } }
    /**
     * Find zero or one ShariaCompliantAccount that matches the filter.
     * @param {ShariaCompliantAccountFindUniqueArgs} args - Arguments to find a ShariaCompliantAccount
     * @example
     * // Get one ShariaCompliantAccount
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShariaCompliantAccountFindUniqueArgs>(args: SelectSubset<T, ShariaCompliantAccountFindUniqueArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShariaCompliantAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShariaCompliantAccountFindUniqueOrThrowArgs} args - Arguments to find a ShariaCompliantAccount
     * @example
     * // Get one ShariaCompliantAccount
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShariaCompliantAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, ShariaCompliantAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShariaCompliantAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShariaCompliantAccountFindFirstArgs} args - Arguments to find a ShariaCompliantAccount
     * @example
     * // Get one ShariaCompliantAccount
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShariaCompliantAccountFindFirstArgs>(args?: SelectSubset<T, ShariaCompliantAccountFindFirstArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShariaCompliantAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShariaCompliantAccountFindFirstOrThrowArgs} args - Arguments to find a ShariaCompliantAccount
     * @example
     * // Get one ShariaCompliantAccount
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShariaCompliantAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, ShariaCompliantAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShariaCompliantAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShariaCompliantAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShariaCompliantAccounts
     * const shariaCompliantAccounts = await prisma.shariaCompliantAccount.findMany()
     * 
     * // Get first 10 ShariaCompliantAccounts
     * const shariaCompliantAccounts = await prisma.shariaCompliantAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shariaCompliantAccountWithIdOnly = await prisma.shariaCompliantAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShariaCompliantAccountFindManyArgs>(args?: SelectSubset<T, ShariaCompliantAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShariaCompliantAccount.
     * @param {ShariaCompliantAccountCreateArgs} args - Arguments to create a ShariaCompliantAccount.
     * @example
     * // Create one ShariaCompliantAccount
     * const ShariaCompliantAccount = await prisma.shariaCompliantAccount.create({
     *   data: {
     *     // ... data to create a ShariaCompliantAccount
     *   }
     * })
     * 
     */
    create<T extends ShariaCompliantAccountCreateArgs>(args: SelectSubset<T, ShariaCompliantAccountCreateArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShariaCompliantAccounts.
     * @param {ShariaCompliantAccountCreateManyArgs} args - Arguments to create many ShariaCompliantAccounts.
     * @example
     * // Create many ShariaCompliantAccounts
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShariaCompliantAccountCreateManyArgs>(args?: SelectSubset<T, ShariaCompliantAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShariaCompliantAccounts and returns the data saved in the database.
     * @param {ShariaCompliantAccountCreateManyAndReturnArgs} args - Arguments to create many ShariaCompliantAccounts.
     * @example
     * // Create many ShariaCompliantAccounts
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShariaCompliantAccounts and only return the `id`
     * const shariaCompliantAccountWithIdOnly = await prisma.shariaCompliantAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShariaCompliantAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, ShariaCompliantAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShariaCompliantAccount.
     * @param {ShariaCompliantAccountDeleteArgs} args - Arguments to delete one ShariaCompliantAccount.
     * @example
     * // Delete one ShariaCompliantAccount
     * const ShariaCompliantAccount = await prisma.shariaCompliantAccount.delete({
     *   where: {
     *     // ... filter to delete one ShariaCompliantAccount
     *   }
     * })
     * 
     */
    delete<T extends ShariaCompliantAccountDeleteArgs>(args: SelectSubset<T, ShariaCompliantAccountDeleteArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShariaCompliantAccount.
     * @param {ShariaCompliantAccountUpdateArgs} args - Arguments to update one ShariaCompliantAccount.
     * @example
     * // Update one ShariaCompliantAccount
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShariaCompliantAccountUpdateArgs>(args: SelectSubset<T, ShariaCompliantAccountUpdateArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShariaCompliantAccounts.
     * @param {ShariaCompliantAccountDeleteManyArgs} args - Arguments to filter ShariaCompliantAccounts to delete.
     * @example
     * // Delete a few ShariaCompliantAccounts
     * const { count } = await prisma.shariaCompliantAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShariaCompliantAccountDeleteManyArgs>(args?: SelectSubset<T, ShariaCompliantAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShariaCompliantAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShariaCompliantAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShariaCompliantAccounts
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShariaCompliantAccountUpdateManyArgs>(args: SelectSubset<T, ShariaCompliantAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShariaCompliantAccounts and returns the data updated in the database.
     * @param {ShariaCompliantAccountUpdateManyAndReturnArgs} args - Arguments to update many ShariaCompliantAccounts.
     * @example
     * // Update many ShariaCompliantAccounts
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShariaCompliantAccounts and only return the `id`
     * const shariaCompliantAccountWithIdOnly = await prisma.shariaCompliantAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShariaCompliantAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, ShariaCompliantAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShariaCompliantAccount.
     * @param {ShariaCompliantAccountUpsertArgs} args - Arguments to update or create a ShariaCompliantAccount.
     * @example
     * // Update or create a ShariaCompliantAccount
     * const shariaCompliantAccount = await prisma.shariaCompliantAccount.upsert({
     *   create: {
     *     // ... data to create a ShariaCompliantAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShariaCompliantAccount we want to update
     *   }
     * })
     */
    upsert<T extends ShariaCompliantAccountUpsertArgs>(args: SelectSubset<T, ShariaCompliantAccountUpsertArgs<ExtArgs>>): Prisma__ShariaCompliantAccountClient<$Result.GetResult<Prisma.$ShariaCompliantAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShariaCompliantAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShariaCompliantAccountCountArgs} args - Arguments to filter ShariaCompliantAccounts to count.
     * @example
     * // Count the number of ShariaCompliantAccounts
     * const count = await prisma.shariaCompliantAccount.count({
     *   where: {
     *     // ... the filter for the ShariaCompliantAccounts we want to count
     *   }
     * })
    **/
    count<T extends ShariaCompliantAccountCountArgs>(
      args?: Subset<T, ShariaCompliantAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShariaCompliantAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShariaCompliantAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShariaCompliantAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShariaCompliantAccountAggregateArgs>(args: Subset<T, ShariaCompliantAccountAggregateArgs>): Prisma.PrismaPromise<GetShariaCompliantAccountAggregateType<T>>

    /**
     * Group by ShariaCompliantAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShariaCompliantAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShariaCompliantAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShariaCompliantAccountGroupByArgs['orderBy'] }
        : { orderBy?: ShariaCompliantAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShariaCompliantAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShariaCompliantAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShariaCompliantAccount model
   */
  readonly fields: ShariaCompliantAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShariaCompliantAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShariaCompliantAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends ShariaCompliantAccount$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, ShariaCompliantAccount$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShariaCompliantAccount model
   */
  interface ShariaCompliantAccountFieldRefs {
    readonly id: FieldRef<"ShariaCompliantAccount", 'String'>
    readonly accountId: FieldRef<"ShariaCompliantAccount", 'String'>
    readonly complianceStatus: FieldRef<"ShariaCompliantAccount", 'ShariaComplianceStatus'>
    readonly complianceNotes: FieldRef<"ShariaCompliantAccount", 'String'>
    readonly lastReviewDate: FieldRef<"ShariaCompliantAccount", 'DateTime'>
    readonly nextReviewDate: FieldRef<"ShariaCompliantAccount", 'DateTime'>
    readonly reviewedBy: FieldRef<"ShariaCompliantAccount", 'String'>
    readonly metadata: FieldRef<"ShariaCompliantAccount", 'Json'>
    readonly createdAt: FieldRef<"ShariaCompliantAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"ShariaCompliantAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShariaCompliantAccount findUnique
   */
  export type ShariaCompliantAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * Filter, which ShariaCompliantAccount to fetch.
     */
    where: ShariaCompliantAccountWhereUniqueInput
  }

  /**
   * ShariaCompliantAccount findUniqueOrThrow
   */
  export type ShariaCompliantAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * Filter, which ShariaCompliantAccount to fetch.
     */
    where: ShariaCompliantAccountWhereUniqueInput
  }

  /**
   * ShariaCompliantAccount findFirst
   */
  export type ShariaCompliantAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * Filter, which ShariaCompliantAccount to fetch.
     */
    where?: ShariaCompliantAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShariaCompliantAccounts to fetch.
     */
    orderBy?: ShariaCompliantAccountOrderByWithRelationInput | ShariaCompliantAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShariaCompliantAccounts.
     */
    cursor?: ShariaCompliantAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShariaCompliantAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShariaCompliantAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShariaCompliantAccounts.
     */
    distinct?: ShariaCompliantAccountScalarFieldEnum | ShariaCompliantAccountScalarFieldEnum[]
  }

  /**
   * ShariaCompliantAccount findFirstOrThrow
   */
  export type ShariaCompliantAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * Filter, which ShariaCompliantAccount to fetch.
     */
    where?: ShariaCompliantAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShariaCompliantAccounts to fetch.
     */
    orderBy?: ShariaCompliantAccountOrderByWithRelationInput | ShariaCompliantAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShariaCompliantAccounts.
     */
    cursor?: ShariaCompliantAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShariaCompliantAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShariaCompliantAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShariaCompliantAccounts.
     */
    distinct?: ShariaCompliantAccountScalarFieldEnum | ShariaCompliantAccountScalarFieldEnum[]
  }

  /**
   * ShariaCompliantAccount findMany
   */
  export type ShariaCompliantAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * Filter, which ShariaCompliantAccounts to fetch.
     */
    where?: ShariaCompliantAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShariaCompliantAccounts to fetch.
     */
    orderBy?: ShariaCompliantAccountOrderByWithRelationInput | ShariaCompliantAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShariaCompliantAccounts.
     */
    cursor?: ShariaCompliantAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShariaCompliantAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShariaCompliantAccounts.
     */
    skip?: number
    distinct?: ShariaCompliantAccountScalarFieldEnum | ShariaCompliantAccountScalarFieldEnum[]
  }

  /**
   * ShariaCompliantAccount create
   */
  export type ShariaCompliantAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a ShariaCompliantAccount.
     */
    data: XOR<ShariaCompliantAccountCreateInput, ShariaCompliantAccountUncheckedCreateInput>
  }

  /**
   * ShariaCompliantAccount createMany
   */
  export type ShariaCompliantAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShariaCompliantAccounts.
     */
    data: ShariaCompliantAccountCreateManyInput | ShariaCompliantAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShariaCompliantAccount createManyAndReturn
   */
  export type ShariaCompliantAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * The data used to create many ShariaCompliantAccounts.
     */
    data: ShariaCompliantAccountCreateManyInput | ShariaCompliantAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShariaCompliantAccount update
   */
  export type ShariaCompliantAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a ShariaCompliantAccount.
     */
    data: XOR<ShariaCompliantAccountUpdateInput, ShariaCompliantAccountUncheckedUpdateInput>
    /**
     * Choose, which ShariaCompliantAccount to update.
     */
    where: ShariaCompliantAccountWhereUniqueInput
  }

  /**
   * ShariaCompliantAccount updateMany
   */
  export type ShariaCompliantAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShariaCompliantAccounts.
     */
    data: XOR<ShariaCompliantAccountUpdateManyMutationInput, ShariaCompliantAccountUncheckedUpdateManyInput>
    /**
     * Filter which ShariaCompliantAccounts to update
     */
    where?: ShariaCompliantAccountWhereInput
    /**
     * Limit how many ShariaCompliantAccounts to update.
     */
    limit?: number
  }

  /**
   * ShariaCompliantAccount updateManyAndReturn
   */
  export type ShariaCompliantAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * The data used to update ShariaCompliantAccounts.
     */
    data: XOR<ShariaCompliantAccountUpdateManyMutationInput, ShariaCompliantAccountUncheckedUpdateManyInput>
    /**
     * Filter which ShariaCompliantAccounts to update
     */
    where?: ShariaCompliantAccountWhereInput
    /**
     * Limit how many ShariaCompliantAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShariaCompliantAccount upsert
   */
  export type ShariaCompliantAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the ShariaCompliantAccount to update in case it exists.
     */
    where: ShariaCompliantAccountWhereUniqueInput
    /**
     * In case the ShariaCompliantAccount found by the `where` argument doesn't exist, create a new ShariaCompliantAccount with this data.
     */
    create: XOR<ShariaCompliantAccountCreateInput, ShariaCompliantAccountUncheckedCreateInput>
    /**
     * In case the ShariaCompliantAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShariaCompliantAccountUpdateInput, ShariaCompliantAccountUncheckedUpdateInput>
  }

  /**
   * ShariaCompliantAccount delete
   */
  export type ShariaCompliantAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
    /**
     * Filter which ShariaCompliantAccount to delete.
     */
    where: ShariaCompliantAccountWhereUniqueInput
  }

  /**
   * ShariaCompliantAccount deleteMany
   */
  export type ShariaCompliantAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShariaCompliantAccounts to delete
     */
    where?: ShariaCompliantAccountWhereInput
    /**
     * Limit how many ShariaCompliantAccounts to delete.
     */
    limit?: number
  }

  /**
   * ShariaCompliantAccount.reviewer
   */
  export type ShariaCompliantAccount$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ShariaCompliantAccount without action
   */
  export type ShariaCompliantAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShariaCompliantAccount
     */
    select?: ShariaCompliantAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShariaCompliantAccount
     */
    omit?: ShariaCompliantAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShariaCompliantAccountInclude<ExtArgs> | null
  }


  /**
   * Model IslamicFinanceReport
   */

  export type AggregateIslamicFinanceReport = {
    _count: IslamicFinanceReportCountAggregateOutputType | null
    _min: IslamicFinanceReportMinAggregateOutputType | null
    _max: IslamicFinanceReportMaxAggregateOutputType | null
  }

  export type IslamicFinanceReportMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    reportType: $Enums.IslamicReportType | null
    periodStartDate: Date | null
    periodEndDate: Date | null
    periodType: string | null
    generatedAt: Date | null
    generatedBy: string | null
    createdAt: Date | null
  }

  export type IslamicFinanceReportMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    reportType: $Enums.IslamicReportType | null
    periodStartDate: Date | null
    periodEndDate: Date | null
    periodType: string | null
    generatedAt: Date | null
    generatedBy: string | null
    createdAt: Date | null
  }

  export type IslamicFinanceReportCountAggregateOutputType = {
    id: number
    householdId: number
    reportType: number
    periodStartDate: number
    periodEndDate: number
    periodType: number
    reportData: number
    generatedAt: number
    generatedBy: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type IslamicFinanceReportMinAggregateInputType = {
    id?: true
    householdId?: true
    reportType?: true
    periodStartDate?: true
    periodEndDate?: true
    periodType?: true
    generatedAt?: true
    generatedBy?: true
    createdAt?: true
  }

  export type IslamicFinanceReportMaxAggregateInputType = {
    id?: true
    householdId?: true
    reportType?: true
    periodStartDate?: true
    periodEndDate?: true
    periodType?: true
    generatedAt?: true
    generatedBy?: true
    createdAt?: true
  }

  export type IslamicFinanceReportCountAggregateInputType = {
    id?: true
    householdId?: true
    reportType?: true
    periodStartDate?: true
    periodEndDate?: true
    periodType?: true
    reportData?: true
    generatedAt?: true
    generatedBy?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type IslamicFinanceReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IslamicFinanceReport to aggregate.
     */
    where?: IslamicFinanceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IslamicFinanceReports to fetch.
     */
    orderBy?: IslamicFinanceReportOrderByWithRelationInput | IslamicFinanceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IslamicFinanceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IslamicFinanceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IslamicFinanceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IslamicFinanceReports
    **/
    _count?: true | IslamicFinanceReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IslamicFinanceReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IslamicFinanceReportMaxAggregateInputType
  }

  export type GetIslamicFinanceReportAggregateType<T extends IslamicFinanceReportAggregateArgs> = {
        [P in keyof T & keyof AggregateIslamicFinanceReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIslamicFinanceReport[P]>
      : GetScalarType<T[P], AggregateIslamicFinanceReport[P]>
  }




  export type IslamicFinanceReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IslamicFinanceReportWhereInput
    orderBy?: IslamicFinanceReportOrderByWithAggregationInput | IslamicFinanceReportOrderByWithAggregationInput[]
    by: IslamicFinanceReportScalarFieldEnum[] | IslamicFinanceReportScalarFieldEnum
    having?: IslamicFinanceReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IslamicFinanceReportCountAggregateInputType | true
    _min?: IslamicFinanceReportMinAggregateInputType
    _max?: IslamicFinanceReportMaxAggregateInputType
  }

  export type IslamicFinanceReportGroupByOutputType = {
    id: string
    householdId: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date
    periodEndDate: Date
    periodType: string
    reportData: JsonValue
    generatedAt: Date
    generatedBy: string | null
    metadata: JsonValue
    createdAt: Date
    _count: IslamicFinanceReportCountAggregateOutputType | null
    _min: IslamicFinanceReportMinAggregateOutputType | null
    _max: IslamicFinanceReportMaxAggregateOutputType | null
  }

  type GetIslamicFinanceReportGroupByPayload<T extends IslamicFinanceReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IslamicFinanceReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IslamicFinanceReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IslamicFinanceReportGroupByOutputType[P]>
            : GetScalarType<T[P], IslamicFinanceReportGroupByOutputType[P]>
        }
      >
    >


  export type IslamicFinanceReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    reportType?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    periodType?: boolean
    reportData?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    generator?: boolean | IslamicFinanceReport$generatorArgs<ExtArgs>
  }, ExtArgs["result"]["islamicFinanceReport"]>

  export type IslamicFinanceReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    reportType?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    periodType?: boolean
    reportData?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    generator?: boolean | IslamicFinanceReport$generatorArgs<ExtArgs>
  }, ExtArgs["result"]["islamicFinanceReport"]>

  export type IslamicFinanceReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    reportType?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    periodType?: boolean
    reportData?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    generator?: boolean | IslamicFinanceReport$generatorArgs<ExtArgs>
  }, ExtArgs["result"]["islamicFinanceReport"]>

  export type IslamicFinanceReportSelectScalar = {
    id?: boolean
    householdId?: boolean
    reportType?: boolean
    periodStartDate?: boolean
    periodEndDate?: boolean
    periodType?: boolean
    reportData?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type IslamicFinanceReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "householdId" | "reportType" | "periodStartDate" | "periodEndDate" | "periodType" | "reportData" | "generatedAt" | "generatedBy" | "metadata" | "createdAt", ExtArgs["result"]["islamicFinanceReport"]>
  export type IslamicFinanceReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    generator?: boolean | IslamicFinanceReport$generatorArgs<ExtArgs>
  }
  export type IslamicFinanceReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    generator?: boolean | IslamicFinanceReport$generatorArgs<ExtArgs>
  }
  export type IslamicFinanceReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    generator?: boolean | IslamicFinanceReport$generatorArgs<ExtArgs>
  }

  export type $IslamicFinanceReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IslamicFinanceReport"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      generator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      reportType: $Enums.IslamicReportType
      periodStartDate: Date
      periodEndDate: Date
      periodType: string
      reportData: Prisma.JsonValue
      generatedAt: Date
      generatedBy: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["islamicFinanceReport"]>
    composites: {}
  }

  type IslamicFinanceReportGetPayload<S extends boolean | null | undefined | IslamicFinanceReportDefaultArgs> = $Result.GetResult<Prisma.$IslamicFinanceReportPayload, S>

  type IslamicFinanceReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IslamicFinanceReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IslamicFinanceReportCountAggregateInputType | true
    }

  export interface IslamicFinanceReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IslamicFinanceReport'], meta: { name: 'IslamicFinanceReport' } }
    /**
     * Find zero or one IslamicFinanceReport that matches the filter.
     * @param {IslamicFinanceReportFindUniqueArgs} args - Arguments to find a IslamicFinanceReport
     * @example
     * // Get one IslamicFinanceReport
     * const islamicFinanceReport = await prisma.islamicFinanceReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IslamicFinanceReportFindUniqueArgs>(args: SelectSubset<T, IslamicFinanceReportFindUniqueArgs<ExtArgs>>): Prisma__IslamicFinanceReportClient<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IslamicFinanceReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IslamicFinanceReportFindUniqueOrThrowArgs} args - Arguments to find a IslamicFinanceReport
     * @example
     * // Get one IslamicFinanceReport
     * const islamicFinanceReport = await prisma.islamicFinanceReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IslamicFinanceReportFindUniqueOrThrowArgs>(args: SelectSubset<T, IslamicFinanceReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IslamicFinanceReportClient<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IslamicFinanceReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IslamicFinanceReportFindFirstArgs} args - Arguments to find a IslamicFinanceReport
     * @example
     * // Get one IslamicFinanceReport
     * const islamicFinanceReport = await prisma.islamicFinanceReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IslamicFinanceReportFindFirstArgs>(args?: SelectSubset<T, IslamicFinanceReportFindFirstArgs<ExtArgs>>): Prisma__IslamicFinanceReportClient<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IslamicFinanceReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IslamicFinanceReportFindFirstOrThrowArgs} args - Arguments to find a IslamicFinanceReport
     * @example
     * // Get one IslamicFinanceReport
     * const islamicFinanceReport = await prisma.islamicFinanceReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IslamicFinanceReportFindFirstOrThrowArgs>(args?: SelectSubset<T, IslamicFinanceReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__IslamicFinanceReportClient<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IslamicFinanceReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IslamicFinanceReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IslamicFinanceReports
     * const islamicFinanceReports = await prisma.islamicFinanceReport.findMany()
     * 
     * // Get first 10 IslamicFinanceReports
     * const islamicFinanceReports = await prisma.islamicFinanceReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const islamicFinanceReportWithIdOnly = await prisma.islamicFinanceReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IslamicFinanceReportFindManyArgs>(args?: SelectSubset<T, IslamicFinanceReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IslamicFinanceReport.
     * @param {IslamicFinanceReportCreateArgs} args - Arguments to create a IslamicFinanceReport.
     * @example
     * // Create one IslamicFinanceReport
     * const IslamicFinanceReport = await prisma.islamicFinanceReport.create({
     *   data: {
     *     // ... data to create a IslamicFinanceReport
     *   }
     * })
     * 
     */
    create<T extends IslamicFinanceReportCreateArgs>(args: SelectSubset<T, IslamicFinanceReportCreateArgs<ExtArgs>>): Prisma__IslamicFinanceReportClient<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IslamicFinanceReports.
     * @param {IslamicFinanceReportCreateManyArgs} args - Arguments to create many IslamicFinanceReports.
     * @example
     * // Create many IslamicFinanceReports
     * const islamicFinanceReport = await prisma.islamicFinanceReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IslamicFinanceReportCreateManyArgs>(args?: SelectSubset<T, IslamicFinanceReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IslamicFinanceReports and returns the data saved in the database.
     * @param {IslamicFinanceReportCreateManyAndReturnArgs} args - Arguments to create many IslamicFinanceReports.
     * @example
     * // Create many IslamicFinanceReports
     * const islamicFinanceReport = await prisma.islamicFinanceReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IslamicFinanceReports and only return the `id`
     * const islamicFinanceReportWithIdOnly = await prisma.islamicFinanceReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IslamicFinanceReportCreateManyAndReturnArgs>(args?: SelectSubset<T, IslamicFinanceReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IslamicFinanceReport.
     * @param {IslamicFinanceReportDeleteArgs} args - Arguments to delete one IslamicFinanceReport.
     * @example
     * // Delete one IslamicFinanceReport
     * const IslamicFinanceReport = await prisma.islamicFinanceReport.delete({
     *   where: {
     *     // ... filter to delete one IslamicFinanceReport
     *   }
     * })
     * 
     */
    delete<T extends IslamicFinanceReportDeleteArgs>(args: SelectSubset<T, IslamicFinanceReportDeleteArgs<ExtArgs>>): Prisma__IslamicFinanceReportClient<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IslamicFinanceReport.
     * @param {IslamicFinanceReportUpdateArgs} args - Arguments to update one IslamicFinanceReport.
     * @example
     * // Update one IslamicFinanceReport
     * const islamicFinanceReport = await prisma.islamicFinanceReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IslamicFinanceReportUpdateArgs>(args: SelectSubset<T, IslamicFinanceReportUpdateArgs<ExtArgs>>): Prisma__IslamicFinanceReportClient<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IslamicFinanceReports.
     * @param {IslamicFinanceReportDeleteManyArgs} args - Arguments to filter IslamicFinanceReports to delete.
     * @example
     * // Delete a few IslamicFinanceReports
     * const { count } = await prisma.islamicFinanceReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IslamicFinanceReportDeleteManyArgs>(args?: SelectSubset<T, IslamicFinanceReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IslamicFinanceReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IslamicFinanceReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IslamicFinanceReports
     * const islamicFinanceReport = await prisma.islamicFinanceReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IslamicFinanceReportUpdateManyArgs>(args: SelectSubset<T, IslamicFinanceReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IslamicFinanceReports and returns the data updated in the database.
     * @param {IslamicFinanceReportUpdateManyAndReturnArgs} args - Arguments to update many IslamicFinanceReports.
     * @example
     * // Update many IslamicFinanceReports
     * const islamicFinanceReport = await prisma.islamicFinanceReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IslamicFinanceReports and only return the `id`
     * const islamicFinanceReportWithIdOnly = await prisma.islamicFinanceReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IslamicFinanceReportUpdateManyAndReturnArgs>(args: SelectSubset<T, IslamicFinanceReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IslamicFinanceReport.
     * @param {IslamicFinanceReportUpsertArgs} args - Arguments to update or create a IslamicFinanceReport.
     * @example
     * // Update or create a IslamicFinanceReport
     * const islamicFinanceReport = await prisma.islamicFinanceReport.upsert({
     *   create: {
     *     // ... data to create a IslamicFinanceReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IslamicFinanceReport we want to update
     *   }
     * })
     */
    upsert<T extends IslamicFinanceReportUpsertArgs>(args: SelectSubset<T, IslamicFinanceReportUpsertArgs<ExtArgs>>): Prisma__IslamicFinanceReportClient<$Result.GetResult<Prisma.$IslamicFinanceReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IslamicFinanceReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IslamicFinanceReportCountArgs} args - Arguments to filter IslamicFinanceReports to count.
     * @example
     * // Count the number of IslamicFinanceReports
     * const count = await prisma.islamicFinanceReport.count({
     *   where: {
     *     // ... the filter for the IslamicFinanceReports we want to count
     *   }
     * })
    **/
    count<T extends IslamicFinanceReportCountArgs>(
      args?: Subset<T, IslamicFinanceReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IslamicFinanceReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IslamicFinanceReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IslamicFinanceReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IslamicFinanceReportAggregateArgs>(args: Subset<T, IslamicFinanceReportAggregateArgs>): Prisma.PrismaPromise<GetIslamicFinanceReportAggregateType<T>>

    /**
     * Group by IslamicFinanceReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IslamicFinanceReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IslamicFinanceReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IslamicFinanceReportGroupByArgs['orderBy'] }
        : { orderBy?: IslamicFinanceReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IslamicFinanceReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIslamicFinanceReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IslamicFinanceReport model
   */
  readonly fields: IslamicFinanceReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IslamicFinanceReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IslamicFinanceReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generator<T extends IslamicFinanceReport$generatorArgs<ExtArgs> = {}>(args?: Subset<T, IslamicFinanceReport$generatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IslamicFinanceReport model
   */
  interface IslamicFinanceReportFieldRefs {
    readonly id: FieldRef<"IslamicFinanceReport", 'String'>
    readonly householdId: FieldRef<"IslamicFinanceReport", 'String'>
    readonly reportType: FieldRef<"IslamicFinanceReport", 'IslamicReportType'>
    readonly periodStartDate: FieldRef<"IslamicFinanceReport", 'DateTime'>
    readonly periodEndDate: FieldRef<"IslamicFinanceReport", 'DateTime'>
    readonly periodType: FieldRef<"IslamicFinanceReport", 'String'>
    readonly reportData: FieldRef<"IslamicFinanceReport", 'Json'>
    readonly generatedAt: FieldRef<"IslamicFinanceReport", 'DateTime'>
    readonly generatedBy: FieldRef<"IslamicFinanceReport", 'String'>
    readonly metadata: FieldRef<"IslamicFinanceReport", 'Json'>
    readonly createdAt: FieldRef<"IslamicFinanceReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IslamicFinanceReport findUnique
   */
  export type IslamicFinanceReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * Filter, which IslamicFinanceReport to fetch.
     */
    where: IslamicFinanceReportWhereUniqueInput
  }

  /**
   * IslamicFinanceReport findUniqueOrThrow
   */
  export type IslamicFinanceReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * Filter, which IslamicFinanceReport to fetch.
     */
    where: IslamicFinanceReportWhereUniqueInput
  }

  /**
   * IslamicFinanceReport findFirst
   */
  export type IslamicFinanceReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * Filter, which IslamicFinanceReport to fetch.
     */
    where?: IslamicFinanceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IslamicFinanceReports to fetch.
     */
    orderBy?: IslamicFinanceReportOrderByWithRelationInput | IslamicFinanceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IslamicFinanceReports.
     */
    cursor?: IslamicFinanceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IslamicFinanceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IslamicFinanceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IslamicFinanceReports.
     */
    distinct?: IslamicFinanceReportScalarFieldEnum | IslamicFinanceReportScalarFieldEnum[]
  }

  /**
   * IslamicFinanceReport findFirstOrThrow
   */
  export type IslamicFinanceReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * Filter, which IslamicFinanceReport to fetch.
     */
    where?: IslamicFinanceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IslamicFinanceReports to fetch.
     */
    orderBy?: IslamicFinanceReportOrderByWithRelationInput | IslamicFinanceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IslamicFinanceReports.
     */
    cursor?: IslamicFinanceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IslamicFinanceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IslamicFinanceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IslamicFinanceReports.
     */
    distinct?: IslamicFinanceReportScalarFieldEnum | IslamicFinanceReportScalarFieldEnum[]
  }

  /**
   * IslamicFinanceReport findMany
   */
  export type IslamicFinanceReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * Filter, which IslamicFinanceReports to fetch.
     */
    where?: IslamicFinanceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IslamicFinanceReports to fetch.
     */
    orderBy?: IslamicFinanceReportOrderByWithRelationInput | IslamicFinanceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IslamicFinanceReports.
     */
    cursor?: IslamicFinanceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IslamicFinanceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IslamicFinanceReports.
     */
    skip?: number
    distinct?: IslamicFinanceReportScalarFieldEnum | IslamicFinanceReportScalarFieldEnum[]
  }

  /**
   * IslamicFinanceReport create
   */
  export type IslamicFinanceReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * The data needed to create a IslamicFinanceReport.
     */
    data: XOR<IslamicFinanceReportCreateInput, IslamicFinanceReportUncheckedCreateInput>
  }

  /**
   * IslamicFinanceReport createMany
   */
  export type IslamicFinanceReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IslamicFinanceReports.
     */
    data: IslamicFinanceReportCreateManyInput | IslamicFinanceReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IslamicFinanceReport createManyAndReturn
   */
  export type IslamicFinanceReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * The data used to create many IslamicFinanceReports.
     */
    data: IslamicFinanceReportCreateManyInput | IslamicFinanceReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IslamicFinanceReport update
   */
  export type IslamicFinanceReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * The data needed to update a IslamicFinanceReport.
     */
    data: XOR<IslamicFinanceReportUpdateInput, IslamicFinanceReportUncheckedUpdateInput>
    /**
     * Choose, which IslamicFinanceReport to update.
     */
    where: IslamicFinanceReportWhereUniqueInput
  }

  /**
   * IslamicFinanceReport updateMany
   */
  export type IslamicFinanceReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IslamicFinanceReports.
     */
    data: XOR<IslamicFinanceReportUpdateManyMutationInput, IslamicFinanceReportUncheckedUpdateManyInput>
    /**
     * Filter which IslamicFinanceReports to update
     */
    where?: IslamicFinanceReportWhereInput
    /**
     * Limit how many IslamicFinanceReports to update.
     */
    limit?: number
  }

  /**
   * IslamicFinanceReport updateManyAndReturn
   */
  export type IslamicFinanceReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * The data used to update IslamicFinanceReports.
     */
    data: XOR<IslamicFinanceReportUpdateManyMutationInput, IslamicFinanceReportUncheckedUpdateManyInput>
    /**
     * Filter which IslamicFinanceReports to update
     */
    where?: IslamicFinanceReportWhereInput
    /**
     * Limit how many IslamicFinanceReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IslamicFinanceReport upsert
   */
  export type IslamicFinanceReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * The filter to search for the IslamicFinanceReport to update in case it exists.
     */
    where: IslamicFinanceReportWhereUniqueInput
    /**
     * In case the IslamicFinanceReport found by the `where` argument doesn't exist, create a new IslamicFinanceReport with this data.
     */
    create: XOR<IslamicFinanceReportCreateInput, IslamicFinanceReportUncheckedCreateInput>
    /**
     * In case the IslamicFinanceReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IslamicFinanceReportUpdateInput, IslamicFinanceReportUncheckedUpdateInput>
  }

  /**
   * IslamicFinanceReport delete
   */
  export type IslamicFinanceReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
    /**
     * Filter which IslamicFinanceReport to delete.
     */
    where: IslamicFinanceReportWhereUniqueInput
  }

  /**
   * IslamicFinanceReport deleteMany
   */
  export type IslamicFinanceReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IslamicFinanceReports to delete
     */
    where?: IslamicFinanceReportWhereInput
    /**
     * Limit how many IslamicFinanceReports to delete.
     */
    limit?: number
  }

  /**
   * IslamicFinanceReport.generator
   */
  export type IslamicFinanceReport$generatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * IslamicFinanceReport without action
   */
  export type IslamicFinanceReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IslamicFinanceReport
     */
    select?: IslamicFinanceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IslamicFinanceReport
     */
    omit?: IslamicFinanceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IslamicFinanceReportInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    actionUrl: string | null
    actionText: string | null
    priority: $Enums.NotificationPriority | null
    status: $Enums.NotificationStatus | null
    scheduledAt: Date | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    actionUrl: string | null
    actionText: string | null
    priority: $Enums.NotificationPriority | null
    status: $Enums.NotificationStatus | null
    scheduledAt: Date | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    householdId: number
    type: number
    title: number
    message: number
    actionUrl: number
    actionText: number
    metadata: number
    priority: number
    status: number
    channels: number
    scheduledAt: number
    sentAt: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    actionText?: true
    priority?: true
    status?: true
    scheduledAt?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    actionText?: true
    priority?: true
    status?: true
    scheduledAt?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    actionText?: true
    metadata?: true
    priority?: true
    status?: true
    channels?: true
    scheduledAt?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    householdId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl: string | null
    actionText: string | null
    metadata: JsonValue
    priority: $Enums.NotificationPriority
    status: $Enums.NotificationStatus
    channels: $Enums.NotificationChannel[]
    scheduledAt: Date | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    actionText?: boolean
    metadata?: boolean
    priority?: boolean
    status?: boolean
    channels?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    deliveries?: boolean | Notification$deliveriesArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    actionText?: boolean
    metadata?: boolean
    priority?: boolean
    status?: boolean
    channels?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    actionText?: boolean
    metadata?: boolean
    priority?: boolean
    status?: boolean
    channels?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    householdId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    actionText?: boolean
    metadata?: boolean
    priority?: boolean
    status?: boolean
    channels?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "householdId" | "type" | "title" | "message" | "actionUrl" | "actionText" | "metadata" | "priority" | "status" | "channels" | "scheduledAt" | "sentAt" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    deliveries?: boolean | Notification$deliveriesArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      household: Prisma.$HouseholdPayload<ExtArgs>
      deliveries: Prisma.$NotificationDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      householdId: string
      type: $Enums.NotificationType
      title: string
      message: string
      actionUrl: string | null
      actionText: string | null
      metadata: Prisma.JsonValue
      priority: $Enums.NotificationPriority
      status: $Enums.NotificationStatus
      channels: $Enums.NotificationChannel[]
      scheduledAt: Date | null
      sentAt: Date | null
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends Notification$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Notification$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly householdId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly actionText: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly channels: FieldRef<"Notification", 'NotificationChannel[]'>
    readonly scheduledAt: FieldRef<"Notification", 'DateTime'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.deliveries
   */
  export type Notification$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    where?: NotificationDeliveryWhereInput
    orderBy?: NotificationDeliveryOrderByWithRelationInput | NotificationDeliveryOrderByWithRelationInput[]
    cursor?: NotificationDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationDelivery
   */

  export type AggregateNotificationDelivery = {
    _count: NotificationDeliveryCountAggregateOutputType | null
    _avg: NotificationDeliveryAvgAggregateOutputType | null
    _sum: NotificationDeliverySumAggregateOutputType | null
    _min: NotificationDeliveryMinAggregateOutputType | null
    _max: NotificationDeliveryMaxAggregateOutputType | null
  }

  export type NotificationDeliveryAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type NotificationDeliverySumAggregateOutputType = {
    retryCount: number | null
  }

  export type NotificationDeliveryMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    channel: $Enums.NotificationChannel | null
    status: $Enums.NotificationStatus | null
    deliveredAt: Date | null
    failureReason: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationDeliveryMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    channel: $Enums.NotificationChannel | null
    status: $Enums.NotificationStatus | null
    deliveredAt: Date | null
    failureReason: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationDeliveryCountAggregateOutputType = {
    id: number
    notificationId: number
    channel: number
    status: number
    deliveredAt: number
    failureReason: number
    retryCount: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationDeliveryAvgAggregateInputType = {
    retryCount?: true
  }

  export type NotificationDeliverySumAggregateInputType = {
    retryCount?: true
  }

  export type NotificationDeliveryMinAggregateInputType = {
    id?: true
    notificationId?: true
    channel?: true
    status?: true
    deliveredAt?: true
    failureReason?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationDeliveryMaxAggregateInputType = {
    id?: true
    notificationId?: true
    channel?: true
    status?: true
    deliveredAt?: true
    failureReason?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationDeliveryCountAggregateInputType = {
    id?: true
    notificationId?: true
    channel?: true
    status?: true
    deliveredAt?: true
    failureReason?: true
    retryCount?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationDelivery to aggregate.
     */
    where?: NotificationDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationDeliveries to fetch.
     */
    orderBy?: NotificationDeliveryOrderByWithRelationInput | NotificationDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationDeliveries
    **/
    _count?: true | NotificationDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationDeliveryMaxAggregateInputType
  }

  export type GetNotificationDeliveryAggregateType<T extends NotificationDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationDelivery[P]>
      : GetScalarType<T[P], AggregateNotificationDelivery[P]>
  }




  export type NotificationDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationDeliveryWhereInput
    orderBy?: NotificationDeliveryOrderByWithAggregationInput | NotificationDeliveryOrderByWithAggregationInput[]
    by: NotificationDeliveryScalarFieldEnum[] | NotificationDeliveryScalarFieldEnum
    having?: NotificationDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationDeliveryCountAggregateInputType | true
    _avg?: NotificationDeliveryAvgAggregateInputType
    _sum?: NotificationDeliverySumAggregateInputType
    _min?: NotificationDeliveryMinAggregateInputType
    _max?: NotificationDeliveryMaxAggregateInputType
  }

  export type NotificationDeliveryGroupByOutputType = {
    id: string
    notificationId: string
    channel: $Enums.NotificationChannel
    status: $Enums.NotificationStatus
    deliveredAt: Date | null
    failureReason: string | null
    retryCount: number
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: NotificationDeliveryCountAggregateOutputType | null
    _avg: NotificationDeliveryAvgAggregateOutputType | null
    _sum: NotificationDeliverySumAggregateOutputType | null
    _min: NotificationDeliveryMinAggregateOutputType | null
    _max: NotificationDeliveryMaxAggregateOutputType | null
  }

  type GetNotificationDeliveryGroupByPayload<T extends NotificationDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type NotificationDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    channel?: boolean
    status?: boolean
    deliveredAt?: boolean
    failureReason?: boolean
    retryCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationDelivery"]>

  export type NotificationDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    channel?: boolean
    status?: boolean
    deliveredAt?: boolean
    failureReason?: boolean
    retryCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationDelivery"]>

  export type NotificationDeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    channel?: boolean
    status?: boolean
    deliveredAt?: boolean
    failureReason?: boolean
    retryCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationDelivery"]>

  export type NotificationDeliverySelectScalar = {
    id?: boolean
    notificationId?: boolean
    channel?: boolean
    status?: boolean
    deliveredAt?: boolean
    failureReason?: boolean
    retryCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationId" | "channel" | "status" | "deliveredAt" | "failureReason" | "retryCount" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationDelivery"]>
  export type NotificationDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }
  export type NotificationDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }
  export type NotificationDeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }

  export type $NotificationDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationDelivery"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string
      channel: $Enums.NotificationChannel
      status: $Enums.NotificationStatus
      deliveredAt: Date | null
      failureReason: string | null
      retryCount: number
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationDelivery"]>
    composites: {}
  }

  type NotificationDeliveryGetPayload<S extends boolean | null | undefined | NotificationDeliveryDefaultArgs> = $Result.GetResult<Prisma.$NotificationDeliveryPayload, S>

  type NotificationDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationDeliveryCountAggregateInputType | true
    }

  export interface NotificationDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationDelivery'], meta: { name: 'NotificationDelivery' } }
    /**
     * Find zero or one NotificationDelivery that matches the filter.
     * @param {NotificationDeliveryFindUniqueArgs} args - Arguments to find a NotificationDelivery
     * @example
     * // Get one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationDeliveryFindUniqueArgs>(args: SelectSubset<T, NotificationDeliveryFindUniqueArgs<ExtArgs>>): Prisma__NotificationDeliveryClient<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationDeliveryFindUniqueOrThrowArgs} args - Arguments to find a NotificationDelivery
     * @example
     * // Get one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationDeliveryClient<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryFindFirstArgs} args - Arguments to find a NotificationDelivery
     * @example
     * // Get one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationDeliveryFindFirstArgs>(args?: SelectSubset<T, NotificationDeliveryFindFirstArgs<ExtArgs>>): Prisma__NotificationDeliveryClient<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryFindFirstOrThrowArgs} args - Arguments to find a NotificationDelivery
     * @example
     * // Get one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationDeliveryClient<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationDeliveries
     * const notificationDeliveries = await prisma.notificationDelivery.findMany()
     * 
     * // Get first 10 NotificationDeliveries
     * const notificationDeliveries = await prisma.notificationDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationDeliveryWithIdOnly = await prisma.notificationDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationDeliveryFindManyArgs>(args?: SelectSubset<T, NotificationDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationDelivery.
     * @param {NotificationDeliveryCreateArgs} args - Arguments to create a NotificationDelivery.
     * @example
     * // Create one NotificationDelivery
     * const NotificationDelivery = await prisma.notificationDelivery.create({
     *   data: {
     *     // ... data to create a NotificationDelivery
     *   }
     * })
     * 
     */
    create<T extends NotificationDeliveryCreateArgs>(args: SelectSubset<T, NotificationDeliveryCreateArgs<ExtArgs>>): Prisma__NotificationDeliveryClient<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationDeliveries.
     * @param {NotificationDeliveryCreateManyArgs} args - Arguments to create many NotificationDeliveries.
     * @example
     * // Create many NotificationDeliveries
     * const notificationDelivery = await prisma.notificationDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationDeliveryCreateManyArgs>(args?: SelectSubset<T, NotificationDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationDeliveries and returns the data saved in the database.
     * @param {NotificationDeliveryCreateManyAndReturnArgs} args - Arguments to create many NotificationDeliveries.
     * @example
     * // Create many NotificationDeliveries
     * const notificationDelivery = await prisma.notificationDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationDeliveries and only return the `id`
     * const notificationDeliveryWithIdOnly = await prisma.notificationDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationDelivery.
     * @param {NotificationDeliveryDeleteArgs} args - Arguments to delete one NotificationDelivery.
     * @example
     * // Delete one NotificationDelivery
     * const NotificationDelivery = await prisma.notificationDelivery.delete({
     *   where: {
     *     // ... filter to delete one NotificationDelivery
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeliveryDeleteArgs>(args: SelectSubset<T, NotificationDeliveryDeleteArgs<ExtArgs>>): Prisma__NotificationDeliveryClient<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationDelivery.
     * @param {NotificationDeliveryUpdateArgs} args - Arguments to update one NotificationDelivery.
     * @example
     * // Update one NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationDeliveryUpdateArgs>(args: SelectSubset<T, NotificationDeliveryUpdateArgs<ExtArgs>>): Prisma__NotificationDeliveryClient<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationDeliveries.
     * @param {NotificationDeliveryDeleteManyArgs} args - Arguments to filter NotificationDeliveries to delete.
     * @example
     * // Delete a few NotificationDeliveries
     * const { count } = await prisma.notificationDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeliveryDeleteManyArgs>(args?: SelectSubset<T, NotificationDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationDeliveries
     * const notificationDelivery = await prisma.notificationDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationDeliveryUpdateManyArgs>(args: SelectSubset<T, NotificationDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationDeliveries and returns the data updated in the database.
     * @param {NotificationDeliveryUpdateManyAndReturnArgs} args - Arguments to update many NotificationDeliveries.
     * @example
     * // Update many NotificationDeliveries
     * const notificationDelivery = await prisma.notificationDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationDeliveries and only return the `id`
     * const notificationDeliveryWithIdOnly = await prisma.notificationDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationDeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationDeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationDelivery.
     * @param {NotificationDeliveryUpsertArgs} args - Arguments to update or create a NotificationDelivery.
     * @example
     * // Update or create a NotificationDelivery
     * const notificationDelivery = await prisma.notificationDelivery.upsert({
     *   create: {
     *     // ... data to create a NotificationDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationDelivery we want to update
     *   }
     * })
     */
    upsert<T extends NotificationDeliveryUpsertArgs>(args: SelectSubset<T, NotificationDeliveryUpsertArgs<ExtArgs>>): Prisma__NotificationDeliveryClient<$Result.GetResult<Prisma.$NotificationDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryCountArgs} args - Arguments to filter NotificationDeliveries to count.
     * @example
     * // Count the number of NotificationDeliveries
     * const count = await prisma.notificationDelivery.count({
     *   where: {
     *     // ... the filter for the NotificationDeliveries we want to count
     *   }
     * })
    **/
    count<T extends NotificationDeliveryCountArgs>(
      args?: Subset<T, NotificationDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationDeliveryAggregateArgs>(args: Subset<T, NotificationDeliveryAggregateArgs>): Prisma.PrismaPromise<GetNotificationDeliveryAggregateType<T>>

    /**
     * Group by NotificationDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: NotificationDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationDelivery model
   */
  readonly fields: NotificationDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationDelivery model
   */
  interface NotificationDeliveryFieldRefs {
    readonly id: FieldRef<"NotificationDelivery", 'String'>
    readonly notificationId: FieldRef<"NotificationDelivery", 'String'>
    readonly channel: FieldRef<"NotificationDelivery", 'NotificationChannel'>
    readonly status: FieldRef<"NotificationDelivery", 'NotificationStatus'>
    readonly deliveredAt: FieldRef<"NotificationDelivery", 'DateTime'>
    readonly failureReason: FieldRef<"NotificationDelivery", 'String'>
    readonly retryCount: FieldRef<"NotificationDelivery", 'Int'>
    readonly metadata: FieldRef<"NotificationDelivery", 'Json'>
    readonly createdAt: FieldRef<"NotificationDelivery", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationDelivery findUnique
   */
  export type NotificationDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDelivery to fetch.
     */
    where: NotificationDeliveryWhereUniqueInput
  }

  /**
   * NotificationDelivery findUniqueOrThrow
   */
  export type NotificationDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDelivery to fetch.
     */
    where: NotificationDeliveryWhereUniqueInput
  }

  /**
   * NotificationDelivery findFirst
   */
  export type NotificationDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDelivery to fetch.
     */
    where?: NotificationDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationDeliveries to fetch.
     */
    orderBy?: NotificationDeliveryOrderByWithRelationInput | NotificationDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationDeliveries.
     */
    cursor?: NotificationDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationDeliveries.
     */
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[]
  }

  /**
   * NotificationDelivery findFirstOrThrow
   */
  export type NotificationDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDelivery to fetch.
     */
    where?: NotificationDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationDeliveries to fetch.
     */
    orderBy?: NotificationDeliveryOrderByWithRelationInput | NotificationDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationDeliveries.
     */
    cursor?: NotificationDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationDeliveries.
     */
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[]
  }

  /**
   * NotificationDelivery findMany
   */
  export type NotificationDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDeliveries to fetch.
     */
    where?: NotificationDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationDeliveries to fetch.
     */
    orderBy?: NotificationDeliveryOrderByWithRelationInput | NotificationDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationDeliveries.
     */
    cursor?: NotificationDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationDeliveries.
     */
    skip?: number
    distinct?: NotificationDeliveryScalarFieldEnum | NotificationDeliveryScalarFieldEnum[]
  }

  /**
   * NotificationDelivery create
   */
  export type NotificationDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationDelivery.
     */
    data: XOR<NotificationDeliveryCreateInput, NotificationDeliveryUncheckedCreateInput>
  }

  /**
   * NotificationDelivery createMany
   */
  export type NotificationDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationDeliveries.
     */
    data: NotificationDeliveryCreateManyInput | NotificationDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationDelivery createManyAndReturn
   */
  export type NotificationDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationDeliveries.
     */
    data: NotificationDeliveryCreateManyInput | NotificationDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationDelivery update
   */
  export type NotificationDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationDelivery.
     */
    data: XOR<NotificationDeliveryUpdateInput, NotificationDeliveryUncheckedUpdateInput>
    /**
     * Choose, which NotificationDelivery to update.
     */
    where: NotificationDeliveryWhereUniqueInput
  }

  /**
   * NotificationDelivery updateMany
   */
  export type NotificationDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationDeliveries.
     */
    data: XOR<NotificationDeliveryUpdateManyMutationInput, NotificationDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which NotificationDeliveries to update
     */
    where?: NotificationDeliveryWhereInput
    /**
     * Limit how many NotificationDeliveries to update.
     */
    limit?: number
  }

  /**
   * NotificationDelivery updateManyAndReturn
   */
  export type NotificationDeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * The data used to update NotificationDeliveries.
     */
    data: XOR<NotificationDeliveryUpdateManyMutationInput, NotificationDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which NotificationDeliveries to update
     */
    where?: NotificationDeliveryWhereInput
    /**
     * Limit how many NotificationDeliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationDelivery upsert
   */
  export type NotificationDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationDelivery to update in case it exists.
     */
    where: NotificationDeliveryWhereUniqueInput
    /**
     * In case the NotificationDelivery found by the `where` argument doesn't exist, create a new NotificationDelivery with this data.
     */
    create: XOR<NotificationDeliveryCreateInput, NotificationDeliveryUncheckedCreateInput>
    /**
     * In case the NotificationDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationDeliveryUpdateInput, NotificationDeliveryUncheckedUpdateInput>
  }

  /**
   * NotificationDelivery delete
   */
  export type NotificationDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
    /**
     * Filter which NotificationDelivery to delete.
     */
    where: NotificationDeliveryWhereUniqueInput
  }

  /**
   * NotificationDelivery deleteMany
   */
  export type NotificationDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationDeliveries to delete
     */
    where?: NotificationDeliveryWhereInput
    /**
     * Limit how many NotificationDeliveries to delete.
     */
    limit?: number
  }

  /**
   * NotificationDelivery without action
   */
  export type NotificationDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDelivery
     */
    select?: NotificationDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDelivery
     */
    omit?: NotificationDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    budgetAlerts: number
    debtReminders: number
    zakatReminders: number
    priceAlerts: number
    transactionAlerts: number
    monthlyReports: number
    securityAlerts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    budgetAlerts?: true
    debtReminders?: true
    zakatReminders?: true
    priceAlerts?: true
    transactionAlerts?: true
    monthlyReports?: true
    securityAlerts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    budgetAlerts: JsonValue
    debtReminders: JsonValue
    zakatReminders: JsonValue
    priceAlerts: JsonValue
    transactionAlerts: JsonValue
    monthlyReports: JsonValue
    securityAlerts: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    budgetAlerts?: boolean
    debtReminders?: boolean
    zakatReminders?: boolean
    priceAlerts?: boolean
    transactionAlerts?: boolean
    monthlyReports?: boolean
    securityAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    budgetAlerts?: boolean
    debtReminders?: boolean
    zakatReminders?: boolean
    priceAlerts?: boolean
    transactionAlerts?: boolean
    monthlyReports?: boolean
    securityAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    budgetAlerts?: boolean
    debtReminders?: boolean
    zakatReminders?: boolean
    priceAlerts?: boolean
    transactionAlerts?: boolean
    monthlyReports?: boolean
    securityAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    budgetAlerts?: boolean
    debtReminders?: boolean
    zakatReminders?: boolean
    priceAlerts?: boolean
    transactionAlerts?: boolean
    monthlyReports?: boolean
    securityAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "budgetAlerts" | "debtReminders" | "zakatReminders" | "priceAlerts" | "transactionAlerts" | "monthlyReports" | "securityAlerts" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      budgetAlerts: Prisma.JsonValue
      debtReminders: Prisma.JsonValue
      zakatReminders: Prisma.JsonValue
      priceAlerts: Prisma.JsonValue
      transactionAlerts: Prisma.JsonValue
      monthlyReports: Prisma.JsonValue
      securityAlerts: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly budgetAlerts: FieldRef<"NotificationPreference", 'Json'>
    readonly debtReminders: FieldRef<"NotificationPreference", 'Json'>
    readonly zakatReminders: FieldRef<"NotificationPreference", 'Json'>
    readonly priceAlerts: FieldRef<"NotificationPreference", 'Json'>
    readonly transactionAlerts: FieldRef<"NotificationPreference", 'Json'>
    readonly monthlyReports: FieldRef<"NotificationPreference", 'Json'>
    readonly securityAlerts: FieldRef<"NotificationPreference", 'Json'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    userAgent: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    userAgent: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    endpoint: number
    p256dh: number
    auth: number
    userAgent: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PushSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "endpoint" | "p256dh" | "auth" | "userAgent" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["pushSubscription"]>
  export type PushSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      endpoint: string
      p256dh: string
      auth: string
      userAgent: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }

  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushSubscriptionFindManyArgs>(args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
     */
    create<T extends PushSubscriptionCreateArgs>(args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
     */
    delete<T extends PushSubscriptionDeleteArgs>(args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushSubscriptionUpdateArgs>(args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions and returns the data updated in the database.
     * @param {PushSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many PushSubscriptions.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PushSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushSubscription model
   */
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'String'>
    readonly userId: FieldRef<"PushSubscription", 'String'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly p256dh: FieldRef<"PushSubscription", 'String'>
    readonly auth: FieldRef<"PushSubscription", 'String'>
    readonly userAgent: FieldRef<"PushSubscription", 'String'>
    readonly isActive: FieldRef<"PushSubscription", 'Boolean'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
  }

  /**
   * PushSubscription updateManyAndReturn
   */
  export type PushSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.NotificationType | null
    subject: string | null
    htmlContent: string | null
    textContent: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.NotificationType | null
    subject: string | null
    htmlContent: string | null
    textContent: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    type: number
    subject: number
    htmlContent: number
    textContent: number
    variables: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subject?: true
    htmlContent?: true
    textContent?: true
    variables?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    type: $Enums.NotificationType
    subject: string
    htmlContent: string
    textContent: string
    variables: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    subject?: boolean
    htmlContent?: boolean
    textContent?: boolean
    variables?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "subject" | "htmlContent" | "textContent" | "variables" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["emailTemplate"]>

  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.NotificationType
      subject: string
      htmlContent: string
      textContent: string
      variables: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates and returns the data updated in the database.
     * @param {EmailTemplateUpdateManyAndReturnArgs} args - Arguments to update many EmailTemplates.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly type: FieldRef<"EmailTemplate", 'NotificationType'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly htmlContent: FieldRef<"EmailTemplate", 'String'>
    readonly textContent: FieldRef<"EmailTemplate", 'String'>
    readonly variables: FieldRef<"EmailTemplate", 'Json'>
    readonly isActive: FieldRef<"EmailTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate updateManyAndReturn
   */
  export type EmailTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to update.
     */
    limit?: number
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
    /**
     * Limit how many EmailTemplates to delete.
     */
    limit?: number
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTemplate
     */
    omit?: EmailTemplateOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    avatarUrl: 'avatarUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const HouseholdScalarFieldEnum: {
    id: 'id',
    name: 'name',
    baseCurrency: 'baseCurrency',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HouseholdScalarFieldEnum = (typeof HouseholdScalarFieldEnum)[keyof typeof HouseholdScalarFieldEnum]


  export const HouseholdMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    householdId: 'householdId',
    role: 'role',
    permissions: 'permissions',
    joinedAt: 'joinedAt'
  };

  export type HouseholdMemberScalarFieldEnum = (typeof HouseholdMemberScalarFieldEnum)[keyof typeof HouseholdMemberScalarFieldEnum]


  export const InstitutionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    logoUrl: 'logoUrl',
    country: 'country',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type InstitutionScalarFieldEnum = (typeof InstitutionScalarFieldEnum)[keyof typeof InstitutionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    name: 'name',
    type: 'type',
    subtype: 'subtype',
    currency: 'currency',
    institutionId: 'institutionId',
    accountNumber: 'accountNumber',
    balanceCents: 'balanceCents',
    isActive: 'isActive',
    ownerId: 'ownerId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const MerchantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logoUrl: 'logoUrl',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type MerchantScalarFieldEnum = (typeof MerchantScalarFieldEnum)[keyof typeof MerchantScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    icon: 'icon',
    color: 'color',
    type: 'type',
    parentId: 'parentId',
    householdId: 'householdId',
    isActive: 'isActive',
    isEditable: 'isEditable',
    isArchived: 'isArchived',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    amountCents: 'amountCents',
    currency: 'currency',
    originalAmountCents: 'originalAmountCents',
    originalCurrency: 'originalCurrency',
    exchangeRate: 'exchangeRate',
    description: 'description',
    categoryId: 'categoryId',
    merchant: 'merchant',
    merchantId: 'merchantId',
    merchantName: 'merchantName',
    merchantLogoUrl: 'merchantLogoUrl',
    merchantColor: 'merchantColor',
    date: 'date',
    accountId: 'accountId',
    transferAccountId: 'transferAccountId',
    receiptUrl: 'receiptUrl',
    metadata: 'metadata',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TransactionTagScalarFieldEnum: {
    transactionId: 'transactionId',
    tag: 'tag'
  };

  export type TransactionTagScalarFieldEnum = (typeof TransactionTagScalarFieldEnum)[keyof typeof TransactionTagScalarFieldEnum]


  export const TransactionSplitScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    categoryId: 'categoryId',
    amountCents: 'amountCents',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type TransactionSplitScalarFieldEnum = (typeof TransactionSplitScalarFieldEnum)[keyof typeof TransactionSplitScalarFieldEnum]


  export const LedgerEntryScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    accountId: 'accountId',
    type: 'type',
    amountCents: 'amountCents',
    currency: 'currency',
    createdAt: 'createdAt'
  };

  export type LedgerEntryScalarFieldEnum = (typeof LedgerEntryScalarFieldEnum)[keyof typeof LedgerEntryScalarFieldEnum]


  export const DebtScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    type: 'type',
    name: 'name',
    creditor: 'creditor',
    principalAmountCents: 'principalAmountCents',
    currentBalanceCents: 'currentBalanceCents',
    currency: 'currency',
    interestRate: 'interestRate',
    marginRate: 'marginRate',
    startDate: 'startDate',
    maturityDate: 'maturityDate',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DebtScalarFieldEnum = (typeof DebtScalarFieldEnum)[keyof typeof DebtScalarFieldEnum]


  export const DebtPaymentScalarFieldEnum: {
    id: 'id',
    debtId: 'debtId',
    amountCents: 'amountCents',
    currency: 'currency',
    paymentDate: 'paymentDate',
    principalAmountCents: 'principalAmountCents',
    interestAmountCents: 'interestAmountCents',
    transactionId: 'transactionId',
    createdAt: 'createdAt'
  };

  export type DebtPaymentScalarFieldEnum = (typeof DebtPaymentScalarFieldEnum)[keyof typeof DebtPaymentScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    name: 'name',
    period: 'period',
    totalAllocatedCents: 'totalAllocatedCents',
    currency: 'currency',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const BudgetCategoryScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    categoryId: 'categoryId',
    allocatedAmountCents: 'allocatedAmountCents',
    spentAmountCents: 'spentAmountCents',
    carryOverCents: 'carryOverCents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetCategoryScalarFieldEnum = (typeof BudgetCategoryScalarFieldEnum)[keyof typeof BudgetCategoryScalarFieldEnum]


  export const WishlistItemScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    name: 'name',
    url: 'url',
    currentPriceCents: 'currentPriceCents',
    targetPriceCents: 'targetPriceCents',
    currency: 'currency',
    imageUrl: 'imageUrl',
    merchant: 'merchant',
    linkedGoalId: 'linkedGoalId',
    isPurchased: 'isPurchased',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WishlistItemScalarFieldEnum = (typeof WishlistItemScalarFieldEnum)[keyof typeof WishlistItemScalarFieldEnum]


  export const PriceHistoryScalarFieldEnum: {
    id: 'id',
    wishlistItemId: 'wishlistItemId',
    priceCents: 'priceCents',
    currency: 'currency',
    recordedAt: 'recordedAt'
  };

  export type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]


  export const GratitudeEntryScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    giver: 'giver',
    type: 'type',
    categoryId: 'categoryId',
    transactionId: 'transactionId',
    estimatedValueCents: 'estimatedValueCents',
    currency: 'currency',
    description: 'description',
    date: 'date',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type GratitudeEntryScalarFieldEnum = (typeof GratitudeEntryScalarFieldEnum)[keyof typeof GratitudeEntryScalarFieldEnum]


  export const ExchangeRateScalarFieldEnum: {
    id: 'id',
    fromCurrency: 'fromCurrency',
    toCurrency: 'toCurrency',
    rate: 'rate',
    date: 'date',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type ExchangeRateScalarFieldEnum = (typeof ExchangeRateScalarFieldEnum)[keyof typeof ExchangeRateScalarFieldEnum]


  export const PasskeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    credentialId: 'credentialId',
    publicKey: 'publicKey',
    counter: 'counter',
    transports: 'transports',
    createdAt: 'createdAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type PasskeyScalarFieldEnum = (typeof PasskeyScalarFieldEnum)[keyof typeof PasskeyScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    householdId: 'householdId',
    eventType: 'eventType',
    eventData: 'eventData',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    sessionId: 'sessionId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    timestamp: 'timestamp'
  };

  export type UserEventScalarFieldEnum = (typeof UserEventScalarFieldEnum)[keyof typeof UserEventScalarFieldEnum]


  export const SpendingPatternScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    userId: 'userId',
    patternType: 'patternType',
    categoryId: 'categoryId',
    merchant: 'merchant',
    dayOfWeek: 'dayOfWeek',
    hourOfDay: 'hourOfDay',
    month: 'month',
    averageAmountCents: 'averageAmountCents',
    frequency: 'frequency',
    confidenceScore: 'confidenceScore',
    lastUpdated: 'lastUpdated'
  };

  export type SpendingPatternScalarFieldEnum = (typeof SpendingPatternScalarFieldEnum)[keyof typeof SpendingPatternScalarFieldEnum]


  export const FinancialInsightScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    insightType: 'insightType',
    title: 'title',
    description: 'description',
    data: 'data',
    priority: 'priority',
    isActionable: 'isActionable',
    isDismissed: 'isDismissed',
    validUntil: 'validUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinancialInsightScalarFieldEnum = (typeof FinancialInsightScalarFieldEnum)[keyof typeof FinancialInsightScalarFieldEnum]


  export const RecurringTransactionScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    name: 'name',
    description: 'description',
    amountCents: 'amountCents',
    currency: 'currency',
    accountId: 'accountId',
    transferAccountId: 'transferAccountId',
    categoryId: 'categoryId',
    merchant: 'merchant',
    frequency: 'frequency',
    intervalValue: 'intervalValue',
    startDate: 'startDate',
    endDate: 'endDate',
    nextExecutionDate: 'nextExecutionDate',
    lastExecutionDate: 'lastExecutionDate',
    executionCount: 'executionCount',
    maxExecutions: 'maxExecutions',
    status: 'status',
    metadata: 'metadata',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringTransactionScalarFieldEnum = (typeof RecurringTransactionScalarFieldEnum)[keyof typeof RecurringTransactionScalarFieldEnum]


  export const RecurringTransactionExecutionScalarFieldEnum: {
    id: 'id',
    recurringTransactionId: 'recurringTransactionId',
    transactionId: 'transactionId',
    scheduledDate: 'scheduledDate',
    executedDate: 'executedDate',
    status: 'status',
    errorMessage: 'errorMessage',
    retryCount: 'retryCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringTransactionExecutionScalarFieldEnum = (typeof RecurringTransactionExecutionScalarFieldEnum)[keyof typeof RecurringTransactionExecutionScalarFieldEnum]


  export const DocumentUploadScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    fileName: 'fileName',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    documentType: 'documentType',
    status: 'status',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    processedAt: 'processedAt',
    storageUrl: 'storageUrl',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentUploadScalarFieldEnum = (typeof DocumentUploadScalarFieldEnum)[keyof typeof DocumentUploadScalarFieldEnum]


  export const OcrResultScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    documentType: 'documentType',
    confidence: 'confidence',
    extractedData: 'extractedData',
    rawText: 'rawText',
    processedAt: 'processedAt',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type OcrResultScalarFieldEnum = (typeof OcrResultScalarFieldEnum)[keyof typeof OcrResultScalarFieldEnum]


  export const TransactionSuggestionScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    ocrResultId: 'ocrResultId',
    description: 'description',
    amountCents: 'amountCents',
    currency: 'currency',
    date: 'date',
    merchant: 'merchant',
    suggestedCategoryId: 'suggestedCategoryId',
    suggestedCategoryName: 'suggestedCategoryName',
    confidence: 'confidence',
    source: 'source',
    status: 'status',
    isApproved: 'isApproved',
    approvedAt: 'approvedAt',
    metadata: 'metadata',
    createdTransactionId: 'createdTransactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionSuggestionScalarFieldEnum = (typeof TransactionSuggestionScalarFieldEnum)[keyof typeof TransactionSuggestionScalarFieldEnum]


  export const ZakatCalculationScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    calculationDate: 'calculationDate',
    hijriYear: 'hijriYear',
    nisabThresholdCents: 'nisabThresholdCents',
    totalZakatableAssetsCents: 'totalZakatableAssetsCents',
    zakatAmountCents: 'zakatAmountCents',
    currency: 'currency',
    isZakatDue: 'isZakatDue',
    nextCalculationDate: 'nextCalculationDate',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZakatCalculationScalarFieldEnum = (typeof ZakatCalculationScalarFieldEnum)[keyof typeof ZakatCalculationScalarFieldEnum]


  export const ZakatAssetBreakdownScalarFieldEnum: {
    id: 'id',
    zakatCalculationId: 'zakatCalculationId',
    assetType: 'assetType',
    accountId: 'accountId',
    accountName: 'accountName',
    amountCents: 'amountCents',
    currency: 'currency',
    zakatRate: 'zakatRate',
    zakatAmountCents: 'zakatAmountCents',
    haulCompleted: 'haulCompleted',
    haulStartDate: 'haulStartDate',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ZakatAssetBreakdownScalarFieldEnum = (typeof ZakatAssetBreakdownScalarFieldEnum)[keyof typeof ZakatAssetBreakdownScalarFieldEnum]


  export const ZakatReminderScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    reminderType: 'reminderType',
    scheduledDate: 'scheduledDate',
    hijriDate: 'hijriDate',
    zakatAmountCents: 'zakatAmountCents',
    currency: 'currency',
    message: 'message',
    isActive: 'isActive',
    isSent: 'isSent',
    sentAt: 'sentAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZakatReminderScalarFieldEnum = (typeof ZakatReminderScalarFieldEnum)[keyof typeof ZakatReminderScalarFieldEnum]


  export const ZakatPaymentScalarFieldEnum: {
    id: 'id',
    zakatCalculationId: 'zakatCalculationId',
    householdId: 'householdId',
    amountCents: 'amountCents',
    currency: 'currency',
    paymentDate: 'paymentDate',
    hijriDate: 'hijriDate',
    transactionId: 'transactionId',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ZakatPaymentScalarFieldEnum = (typeof ZakatPaymentScalarFieldEnum)[keyof typeof ZakatPaymentScalarFieldEnum]


  export const ShariaCompliantAccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    complianceStatus: 'complianceStatus',
    complianceNotes: 'complianceNotes',
    lastReviewDate: 'lastReviewDate',
    nextReviewDate: 'nextReviewDate',
    reviewedBy: 'reviewedBy',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShariaCompliantAccountScalarFieldEnum = (typeof ShariaCompliantAccountScalarFieldEnum)[keyof typeof ShariaCompliantAccountScalarFieldEnum]


  export const IslamicFinanceReportScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    reportType: 'reportType',
    periodStartDate: 'periodStartDate',
    periodEndDate: 'periodEndDate',
    periodType: 'periodType',
    reportData: 'reportData',
    generatedAt: 'generatedAt',
    generatedBy: 'generatedBy',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type IslamicFinanceReportScalarFieldEnum = (typeof IslamicFinanceReportScalarFieldEnum)[keyof typeof IslamicFinanceReportScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    householdId: 'householdId',
    type: 'type',
    title: 'title',
    message: 'message',
    actionUrl: 'actionUrl',
    actionText: 'actionText',
    metadata: 'metadata',
    priority: 'priority',
    status: 'status',
    channels: 'channels',
    scheduledAt: 'scheduledAt',
    sentAt: 'sentAt',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationDeliveryScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    channel: 'channel',
    status: 'status',
    deliveredAt: 'deliveredAt',
    failureReason: 'failureReason',
    retryCount: 'retryCount',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationDeliveryScalarFieldEnum = (typeof NotificationDeliveryScalarFieldEnum)[keyof typeof NotificationDeliveryScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    budgetAlerts: 'budgetAlerts',
    debtReminders: 'debtReminders',
    zakatReminders: 'zakatReminders',
    priceAlerts: 'priceAlerts',
    transactionAlerts: 'transactionAlerts',
    monthlyReports: 'monthlyReports',
    securityAlerts: 'securityAlerts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    endpoint: 'endpoint',
    p256dh: 'p256dh',
    auth: 'auth',
    userAgent: 'userAgent',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    subject: 'subject',
    htmlContent: 'htmlContent',
    textContent: 'textContent',
    variables: 'variables',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'HouseholdRole'
   */
  export type EnumHouseholdRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HouseholdRole'>
    


  /**
   * Reference to a field of type 'HouseholdRole[]'
   */
  export type ListEnumHouseholdRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HouseholdRole[]'>
    


  /**
   * Reference to a field of type 'InstitutionType'
   */
  export type EnumInstitutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionType'>
    


  /**
   * Reference to a field of type 'InstitutionType[]'
   */
  export type ListEnumInstitutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionType[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'CategoryType'
   */
  export type EnumCategoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryType'>
    


  /**
   * Reference to a field of type 'CategoryType[]'
   */
  export type ListEnumCategoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LedgerType'
   */
  export type EnumLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerType'>
    


  /**
   * Reference to a field of type 'LedgerType[]'
   */
  export type ListEnumLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerType[]'>
    


  /**
   * Reference to a field of type 'DebtType'
   */
  export type EnumDebtTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebtType'>
    


  /**
   * Reference to a field of type 'DebtType[]'
   */
  export type ListEnumDebtTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebtType[]'>
    


  /**
   * Reference to a field of type 'BudgetPeriod'
   */
  export type EnumBudgetPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetPeriod'>
    


  /**
   * Reference to a field of type 'BudgetPeriod[]'
   */
  export type ListEnumBudgetPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetPeriod[]'>
    


  /**
   * Reference to a field of type 'GratitudeType'
   */
  export type EnumGratitudeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GratitudeType'>
    


  /**
   * Reference to a field of type 'GratitudeType[]'
   */
  export type ListEnumGratitudeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GratitudeType[]'>
    


  /**
   * Reference to a field of type 'InsightPriority'
   */
  export type EnumInsightPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightPriority'>
    


  /**
   * Reference to a field of type 'InsightPriority[]'
   */
  export type ListEnumInsightPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightPriority[]'>
    


  /**
   * Reference to a field of type 'RecurrenceFrequency'
   */
  export type EnumRecurrenceFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceFrequency'>
    


  /**
   * Reference to a field of type 'RecurrenceFrequency[]'
   */
  export type ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceFrequency[]'>
    


  /**
   * Reference to a field of type 'RecurringTransactionStatus'
   */
  export type EnumRecurringTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringTransactionStatus'>
    


  /**
   * Reference to a field of type 'RecurringTransactionStatus[]'
   */
  export type ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringTransactionStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'ProcessingStatus'
   */
  export type EnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus'>
    


  /**
   * Reference to a field of type 'ProcessingStatus[]'
   */
  export type ListEnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus[]'>
    


  /**
   * Reference to a field of type 'ZakatAssetType'
   */
  export type EnumZakatAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZakatAssetType'>
    


  /**
   * Reference to a field of type 'ZakatAssetType[]'
   */
  export type ListEnumZakatAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZakatAssetType[]'>
    


  /**
   * Reference to a field of type 'ZakatReminderType'
   */
  export type EnumZakatReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZakatReminderType'>
    


  /**
   * Reference to a field of type 'ZakatReminderType[]'
   */
  export type ListEnumZakatReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZakatReminderType[]'>
    


  /**
   * Reference to a field of type 'ShariaComplianceStatus'
   */
  export type EnumShariaComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShariaComplianceStatus'>
    


  /**
   * Reference to a field of type 'ShariaComplianceStatus[]'
   */
  export type ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShariaComplianceStatus[]'>
    


  /**
   * Reference to a field of type 'IslamicReportType'
   */
  export type EnumIslamicReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IslamicReportType'>
    


  /**
   * Reference to a field of type 'IslamicReportType[]'
   */
  export type ListEnumIslamicReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IslamicReportType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    householdMembers?: HouseholdMemberListRelationFilter
    passkeys?: PasskeyListRelationFilter
    sessions?: SessionListRelationFilter
    createdTransactions?: TransactionListRelationFilter
    createdWishlistItems?: WishlistItemListRelationFilter
    createdGratitudeEntries?: GratitudeEntryListRelationFilter
    createdRecurringTransactions?: RecurringTransactionListRelationFilter
    uploadedDocuments?: DocumentUploadListRelationFilter
    userEvents?: UserEventListRelationFilter
    shariaReviews?: ShariaCompliantAccountListRelationFilter
    generatedIslamicReports?: IslamicFinanceReportListRelationFilter
    notifications?: NotificationListRelationFilter
    notificationPreferences?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    pushSubscriptions?: PushSubscriptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    householdMembers?: HouseholdMemberOrderByRelationAggregateInput
    passkeys?: PasskeyOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    createdTransactions?: TransactionOrderByRelationAggregateInput
    createdWishlistItems?: WishlistItemOrderByRelationAggregateInput
    createdGratitudeEntries?: GratitudeEntryOrderByRelationAggregateInput
    createdRecurringTransactions?: RecurringTransactionOrderByRelationAggregateInput
    uploadedDocuments?: DocumentUploadOrderByRelationAggregateInput
    userEvents?: UserEventOrderByRelationAggregateInput
    shariaReviews?: ShariaCompliantAccountOrderByRelationAggregateInput
    generatedIslamicReports?: IslamicFinanceReportOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    notificationPreferences?: NotificationPreferenceOrderByWithRelationInput
    pushSubscriptions?: PushSubscriptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    householdMembers?: HouseholdMemberListRelationFilter
    passkeys?: PasskeyListRelationFilter
    sessions?: SessionListRelationFilter
    createdTransactions?: TransactionListRelationFilter
    createdWishlistItems?: WishlistItemListRelationFilter
    createdGratitudeEntries?: GratitudeEntryListRelationFilter
    createdRecurringTransactions?: RecurringTransactionListRelationFilter
    uploadedDocuments?: DocumentUploadListRelationFilter
    userEvents?: UserEventListRelationFilter
    shariaReviews?: ShariaCompliantAccountListRelationFilter
    generatedIslamicReports?: IslamicFinanceReportListRelationFilter
    notifications?: NotificationListRelationFilter
    notificationPreferences?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    pushSubscriptions?: PushSubscriptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type HouseholdWhereInput = {
    AND?: HouseholdWhereInput | HouseholdWhereInput[]
    OR?: HouseholdWhereInput[]
    NOT?: HouseholdWhereInput | HouseholdWhereInput[]
    id?: UuidFilter<"Household"> | string
    name?: StringFilter<"Household"> | string
    baseCurrency?: StringFilter<"Household"> | string
    settings?: JsonFilter<"Household">
    createdAt?: DateTimeFilter<"Household"> | Date | string
    updatedAt?: DateTimeFilter<"Household"> | Date | string
    members?: HouseholdMemberListRelationFilter
    accounts?: AccountListRelationFilter
    transactions?: TransactionListRelationFilter
    debts?: DebtListRelationFilter
    budgets?: BudgetListRelationFilter
    wishlistItems?: WishlistItemListRelationFilter
    gratitudeEntries?: GratitudeEntryListRelationFilter
    categories?: CategoryListRelationFilter
    recurringTransactions?: RecurringTransactionListRelationFilter
    documentUploads?: DocumentUploadListRelationFilter
    userEvents?: UserEventListRelationFilter
    spendingPatterns?: SpendingPatternListRelationFilter
    financialInsights?: FinancialInsightListRelationFilter
    zakatCalculations?: ZakatCalculationListRelationFilter
    zakatReminders?: ZakatReminderListRelationFilter
    zakatPayments?: ZakatPaymentListRelationFilter
    islamicFinanceReports?: IslamicFinanceReportListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type HouseholdOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: HouseholdMemberOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    debts?: DebtOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
    wishlistItems?: WishlistItemOrderByRelationAggregateInput
    gratitudeEntries?: GratitudeEntryOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    recurringTransactions?: RecurringTransactionOrderByRelationAggregateInput
    documentUploads?: DocumentUploadOrderByRelationAggregateInput
    userEvents?: UserEventOrderByRelationAggregateInput
    spendingPatterns?: SpendingPatternOrderByRelationAggregateInput
    financialInsights?: FinancialInsightOrderByRelationAggregateInput
    zakatCalculations?: ZakatCalculationOrderByRelationAggregateInput
    zakatReminders?: ZakatReminderOrderByRelationAggregateInput
    zakatPayments?: ZakatPaymentOrderByRelationAggregateInput
    islamicFinanceReports?: IslamicFinanceReportOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type HouseholdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HouseholdWhereInput | HouseholdWhereInput[]
    OR?: HouseholdWhereInput[]
    NOT?: HouseholdWhereInput | HouseholdWhereInput[]
    name?: StringFilter<"Household"> | string
    baseCurrency?: StringFilter<"Household"> | string
    settings?: JsonFilter<"Household">
    createdAt?: DateTimeFilter<"Household"> | Date | string
    updatedAt?: DateTimeFilter<"Household"> | Date | string
    members?: HouseholdMemberListRelationFilter
    accounts?: AccountListRelationFilter
    transactions?: TransactionListRelationFilter
    debts?: DebtListRelationFilter
    budgets?: BudgetListRelationFilter
    wishlistItems?: WishlistItemListRelationFilter
    gratitudeEntries?: GratitudeEntryListRelationFilter
    categories?: CategoryListRelationFilter
    recurringTransactions?: RecurringTransactionListRelationFilter
    documentUploads?: DocumentUploadListRelationFilter
    userEvents?: UserEventListRelationFilter
    spendingPatterns?: SpendingPatternListRelationFilter
    financialInsights?: FinancialInsightListRelationFilter
    zakatCalculations?: ZakatCalculationListRelationFilter
    zakatReminders?: ZakatReminderListRelationFilter
    zakatPayments?: ZakatPaymentListRelationFilter
    islamicFinanceReports?: IslamicFinanceReportListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type HouseholdOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HouseholdCountOrderByAggregateInput
    _max?: HouseholdMaxOrderByAggregateInput
    _min?: HouseholdMinOrderByAggregateInput
  }

  export type HouseholdScalarWhereWithAggregatesInput = {
    AND?: HouseholdScalarWhereWithAggregatesInput | HouseholdScalarWhereWithAggregatesInput[]
    OR?: HouseholdScalarWhereWithAggregatesInput[]
    NOT?: HouseholdScalarWhereWithAggregatesInput | HouseholdScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Household"> | string
    name?: StringWithAggregatesFilter<"Household"> | string
    baseCurrency?: StringWithAggregatesFilter<"Household"> | string
    settings?: JsonWithAggregatesFilter<"Household">
    createdAt?: DateTimeWithAggregatesFilter<"Household"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Household"> | Date | string
  }

  export type HouseholdMemberWhereInput = {
    AND?: HouseholdMemberWhereInput | HouseholdMemberWhereInput[]
    OR?: HouseholdMemberWhereInput[]
    NOT?: HouseholdMemberWhereInput | HouseholdMemberWhereInput[]
    id?: UuidFilter<"HouseholdMember"> | string
    userId?: UuidFilter<"HouseholdMember"> | string
    householdId?: UuidFilter<"HouseholdMember"> | string
    role?: EnumHouseholdRoleFilter<"HouseholdMember"> | $Enums.HouseholdRole
    permissions?: JsonFilter<"HouseholdMember">
    joinedAt?: DateTimeFilter<"HouseholdMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }

  export type HouseholdMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    household?: HouseholdOrderByWithRelationInput
  }

  export type HouseholdMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_householdId?: HouseholdMemberUserIdHouseholdIdCompoundUniqueInput
    AND?: HouseholdMemberWhereInput | HouseholdMemberWhereInput[]
    OR?: HouseholdMemberWhereInput[]
    NOT?: HouseholdMemberWhereInput | HouseholdMemberWhereInput[]
    userId?: UuidFilter<"HouseholdMember"> | string
    householdId?: UuidFilter<"HouseholdMember"> | string
    role?: EnumHouseholdRoleFilter<"HouseholdMember"> | $Enums.HouseholdRole
    permissions?: JsonFilter<"HouseholdMember">
    joinedAt?: DateTimeFilter<"HouseholdMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }, "id" | "userId_householdId">

  export type HouseholdMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    _count?: HouseholdMemberCountOrderByAggregateInput
    _max?: HouseholdMemberMaxOrderByAggregateInput
    _min?: HouseholdMemberMinOrderByAggregateInput
  }

  export type HouseholdMemberScalarWhereWithAggregatesInput = {
    AND?: HouseholdMemberScalarWhereWithAggregatesInput | HouseholdMemberScalarWhereWithAggregatesInput[]
    OR?: HouseholdMemberScalarWhereWithAggregatesInput[]
    NOT?: HouseholdMemberScalarWhereWithAggregatesInput | HouseholdMemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"HouseholdMember"> | string
    userId?: UuidWithAggregatesFilter<"HouseholdMember"> | string
    householdId?: UuidWithAggregatesFilter<"HouseholdMember"> | string
    role?: EnumHouseholdRoleWithAggregatesFilter<"HouseholdMember"> | $Enums.HouseholdRole
    permissions?: JsonWithAggregatesFilter<"HouseholdMember">
    joinedAt?: DateTimeWithAggregatesFilter<"HouseholdMember"> | Date | string
  }

  export type InstitutionWhereInput = {
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    id?: UuidFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    code?: StringNullableFilter<"Institution"> | string | null
    logoUrl?: StringNullableFilter<"Institution"> | string | null
    country?: StringFilter<"Institution"> | string
    type?: EnumInstitutionTypeFilter<"Institution"> | $Enums.InstitutionType
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    accounts?: AccountListRelationFilter
  }

  export type InstitutionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    country?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
  }

  export type InstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    name?: StringFilter<"Institution"> | string
    logoUrl?: StringNullableFilter<"Institution"> | string | null
    country?: StringFilter<"Institution"> | string
    type?: EnumInstitutionTypeFilter<"Institution"> | $Enums.InstitutionType
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    accounts?: AccountListRelationFilter
  }, "id" | "code">

  export type InstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    country?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: InstitutionCountOrderByAggregateInput
    _max?: InstitutionMaxOrderByAggregateInput
    _min?: InstitutionMinOrderByAggregateInput
  }

  export type InstitutionScalarWhereWithAggregatesInput = {
    AND?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    OR?: InstitutionScalarWhereWithAggregatesInput[]
    NOT?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Institution"> | string
    name?: StringWithAggregatesFilter<"Institution"> | string
    code?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    country?: StringWithAggregatesFilter<"Institution"> | string
    type?: EnumInstitutionTypeWithAggregatesFilter<"Institution"> | $Enums.InstitutionType
    createdAt?: DateTimeWithAggregatesFilter<"Institution"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: UuidFilter<"Account"> | string
    householdId?: UuidFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    subtype?: StringFilter<"Account"> | string
    currency?: StringFilter<"Account"> | string
    institutionId?: UuidNullableFilter<"Account"> | string | null
    accountNumber?: StringNullableFilter<"Account"> | string | null
    balanceCents?: BigIntFilter<"Account"> | bigint | number
    isActive?: BoolFilter<"Account"> | boolean
    ownerId?: UuidNullableFilter<"Account"> | string | null
    metadata?: JsonFilter<"Account">
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    transactions?: TransactionListRelationFilter
    transferTransactions?: TransactionListRelationFilter
    recurringTransactions?: RecurringTransactionListRelationFilter
    recurringTransferTransactions?: RecurringTransactionListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    zakatAssetBreakdown?: ZakatAssetBreakdownListRelationFilter
    shariaCompliance?: XOR<ShariaCompliantAccountNullableScalarRelationFilter, ShariaCompliantAccountWhereInput> | null
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    currency?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    balanceCents?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    transferTransactions?: TransactionOrderByRelationAggregateInput
    recurringTransactions?: RecurringTransactionOrderByRelationAggregateInput
    recurringTransferTransactions?: RecurringTransactionOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    zakatAssetBreakdown?: ZakatAssetBreakdownOrderByRelationAggregateInput
    shariaCompliance?: ShariaCompliantAccountOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    householdId?: UuidFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    subtype?: StringFilter<"Account"> | string
    currency?: StringFilter<"Account"> | string
    institutionId?: UuidNullableFilter<"Account"> | string | null
    accountNumber?: StringNullableFilter<"Account"> | string | null
    balanceCents?: BigIntFilter<"Account"> | bigint | number
    isActive?: BoolFilter<"Account"> | boolean
    ownerId?: UuidNullableFilter<"Account"> | string | null
    metadata?: JsonFilter<"Account">
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    transactions?: TransactionListRelationFilter
    transferTransactions?: TransactionListRelationFilter
    recurringTransactions?: RecurringTransactionListRelationFilter
    recurringTransferTransactions?: RecurringTransactionListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    zakatAssetBreakdown?: ZakatAssetBreakdownListRelationFilter
    shariaCompliance?: XOR<ShariaCompliantAccountNullableScalarRelationFilter, ShariaCompliantAccountWhereInput> | null
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    currency?: SortOrder
    institutionId?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    balanceCents?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Account"> | string
    householdId?: UuidWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    type?: EnumAccountTypeWithAggregatesFilter<"Account"> | $Enums.AccountType
    subtype?: StringWithAggregatesFilter<"Account"> | string
    currency?: StringWithAggregatesFilter<"Account"> | string
    institutionId?: UuidNullableWithAggregatesFilter<"Account"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"Account"> | string | null
    balanceCents?: BigIntWithAggregatesFilter<"Account"> | bigint | number
    isActive?: BoolWithAggregatesFilter<"Account"> | boolean
    ownerId?: UuidNullableWithAggregatesFilter<"Account"> | string | null
    metadata?: JsonWithAggregatesFilter<"Account">
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type MerchantWhereInput = {
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    id?: UuidFilter<"Merchant"> | string
    name?: StringFilter<"Merchant"> | string
    slug?: StringFilter<"Merchant"> | string
    logoUrl?: StringNullableFilter<"Merchant"> | string | null
    color?: StringNullableFilter<"Merchant"> | string | null
    createdAt?: DateTimeFilter<"Merchant"> | Date | string
    transactions?: TransactionListRelationFilter
  }

  export type MerchantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type MerchantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    name?: StringFilter<"Merchant"> | string
    logoUrl?: StringNullableFilter<"Merchant"> | string | null
    color?: StringNullableFilter<"Merchant"> | string | null
    createdAt?: DateTimeFilter<"Merchant"> | Date | string
    transactions?: TransactionListRelationFilter
  }, "id" | "slug">

  export type MerchantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MerchantCountOrderByAggregateInput
    _max?: MerchantMaxOrderByAggregateInput
    _min?: MerchantMinOrderByAggregateInput
  }

  export type MerchantScalarWhereWithAggregatesInput = {
    AND?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    OR?: MerchantScalarWhereWithAggregatesInput[]
    NOT?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Merchant"> | string
    name?: StringWithAggregatesFilter<"Merchant"> | string
    slug?: StringWithAggregatesFilter<"Merchant"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    color?: StringNullableWithAggregatesFilter<"Merchant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Merchant"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: UuidFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    parentId?: UuidNullableFilter<"Category"> | string | null
    householdId?: UuidNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    isEditable?: BoolFilter<"Category"> | boolean
    isArchived?: BoolFilter<"Category"> | boolean
    sortOrder?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    household?: XOR<HouseholdNullableScalarRelationFilter, HouseholdWhereInput> | null
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    transactions?: TransactionListRelationFilter
    transactionSplits?: TransactionSplitListRelationFilter
    budgetCategories?: BudgetCategoryListRelationFilter
    recurringTransactions?: RecurringTransactionListRelationFilter
    gratitudeEntries?: GratitudeEntryListRelationFilter
    transactionSuggestions?: TransactionSuggestionListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    type?: SortOrder
    parentId?: SortOrderInput | SortOrder
    householdId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isEditable?: SortOrder
    isArchived?: SortOrder
    sortOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    transactionSplits?: TransactionSplitOrderByRelationAggregateInput
    budgetCategories?: BudgetCategoryOrderByRelationAggregateInput
    recurringTransactions?: RecurringTransactionOrderByRelationAggregateInput
    gratitudeEntries?: GratitudeEntryOrderByRelationAggregateInput
    transactionSuggestions?: TransactionSuggestionOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    householdId_slug?: CategoryHouseholdIdSlugCompoundUniqueInput
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    parentId?: UuidNullableFilter<"Category"> | string | null
    householdId?: UuidNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    isEditable?: BoolFilter<"Category"> | boolean
    isArchived?: BoolFilter<"Category"> | boolean
    sortOrder?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    household?: XOR<HouseholdNullableScalarRelationFilter, HouseholdWhereInput> | null
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    transactions?: TransactionListRelationFilter
    transactionSplits?: TransactionSplitListRelationFilter
    budgetCategories?: BudgetCategoryListRelationFilter
    recurringTransactions?: RecurringTransactionListRelationFilter
    gratitudeEntries?: GratitudeEntryListRelationFilter
    transactionSuggestions?: TransactionSuggestionListRelationFilter
  }, "id" | "householdId_slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    type?: SortOrder
    parentId?: SortOrderInput | SortOrder
    householdId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isEditable?: SortOrder
    isArchived?: SortOrder
    sortOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    color?: StringNullableWithAggregatesFilter<"Category"> | string | null
    type?: EnumCategoryTypeWithAggregatesFilter<"Category"> | $Enums.CategoryType
    parentId?: UuidNullableWithAggregatesFilter<"Category"> | string | null
    householdId?: UuidNullableWithAggregatesFilter<"Category"> | string | null
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    isEditable?: BoolWithAggregatesFilter<"Category"> | boolean
    isArchived?: BoolWithAggregatesFilter<"Category"> | boolean
    sortOrder?: IntNullableWithAggregatesFilter<"Category"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: UuidFilter<"Transaction"> | string
    householdId?: UuidFilter<"Transaction"> | string
    amountCents?: BigIntFilter<"Transaction"> | bigint | number
    currency?: StringFilter<"Transaction"> | string
    originalAmountCents?: BigIntNullableFilter<"Transaction"> | bigint | number | null
    originalCurrency?: StringNullableFilter<"Transaction"> | string | null
    exchangeRate?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    description?: StringFilter<"Transaction"> | string
    categoryId?: UuidNullableFilter<"Transaction"> | string | null
    merchant?: StringNullableFilter<"Transaction"> | string | null
    merchantId?: UuidNullableFilter<"Transaction"> | string | null
    merchantName?: StringNullableFilter<"Transaction"> | string | null
    merchantLogoUrl?: StringNullableFilter<"Transaction"> | string | null
    merchantColor?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    accountId?: UuidFilter<"Transaction"> | string
    transferAccountId?: UuidNullableFilter<"Transaction"> | string | null
    receiptUrl?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonFilter<"Transaction">
    createdBy?: UuidFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    transferAccount?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    merchantData?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    tags?: TransactionTagListRelationFilter
    splits?: TransactionSplitListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    recurringTransactionExecutions?: RecurringTransactionExecutionListRelationFilter
    gratitudeEntries?: GratitudeEntryListRelationFilter
    createdFromSuggestion?: TransactionSuggestionListRelationFilter
    zakatPayments?: ZakatPaymentListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    originalAmountCents?: SortOrderInput | SortOrder
    originalCurrency?: SortOrderInput | SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    description?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    merchant?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    merchantName?: SortOrderInput | SortOrder
    merchantLogoUrl?: SortOrderInput | SortOrder
    merchantColor?: SortOrderInput | SortOrder
    date?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    transferAccount?: AccountOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    merchantData?: MerchantOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    tags?: TransactionTagOrderByRelationAggregateInput
    splits?: TransactionSplitOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    recurringTransactionExecutions?: RecurringTransactionExecutionOrderByRelationAggregateInput
    gratitudeEntries?: GratitudeEntryOrderByRelationAggregateInput
    createdFromSuggestion?: TransactionSuggestionOrderByRelationAggregateInput
    zakatPayments?: ZakatPaymentOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    householdId?: UuidFilter<"Transaction"> | string
    amountCents?: BigIntFilter<"Transaction"> | bigint | number
    currency?: StringFilter<"Transaction"> | string
    originalAmountCents?: BigIntNullableFilter<"Transaction"> | bigint | number | null
    originalCurrency?: StringNullableFilter<"Transaction"> | string | null
    exchangeRate?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    description?: StringFilter<"Transaction"> | string
    categoryId?: UuidNullableFilter<"Transaction"> | string | null
    merchant?: StringNullableFilter<"Transaction"> | string | null
    merchantId?: UuidNullableFilter<"Transaction"> | string | null
    merchantName?: StringNullableFilter<"Transaction"> | string | null
    merchantLogoUrl?: StringNullableFilter<"Transaction"> | string | null
    merchantColor?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    accountId?: UuidFilter<"Transaction"> | string
    transferAccountId?: UuidNullableFilter<"Transaction"> | string | null
    receiptUrl?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonFilter<"Transaction">
    createdBy?: UuidFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    transferAccount?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    merchantData?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    tags?: TransactionTagListRelationFilter
    splits?: TransactionSplitListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    recurringTransactionExecutions?: RecurringTransactionExecutionListRelationFilter
    gratitudeEntries?: GratitudeEntryListRelationFilter
    createdFromSuggestion?: TransactionSuggestionListRelationFilter
    zakatPayments?: ZakatPaymentListRelationFilter
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    originalAmountCents?: SortOrderInput | SortOrder
    originalCurrency?: SortOrderInput | SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    description?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    merchant?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    merchantName?: SortOrderInput | SortOrder
    merchantLogoUrl?: SortOrderInput | SortOrder
    merchantColor?: SortOrderInput | SortOrder
    date?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Transaction"> | string
    householdId?: UuidWithAggregatesFilter<"Transaction"> | string
    amountCents?: BigIntWithAggregatesFilter<"Transaction"> | bigint | number
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    originalAmountCents?: BigIntNullableWithAggregatesFilter<"Transaction"> | bigint | number | null
    originalCurrency?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    exchangeRate?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    description?: StringWithAggregatesFilter<"Transaction"> | string
    categoryId?: UuidNullableWithAggregatesFilter<"Transaction"> | string | null
    merchant?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    merchantId?: UuidNullableWithAggregatesFilter<"Transaction"> | string | null
    merchantName?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    merchantLogoUrl?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    merchantColor?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    accountId?: UuidWithAggregatesFilter<"Transaction"> | string
    transferAccountId?: UuidNullableWithAggregatesFilter<"Transaction"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: JsonWithAggregatesFilter<"Transaction">
    createdBy?: UuidWithAggregatesFilter<"Transaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TransactionTagWhereInput = {
    AND?: TransactionTagWhereInput | TransactionTagWhereInput[]
    OR?: TransactionTagWhereInput[]
    NOT?: TransactionTagWhereInput | TransactionTagWhereInput[]
    transactionId?: UuidFilter<"TransactionTag"> | string
    tag?: StringFilter<"TransactionTag"> | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type TransactionTagOrderByWithRelationInput = {
    transactionId?: SortOrder
    tag?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type TransactionTagWhereUniqueInput = Prisma.AtLeast<{
    transactionId_tag?: TransactionTagTransactionIdTagCompoundUniqueInput
    AND?: TransactionTagWhereInput | TransactionTagWhereInput[]
    OR?: TransactionTagWhereInput[]
    NOT?: TransactionTagWhereInput | TransactionTagWhereInput[]
    transactionId?: UuidFilter<"TransactionTag"> | string
    tag?: StringFilter<"TransactionTag"> | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "transactionId_tag">

  export type TransactionTagOrderByWithAggregationInput = {
    transactionId?: SortOrder
    tag?: SortOrder
    _count?: TransactionTagCountOrderByAggregateInput
    _max?: TransactionTagMaxOrderByAggregateInput
    _min?: TransactionTagMinOrderByAggregateInput
  }

  export type TransactionTagScalarWhereWithAggregatesInput = {
    AND?: TransactionTagScalarWhereWithAggregatesInput | TransactionTagScalarWhereWithAggregatesInput[]
    OR?: TransactionTagScalarWhereWithAggregatesInput[]
    NOT?: TransactionTagScalarWhereWithAggregatesInput | TransactionTagScalarWhereWithAggregatesInput[]
    transactionId?: UuidWithAggregatesFilter<"TransactionTag"> | string
    tag?: StringWithAggregatesFilter<"TransactionTag"> | string
  }

  export type TransactionSplitWhereInput = {
    AND?: TransactionSplitWhereInput | TransactionSplitWhereInput[]
    OR?: TransactionSplitWhereInput[]
    NOT?: TransactionSplitWhereInput | TransactionSplitWhereInput[]
    id?: UuidFilter<"TransactionSplit"> | string
    transactionId?: UuidFilter<"TransactionSplit"> | string
    categoryId?: UuidFilter<"TransactionSplit"> | string
    amountCents?: BigIntFilter<"TransactionSplit"> | bigint | number
    description?: StringNullableFilter<"TransactionSplit"> | string | null
    createdAt?: DateTimeFilter<"TransactionSplit"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type TransactionSplitOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    categoryId?: SortOrder
    amountCents?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type TransactionSplitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionSplitWhereInput | TransactionSplitWhereInput[]
    OR?: TransactionSplitWhereInput[]
    NOT?: TransactionSplitWhereInput | TransactionSplitWhereInput[]
    transactionId?: UuidFilter<"TransactionSplit"> | string
    categoryId?: UuidFilter<"TransactionSplit"> | string
    amountCents?: BigIntFilter<"TransactionSplit"> | bigint | number
    description?: StringNullableFilter<"TransactionSplit"> | string | null
    createdAt?: DateTimeFilter<"TransactionSplit"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id">

  export type TransactionSplitOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    categoryId?: SortOrder
    amountCents?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransactionSplitCountOrderByAggregateInput
    _avg?: TransactionSplitAvgOrderByAggregateInput
    _max?: TransactionSplitMaxOrderByAggregateInput
    _min?: TransactionSplitMinOrderByAggregateInput
    _sum?: TransactionSplitSumOrderByAggregateInput
  }

  export type TransactionSplitScalarWhereWithAggregatesInput = {
    AND?: TransactionSplitScalarWhereWithAggregatesInput | TransactionSplitScalarWhereWithAggregatesInput[]
    OR?: TransactionSplitScalarWhereWithAggregatesInput[]
    NOT?: TransactionSplitScalarWhereWithAggregatesInput | TransactionSplitScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TransactionSplit"> | string
    transactionId?: UuidWithAggregatesFilter<"TransactionSplit"> | string
    categoryId?: UuidWithAggregatesFilter<"TransactionSplit"> | string
    amountCents?: BigIntWithAggregatesFilter<"TransactionSplit"> | bigint | number
    description?: StringNullableWithAggregatesFilter<"TransactionSplit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionSplit"> | Date | string
  }

  export type LedgerEntryWhereInput = {
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    id?: UuidFilter<"LedgerEntry"> | string
    transactionId?: UuidFilter<"LedgerEntry"> | string
    accountId?: UuidFilter<"LedgerEntry"> | string
    type?: EnumLedgerTypeFilter<"LedgerEntry"> | $Enums.LedgerType
    amountCents?: BigIntFilter<"LedgerEntry"> | bigint | number
    currency?: StringFilter<"LedgerEntry"> | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type LedgerEntryOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
  }

  export type LedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    transactionId?: UuidFilter<"LedgerEntry"> | string
    accountId?: UuidFilter<"LedgerEntry"> | string
    type?: EnumLedgerTypeFilter<"LedgerEntry"> | $Enums.LedgerType
    amountCents?: BigIntFilter<"LedgerEntry"> | bigint | number
    currency?: StringFilter<"LedgerEntry"> | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id">

  export type LedgerEntryOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    _count?: LedgerEntryCountOrderByAggregateInput
    _avg?: LedgerEntryAvgOrderByAggregateInput
    _max?: LedgerEntryMaxOrderByAggregateInput
    _min?: LedgerEntryMinOrderByAggregateInput
    _sum?: LedgerEntrySumOrderByAggregateInput
  }

  export type LedgerEntryScalarWhereWithAggregatesInput = {
    AND?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    OR?: LedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LedgerEntry"> | string
    transactionId?: UuidWithAggregatesFilter<"LedgerEntry"> | string
    accountId?: UuidWithAggregatesFilter<"LedgerEntry"> | string
    type?: EnumLedgerTypeWithAggregatesFilter<"LedgerEntry"> | $Enums.LedgerType
    amountCents?: BigIntWithAggregatesFilter<"LedgerEntry"> | bigint | number
    currency?: StringWithAggregatesFilter<"LedgerEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LedgerEntry"> | Date | string
  }

  export type DebtWhereInput = {
    AND?: DebtWhereInput | DebtWhereInput[]
    OR?: DebtWhereInput[]
    NOT?: DebtWhereInput | DebtWhereInput[]
    id?: UuidFilter<"Debt"> | string
    householdId?: UuidFilter<"Debt"> | string
    type?: EnumDebtTypeFilter<"Debt"> | $Enums.DebtType
    name?: StringFilter<"Debt"> | string
    creditor?: StringFilter<"Debt"> | string
    principalAmountCents?: BigIntFilter<"Debt"> | bigint | number
    currentBalanceCents?: BigIntFilter<"Debt"> | bigint | number
    currency?: StringFilter<"Debt"> | string
    interestRate?: DecimalNullableFilter<"Debt"> | Decimal | DecimalJsLike | number | string | null
    marginRate?: DecimalNullableFilter<"Debt"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFilter<"Debt"> | Date | string
    maturityDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    isActive?: BoolFilter<"Debt"> | boolean
    metadata?: JsonFilter<"Debt">
    createdAt?: DateTimeFilter<"Debt"> | Date | string
    updatedAt?: DateTimeFilter<"Debt"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    payments?: DebtPaymentListRelationFilter
  }

  export type DebtOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    creditor?: SortOrder
    principalAmountCents?: SortOrder
    currentBalanceCents?: SortOrder
    currency?: SortOrder
    interestRate?: SortOrderInput | SortOrder
    marginRate?: SortOrderInput | SortOrder
    startDate?: SortOrder
    maturityDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    payments?: DebtPaymentOrderByRelationAggregateInput
  }

  export type DebtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DebtWhereInput | DebtWhereInput[]
    OR?: DebtWhereInput[]
    NOT?: DebtWhereInput | DebtWhereInput[]
    householdId?: UuidFilter<"Debt"> | string
    type?: EnumDebtTypeFilter<"Debt"> | $Enums.DebtType
    name?: StringFilter<"Debt"> | string
    creditor?: StringFilter<"Debt"> | string
    principalAmountCents?: BigIntFilter<"Debt"> | bigint | number
    currentBalanceCents?: BigIntFilter<"Debt"> | bigint | number
    currency?: StringFilter<"Debt"> | string
    interestRate?: DecimalNullableFilter<"Debt"> | Decimal | DecimalJsLike | number | string | null
    marginRate?: DecimalNullableFilter<"Debt"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFilter<"Debt"> | Date | string
    maturityDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    isActive?: BoolFilter<"Debt"> | boolean
    metadata?: JsonFilter<"Debt">
    createdAt?: DateTimeFilter<"Debt"> | Date | string
    updatedAt?: DateTimeFilter<"Debt"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    payments?: DebtPaymentListRelationFilter
  }, "id">

  export type DebtOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    creditor?: SortOrder
    principalAmountCents?: SortOrder
    currentBalanceCents?: SortOrder
    currency?: SortOrder
    interestRate?: SortOrderInput | SortOrder
    marginRate?: SortOrderInput | SortOrder
    startDate?: SortOrder
    maturityDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DebtCountOrderByAggregateInput
    _avg?: DebtAvgOrderByAggregateInput
    _max?: DebtMaxOrderByAggregateInput
    _min?: DebtMinOrderByAggregateInput
    _sum?: DebtSumOrderByAggregateInput
  }

  export type DebtScalarWhereWithAggregatesInput = {
    AND?: DebtScalarWhereWithAggregatesInput | DebtScalarWhereWithAggregatesInput[]
    OR?: DebtScalarWhereWithAggregatesInput[]
    NOT?: DebtScalarWhereWithAggregatesInput | DebtScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Debt"> | string
    householdId?: UuidWithAggregatesFilter<"Debt"> | string
    type?: EnumDebtTypeWithAggregatesFilter<"Debt"> | $Enums.DebtType
    name?: StringWithAggregatesFilter<"Debt"> | string
    creditor?: StringWithAggregatesFilter<"Debt"> | string
    principalAmountCents?: BigIntWithAggregatesFilter<"Debt"> | bigint | number
    currentBalanceCents?: BigIntWithAggregatesFilter<"Debt"> | bigint | number
    currency?: StringWithAggregatesFilter<"Debt"> | string
    interestRate?: DecimalNullableWithAggregatesFilter<"Debt"> | Decimal | DecimalJsLike | number | string | null
    marginRate?: DecimalNullableWithAggregatesFilter<"Debt"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeWithAggregatesFilter<"Debt"> | Date | string
    maturityDate?: DateTimeNullableWithAggregatesFilter<"Debt"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Debt"> | boolean
    metadata?: JsonWithAggregatesFilter<"Debt">
    createdAt?: DateTimeWithAggregatesFilter<"Debt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Debt"> | Date | string
  }

  export type DebtPaymentWhereInput = {
    AND?: DebtPaymentWhereInput | DebtPaymentWhereInput[]
    OR?: DebtPaymentWhereInput[]
    NOT?: DebtPaymentWhereInput | DebtPaymentWhereInput[]
    id?: UuidFilter<"DebtPayment"> | string
    debtId?: UuidFilter<"DebtPayment"> | string
    amountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    currency?: StringFilter<"DebtPayment"> | string
    paymentDate?: DateTimeFilter<"DebtPayment"> | Date | string
    principalAmountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    interestAmountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    transactionId?: UuidNullableFilter<"DebtPayment"> | string | null
    createdAt?: DateTimeFilter<"DebtPayment"> | Date | string
    debt?: XOR<DebtScalarRelationFilter, DebtWhereInput>
  }

  export type DebtPaymentOrderByWithRelationInput = {
    id?: SortOrder
    debtId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    principalAmountCents?: SortOrder
    interestAmountCents?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    debt?: DebtOrderByWithRelationInput
  }

  export type DebtPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DebtPaymentWhereInput | DebtPaymentWhereInput[]
    OR?: DebtPaymentWhereInput[]
    NOT?: DebtPaymentWhereInput | DebtPaymentWhereInput[]
    debtId?: UuidFilter<"DebtPayment"> | string
    amountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    currency?: StringFilter<"DebtPayment"> | string
    paymentDate?: DateTimeFilter<"DebtPayment"> | Date | string
    principalAmountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    interestAmountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    transactionId?: UuidNullableFilter<"DebtPayment"> | string | null
    createdAt?: DateTimeFilter<"DebtPayment"> | Date | string
    debt?: XOR<DebtScalarRelationFilter, DebtWhereInput>
  }, "id">

  export type DebtPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    debtId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    principalAmountCents?: SortOrder
    interestAmountCents?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DebtPaymentCountOrderByAggregateInput
    _avg?: DebtPaymentAvgOrderByAggregateInput
    _max?: DebtPaymentMaxOrderByAggregateInput
    _min?: DebtPaymentMinOrderByAggregateInput
    _sum?: DebtPaymentSumOrderByAggregateInput
  }

  export type DebtPaymentScalarWhereWithAggregatesInput = {
    AND?: DebtPaymentScalarWhereWithAggregatesInput | DebtPaymentScalarWhereWithAggregatesInput[]
    OR?: DebtPaymentScalarWhereWithAggregatesInput[]
    NOT?: DebtPaymentScalarWhereWithAggregatesInput | DebtPaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DebtPayment"> | string
    debtId?: UuidWithAggregatesFilter<"DebtPayment"> | string
    amountCents?: BigIntWithAggregatesFilter<"DebtPayment"> | bigint | number
    currency?: StringWithAggregatesFilter<"DebtPayment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"DebtPayment"> | Date | string
    principalAmountCents?: BigIntWithAggregatesFilter<"DebtPayment"> | bigint | number
    interestAmountCents?: BigIntWithAggregatesFilter<"DebtPayment"> | bigint | number
    transactionId?: UuidNullableWithAggregatesFilter<"DebtPayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DebtPayment"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: UuidFilter<"Budget"> | string
    householdId?: UuidFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFilter<"Budget"> | bigint | number
    currency?: StringFilter<"Budget"> | string
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeFilter<"Budget"> | Date | string
    isActive?: BoolFilter<"Budget"> | boolean
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    categories?: BudgetCategoryListRelationFilter
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    period?: SortOrder
    totalAllocatedCents?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    categories?: BudgetCategoryOrderByRelationAggregateInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    householdId?: UuidFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFilter<"Budget"> | bigint | number
    currency?: StringFilter<"Budget"> | string
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeFilter<"Budget"> | Date | string
    isActive?: BoolFilter<"Budget"> | boolean
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    categories?: BudgetCategoryListRelationFilter
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    period?: SortOrder
    totalAllocatedCents?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Budget"> | string
    householdId?: UuidWithAggregatesFilter<"Budget"> | string
    name?: StringWithAggregatesFilter<"Budget"> | string
    period?: EnumBudgetPeriodWithAggregatesFilter<"Budget"> | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntWithAggregatesFilter<"Budget"> | bigint | number
    currency?: StringWithAggregatesFilter<"Budget"> | string
    startDate?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Budget"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type BudgetCategoryWhereInput = {
    AND?: BudgetCategoryWhereInput | BudgetCategoryWhereInput[]
    OR?: BudgetCategoryWhereInput[]
    NOT?: BudgetCategoryWhereInput | BudgetCategoryWhereInput[]
    id?: UuidFilter<"BudgetCategory"> | string
    budgetId?: UuidFilter<"BudgetCategory"> | string
    categoryId?: UuidFilter<"BudgetCategory"> | string
    allocatedAmountCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    spentAmountCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    carryOverCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    createdAt?: DateTimeFilter<"BudgetCategory"> | Date | string
    updatedAt?: DateTimeFilter<"BudgetCategory"> | Date | string
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type BudgetCategoryOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    allocatedAmountCents?: SortOrder
    spentAmountCents?: SortOrder
    carryOverCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budget?: BudgetOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type BudgetCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetCategoryWhereInput | BudgetCategoryWhereInput[]
    OR?: BudgetCategoryWhereInput[]
    NOT?: BudgetCategoryWhereInput | BudgetCategoryWhereInput[]
    budgetId?: UuidFilter<"BudgetCategory"> | string
    categoryId?: UuidFilter<"BudgetCategory"> | string
    allocatedAmountCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    spentAmountCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    carryOverCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    createdAt?: DateTimeFilter<"BudgetCategory"> | Date | string
    updatedAt?: DateTimeFilter<"BudgetCategory"> | Date | string
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id">

  export type BudgetCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    allocatedAmountCents?: SortOrder
    spentAmountCents?: SortOrder
    carryOverCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCategoryCountOrderByAggregateInput
    _avg?: BudgetCategoryAvgOrderByAggregateInput
    _max?: BudgetCategoryMaxOrderByAggregateInput
    _min?: BudgetCategoryMinOrderByAggregateInput
    _sum?: BudgetCategorySumOrderByAggregateInput
  }

  export type BudgetCategoryScalarWhereWithAggregatesInput = {
    AND?: BudgetCategoryScalarWhereWithAggregatesInput | BudgetCategoryScalarWhereWithAggregatesInput[]
    OR?: BudgetCategoryScalarWhereWithAggregatesInput[]
    NOT?: BudgetCategoryScalarWhereWithAggregatesInput | BudgetCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BudgetCategory"> | string
    budgetId?: UuidWithAggregatesFilter<"BudgetCategory"> | string
    categoryId?: UuidWithAggregatesFilter<"BudgetCategory"> | string
    allocatedAmountCents?: BigIntWithAggregatesFilter<"BudgetCategory"> | bigint | number
    spentAmountCents?: BigIntWithAggregatesFilter<"BudgetCategory"> | bigint | number
    carryOverCents?: BigIntWithAggregatesFilter<"BudgetCategory"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"BudgetCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BudgetCategory"> | Date | string
  }

  export type WishlistItemWhereInput = {
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    id?: UuidFilter<"WishlistItem"> | string
    householdId?: UuidFilter<"WishlistItem"> | string
    name?: StringFilter<"WishlistItem"> | string
    url?: StringFilter<"WishlistItem"> | string
    currentPriceCents?: BigIntFilter<"WishlistItem"> | bigint | number
    targetPriceCents?: BigIntNullableFilter<"WishlistItem"> | bigint | number | null
    currency?: StringFilter<"WishlistItem"> | string
    imageUrl?: StringNullableFilter<"WishlistItem"> | string | null
    merchant?: StringFilter<"WishlistItem"> | string
    linkedGoalId?: UuidNullableFilter<"WishlistItem"> | string | null
    isPurchased?: BoolFilter<"WishlistItem"> | boolean
    createdBy?: UuidFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    updatedAt?: DateTimeFilter<"WishlistItem"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    priceHistory?: PriceHistoryListRelationFilter
  }

  export type WishlistItemOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    currentPriceCents?: SortOrder
    targetPriceCents?: SortOrderInput | SortOrder
    currency?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    merchant?: SortOrder
    linkedGoalId?: SortOrderInput | SortOrder
    isPurchased?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    priceHistory?: PriceHistoryOrderByRelationAggregateInput
  }

  export type WishlistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    householdId?: UuidFilter<"WishlistItem"> | string
    name?: StringFilter<"WishlistItem"> | string
    url?: StringFilter<"WishlistItem"> | string
    currentPriceCents?: BigIntFilter<"WishlistItem"> | bigint | number
    targetPriceCents?: BigIntNullableFilter<"WishlistItem"> | bigint | number | null
    currency?: StringFilter<"WishlistItem"> | string
    imageUrl?: StringNullableFilter<"WishlistItem"> | string | null
    merchant?: StringFilter<"WishlistItem"> | string
    linkedGoalId?: UuidNullableFilter<"WishlistItem"> | string | null
    isPurchased?: BoolFilter<"WishlistItem"> | boolean
    createdBy?: UuidFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    updatedAt?: DateTimeFilter<"WishlistItem"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    priceHistory?: PriceHistoryListRelationFilter
  }, "id">

  export type WishlistItemOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    currentPriceCents?: SortOrder
    targetPriceCents?: SortOrderInput | SortOrder
    currency?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    merchant?: SortOrder
    linkedGoalId?: SortOrderInput | SortOrder
    isPurchased?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WishlistItemCountOrderByAggregateInput
    _avg?: WishlistItemAvgOrderByAggregateInput
    _max?: WishlistItemMaxOrderByAggregateInput
    _min?: WishlistItemMinOrderByAggregateInput
    _sum?: WishlistItemSumOrderByAggregateInput
  }

  export type WishlistItemScalarWhereWithAggregatesInput = {
    AND?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    OR?: WishlistItemScalarWhereWithAggregatesInput[]
    NOT?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WishlistItem"> | string
    householdId?: UuidWithAggregatesFilter<"WishlistItem"> | string
    name?: StringWithAggregatesFilter<"WishlistItem"> | string
    url?: StringWithAggregatesFilter<"WishlistItem"> | string
    currentPriceCents?: BigIntWithAggregatesFilter<"WishlistItem"> | bigint | number
    targetPriceCents?: BigIntNullableWithAggregatesFilter<"WishlistItem"> | bigint | number | null
    currency?: StringWithAggregatesFilter<"WishlistItem"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"WishlistItem"> | string | null
    merchant?: StringWithAggregatesFilter<"WishlistItem"> | string
    linkedGoalId?: UuidNullableWithAggregatesFilter<"WishlistItem"> | string | null
    isPurchased?: BoolWithAggregatesFilter<"WishlistItem"> | boolean
    createdBy?: UuidWithAggregatesFilter<"WishlistItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WishlistItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WishlistItem"> | Date | string
  }

  export type PriceHistoryWhereInput = {
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    id?: UuidFilter<"PriceHistory"> | string
    wishlistItemId?: UuidFilter<"PriceHistory"> | string
    priceCents?: BigIntFilter<"PriceHistory"> | bigint | number
    currency?: StringFilter<"PriceHistory"> | string
    recordedAt?: DateTimeFilter<"PriceHistory"> | Date | string
    wishlistItem?: XOR<WishlistItemScalarRelationFilter, WishlistItemWhereInput>
  }

  export type PriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    wishlistItemId?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    recordedAt?: SortOrder
    wishlistItem?: WishlistItemOrderByWithRelationInput
  }

  export type PriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    wishlistItemId?: UuidFilter<"PriceHistory"> | string
    priceCents?: BigIntFilter<"PriceHistory"> | bigint | number
    currency?: StringFilter<"PriceHistory"> | string
    recordedAt?: DateTimeFilter<"PriceHistory"> | Date | string
    wishlistItem?: XOR<WishlistItemScalarRelationFilter, WishlistItemWhereInput>
  }, "id">

  export type PriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    wishlistItemId?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    recordedAt?: SortOrder
    _count?: PriceHistoryCountOrderByAggregateInput
    _avg?: PriceHistoryAvgOrderByAggregateInput
    _max?: PriceHistoryMaxOrderByAggregateInput
    _min?: PriceHistoryMinOrderByAggregateInput
    _sum?: PriceHistorySumOrderByAggregateInput
  }

  export type PriceHistoryScalarWhereWithAggregatesInput = {
    AND?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    OR?: PriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PriceHistory"> | string
    wishlistItemId?: UuidWithAggregatesFilter<"PriceHistory"> | string
    priceCents?: BigIntWithAggregatesFilter<"PriceHistory"> | bigint | number
    currency?: StringWithAggregatesFilter<"PriceHistory"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"PriceHistory"> | Date | string
  }

  export type GratitudeEntryWhereInput = {
    AND?: GratitudeEntryWhereInput | GratitudeEntryWhereInput[]
    OR?: GratitudeEntryWhereInput[]
    NOT?: GratitudeEntryWhereInput | GratitudeEntryWhereInput[]
    id?: UuidFilter<"GratitudeEntry"> | string
    householdId?: UuidFilter<"GratitudeEntry"> | string
    giver?: StringFilter<"GratitudeEntry"> | string
    type?: EnumGratitudeTypeFilter<"GratitudeEntry"> | $Enums.GratitudeType
    categoryId?: UuidNullableFilter<"GratitudeEntry"> | string | null
    transactionId?: UuidNullableFilter<"GratitudeEntry"> | string | null
    estimatedValueCents?: BigIntNullableFilter<"GratitudeEntry"> | bigint | number | null
    currency?: StringNullableFilter<"GratitudeEntry"> | string | null
    description?: StringFilter<"GratitudeEntry"> | string
    date?: DateTimeFilter<"GratitudeEntry"> | Date | string
    createdBy?: UuidFilter<"GratitudeEntry"> | string
    createdAt?: DateTimeFilter<"GratitudeEntry"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GratitudeEntryOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    giver?: SortOrder
    type?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    estimatedValueCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    description?: SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type GratitudeEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GratitudeEntryWhereInput | GratitudeEntryWhereInput[]
    OR?: GratitudeEntryWhereInput[]
    NOT?: GratitudeEntryWhereInput | GratitudeEntryWhereInput[]
    householdId?: UuidFilter<"GratitudeEntry"> | string
    giver?: StringFilter<"GratitudeEntry"> | string
    type?: EnumGratitudeTypeFilter<"GratitudeEntry"> | $Enums.GratitudeType
    categoryId?: UuidNullableFilter<"GratitudeEntry"> | string | null
    transactionId?: UuidNullableFilter<"GratitudeEntry"> | string | null
    estimatedValueCents?: BigIntNullableFilter<"GratitudeEntry"> | bigint | number | null
    currency?: StringNullableFilter<"GratitudeEntry"> | string | null
    description?: StringFilter<"GratitudeEntry"> | string
    date?: DateTimeFilter<"GratitudeEntry"> | Date | string
    createdBy?: UuidFilter<"GratitudeEntry"> | string
    createdAt?: DateTimeFilter<"GratitudeEntry"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GratitudeEntryOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    giver?: SortOrder
    type?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    estimatedValueCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    description?: SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: GratitudeEntryCountOrderByAggregateInput
    _avg?: GratitudeEntryAvgOrderByAggregateInput
    _max?: GratitudeEntryMaxOrderByAggregateInput
    _min?: GratitudeEntryMinOrderByAggregateInput
    _sum?: GratitudeEntrySumOrderByAggregateInput
  }

  export type GratitudeEntryScalarWhereWithAggregatesInput = {
    AND?: GratitudeEntryScalarWhereWithAggregatesInput | GratitudeEntryScalarWhereWithAggregatesInput[]
    OR?: GratitudeEntryScalarWhereWithAggregatesInput[]
    NOT?: GratitudeEntryScalarWhereWithAggregatesInput | GratitudeEntryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GratitudeEntry"> | string
    householdId?: UuidWithAggregatesFilter<"GratitudeEntry"> | string
    giver?: StringWithAggregatesFilter<"GratitudeEntry"> | string
    type?: EnumGratitudeTypeWithAggregatesFilter<"GratitudeEntry"> | $Enums.GratitudeType
    categoryId?: UuidNullableWithAggregatesFilter<"GratitudeEntry"> | string | null
    transactionId?: UuidNullableWithAggregatesFilter<"GratitudeEntry"> | string | null
    estimatedValueCents?: BigIntNullableWithAggregatesFilter<"GratitudeEntry"> | bigint | number | null
    currency?: StringNullableWithAggregatesFilter<"GratitudeEntry"> | string | null
    description?: StringWithAggregatesFilter<"GratitudeEntry"> | string
    date?: DateTimeWithAggregatesFilter<"GratitudeEntry"> | Date | string
    createdBy?: UuidWithAggregatesFilter<"GratitudeEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GratitudeEntry"> | Date | string
  }

  export type ExchangeRateWhereInput = {
    AND?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    OR?: ExchangeRateWhereInput[]
    NOT?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    id?: UuidFilter<"ExchangeRate"> | string
    fromCurrency?: StringFilter<"ExchangeRate"> | string
    toCurrency?: StringFilter<"ExchangeRate"> | string
    rate?: DecimalFilter<"ExchangeRate"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ExchangeRate"> | Date | string
    source?: StringNullableFilter<"ExchangeRate"> | string | null
    createdAt?: DateTimeFilter<"ExchangeRate"> | Date | string
  }

  export type ExchangeRateOrderByWithRelationInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ExchangeRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fromCurrency_toCurrency_date?: ExchangeRateFromCurrencyToCurrencyDateCompoundUniqueInput
    AND?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    OR?: ExchangeRateWhereInput[]
    NOT?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    fromCurrency?: StringFilter<"ExchangeRate"> | string
    toCurrency?: StringFilter<"ExchangeRate"> | string
    rate?: DecimalFilter<"ExchangeRate"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"ExchangeRate"> | Date | string
    source?: StringNullableFilter<"ExchangeRate"> | string | null
    createdAt?: DateTimeFilter<"ExchangeRate"> | Date | string
  }, "id" | "fromCurrency_toCurrency_date">

  export type ExchangeRateOrderByWithAggregationInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExchangeRateCountOrderByAggregateInput
    _avg?: ExchangeRateAvgOrderByAggregateInput
    _max?: ExchangeRateMaxOrderByAggregateInput
    _min?: ExchangeRateMinOrderByAggregateInput
    _sum?: ExchangeRateSumOrderByAggregateInput
  }

  export type ExchangeRateScalarWhereWithAggregatesInput = {
    AND?: ExchangeRateScalarWhereWithAggregatesInput | ExchangeRateScalarWhereWithAggregatesInput[]
    OR?: ExchangeRateScalarWhereWithAggregatesInput[]
    NOT?: ExchangeRateScalarWhereWithAggregatesInput | ExchangeRateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ExchangeRate"> | string
    fromCurrency?: StringWithAggregatesFilter<"ExchangeRate"> | string
    toCurrency?: StringWithAggregatesFilter<"ExchangeRate"> | string
    rate?: DecimalWithAggregatesFilter<"ExchangeRate"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"ExchangeRate"> | Date | string
    source?: StringNullableWithAggregatesFilter<"ExchangeRate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExchangeRate"> | Date | string
  }

  export type PasskeyWhereInput = {
    AND?: PasskeyWhereInput | PasskeyWhereInput[]
    OR?: PasskeyWhereInput[]
    NOT?: PasskeyWhereInput | PasskeyWhereInput[]
    id?: UuidFilter<"Passkey"> | string
    userId?: UuidFilter<"Passkey"> | string
    name?: StringFilter<"Passkey"> | string
    credentialId?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    transports?: StringNullableListFilter<"Passkey">
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"Passkey"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasskeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasskeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    credentialId?: string
    AND?: PasskeyWhereInput | PasskeyWhereInput[]
    OR?: PasskeyWhereInput[]
    NOT?: PasskeyWhereInput | PasskeyWhereInput[]
    userId?: UuidFilter<"Passkey"> | string
    name?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    transports?: StringNullableListFilter<"Passkey">
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"Passkey"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "credentialId">

  export type PasskeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: PasskeyCountOrderByAggregateInput
    _avg?: PasskeyAvgOrderByAggregateInput
    _max?: PasskeyMaxOrderByAggregateInput
    _min?: PasskeyMinOrderByAggregateInput
    _sum?: PasskeySumOrderByAggregateInput
  }

  export type PasskeyScalarWhereWithAggregatesInput = {
    AND?: PasskeyScalarWhereWithAggregatesInput | PasskeyScalarWhereWithAggregatesInput[]
    OR?: PasskeyScalarWhereWithAggregatesInput[]
    NOT?: PasskeyScalarWhereWithAggregatesInput | PasskeyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Passkey"> | string
    userId?: UuidWithAggregatesFilter<"Passkey"> | string
    name?: StringWithAggregatesFilter<"Passkey"> | string
    credentialId?: StringWithAggregatesFilter<"Passkey"> | string
    publicKey?: StringWithAggregatesFilter<"Passkey"> | string
    counter?: IntWithAggregatesFilter<"Passkey"> | number
    transports?: StringNullableListFilter<"Passkey">
    createdAt?: DateTimeWithAggregatesFilter<"Passkey"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"Passkey"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: UuidFilter<"Session"> | string
    userId?: UuidFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: UuidFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Session"> | string
    userId?: UuidWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserEventWhereInput = {
    AND?: UserEventWhereInput | UserEventWhereInput[]
    OR?: UserEventWhereInput[]
    NOT?: UserEventWhereInput | UserEventWhereInput[]
    id?: UuidFilter<"UserEvent"> | string
    userId?: UuidFilter<"UserEvent"> | string
    householdId?: UuidFilter<"UserEvent"> | string
    eventType?: StringFilter<"UserEvent"> | string
    eventData?: JsonFilter<"UserEvent">
    resourceType?: StringNullableFilter<"UserEvent"> | string | null
    resourceId?: UuidNullableFilter<"UserEvent"> | string | null
    sessionId?: StringNullableFilter<"UserEvent"> | string | null
    ipAddress?: StringNullableFilter<"UserEvent"> | string | null
    userAgent?: StringNullableFilter<"UserEvent"> | string | null
    timestamp?: DateTimeFilter<"UserEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }

  export type UserEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    resourceType?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
    household?: HouseholdOrderByWithRelationInput
  }

  export type UserEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserEventWhereInput | UserEventWhereInput[]
    OR?: UserEventWhereInput[]
    NOT?: UserEventWhereInput | UserEventWhereInput[]
    userId?: UuidFilter<"UserEvent"> | string
    householdId?: UuidFilter<"UserEvent"> | string
    eventType?: StringFilter<"UserEvent"> | string
    eventData?: JsonFilter<"UserEvent">
    resourceType?: StringNullableFilter<"UserEvent"> | string | null
    resourceId?: UuidNullableFilter<"UserEvent"> | string | null
    sessionId?: StringNullableFilter<"UserEvent"> | string | null
    ipAddress?: StringNullableFilter<"UserEvent"> | string | null
    userAgent?: StringNullableFilter<"UserEvent"> | string | null
    timestamp?: DateTimeFilter<"UserEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }, "id">

  export type UserEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    resourceType?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: UserEventCountOrderByAggregateInput
    _max?: UserEventMaxOrderByAggregateInput
    _min?: UserEventMinOrderByAggregateInput
  }

  export type UserEventScalarWhereWithAggregatesInput = {
    AND?: UserEventScalarWhereWithAggregatesInput | UserEventScalarWhereWithAggregatesInput[]
    OR?: UserEventScalarWhereWithAggregatesInput[]
    NOT?: UserEventScalarWhereWithAggregatesInput | UserEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserEvent"> | string
    userId?: UuidWithAggregatesFilter<"UserEvent"> | string
    householdId?: UuidWithAggregatesFilter<"UserEvent"> | string
    eventType?: StringWithAggregatesFilter<"UserEvent"> | string
    eventData?: JsonWithAggregatesFilter<"UserEvent">
    resourceType?: StringNullableWithAggregatesFilter<"UserEvent"> | string | null
    resourceId?: UuidNullableWithAggregatesFilter<"UserEvent"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"UserEvent"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserEvent"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"UserEvent"> | Date | string
  }

  export type SpendingPatternWhereInput = {
    AND?: SpendingPatternWhereInput | SpendingPatternWhereInput[]
    OR?: SpendingPatternWhereInput[]
    NOT?: SpendingPatternWhereInput | SpendingPatternWhereInput[]
    id?: UuidFilter<"SpendingPattern"> | string
    householdId?: UuidFilter<"SpendingPattern"> | string
    userId?: UuidNullableFilter<"SpendingPattern"> | string | null
    patternType?: StringFilter<"SpendingPattern"> | string
    categoryId?: UuidNullableFilter<"SpendingPattern"> | string | null
    merchant?: StringNullableFilter<"SpendingPattern"> | string | null
    dayOfWeek?: IntNullableFilter<"SpendingPattern"> | number | null
    hourOfDay?: IntNullableFilter<"SpendingPattern"> | number | null
    month?: IntNullableFilter<"SpendingPattern"> | number | null
    averageAmountCents?: BigIntFilter<"SpendingPattern"> | bigint | number
    frequency?: IntFilter<"SpendingPattern"> | number
    confidenceScore?: DecimalFilter<"SpendingPattern"> | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFilter<"SpendingPattern"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }

  export type SpendingPatternOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    userId?: SortOrderInput | SortOrder
    patternType?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    merchant?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    hourOfDay?: SortOrderInput | SortOrder
    month?: SortOrderInput | SortOrder
    averageAmountCents?: SortOrder
    frequency?: SortOrder
    confidenceScore?: SortOrder
    lastUpdated?: SortOrder
    household?: HouseholdOrderByWithRelationInput
  }

  export type SpendingPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpendingPatternWhereInput | SpendingPatternWhereInput[]
    OR?: SpendingPatternWhereInput[]
    NOT?: SpendingPatternWhereInput | SpendingPatternWhereInput[]
    householdId?: UuidFilter<"SpendingPattern"> | string
    userId?: UuidNullableFilter<"SpendingPattern"> | string | null
    patternType?: StringFilter<"SpendingPattern"> | string
    categoryId?: UuidNullableFilter<"SpendingPattern"> | string | null
    merchant?: StringNullableFilter<"SpendingPattern"> | string | null
    dayOfWeek?: IntNullableFilter<"SpendingPattern"> | number | null
    hourOfDay?: IntNullableFilter<"SpendingPattern"> | number | null
    month?: IntNullableFilter<"SpendingPattern"> | number | null
    averageAmountCents?: BigIntFilter<"SpendingPattern"> | bigint | number
    frequency?: IntFilter<"SpendingPattern"> | number
    confidenceScore?: DecimalFilter<"SpendingPattern"> | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFilter<"SpendingPattern"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }, "id">

  export type SpendingPatternOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    userId?: SortOrderInput | SortOrder
    patternType?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    merchant?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    hourOfDay?: SortOrderInput | SortOrder
    month?: SortOrderInput | SortOrder
    averageAmountCents?: SortOrder
    frequency?: SortOrder
    confidenceScore?: SortOrder
    lastUpdated?: SortOrder
    _count?: SpendingPatternCountOrderByAggregateInput
    _avg?: SpendingPatternAvgOrderByAggregateInput
    _max?: SpendingPatternMaxOrderByAggregateInput
    _min?: SpendingPatternMinOrderByAggregateInput
    _sum?: SpendingPatternSumOrderByAggregateInput
  }

  export type SpendingPatternScalarWhereWithAggregatesInput = {
    AND?: SpendingPatternScalarWhereWithAggregatesInput | SpendingPatternScalarWhereWithAggregatesInput[]
    OR?: SpendingPatternScalarWhereWithAggregatesInput[]
    NOT?: SpendingPatternScalarWhereWithAggregatesInput | SpendingPatternScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SpendingPattern"> | string
    householdId?: UuidWithAggregatesFilter<"SpendingPattern"> | string
    userId?: UuidNullableWithAggregatesFilter<"SpendingPattern"> | string | null
    patternType?: StringWithAggregatesFilter<"SpendingPattern"> | string
    categoryId?: UuidNullableWithAggregatesFilter<"SpendingPattern"> | string | null
    merchant?: StringNullableWithAggregatesFilter<"SpendingPattern"> | string | null
    dayOfWeek?: IntNullableWithAggregatesFilter<"SpendingPattern"> | number | null
    hourOfDay?: IntNullableWithAggregatesFilter<"SpendingPattern"> | number | null
    month?: IntNullableWithAggregatesFilter<"SpendingPattern"> | number | null
    averageAmountCents?: BigIntWithAggregatesFilter<"SpendingPattern"> | bigint | number
    frequency?: IntWithAggregatesFilter<"SpendingPattern"> | number
    confidenceScore?: DecimalWithAggregatesFilter<"SpendingPattern"> | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeWithAggregatesFilter<"SpendingPattern"> | Date | string
  }

  export type FinancialInsightWhereInput = {
    AND?: FinancialInsightWhereInput | FinancialInsightWhereInput[]
    OR?: FinancialInsightWhereInput[]
    NOT?: FinancialInsightWhereInput | FinancialInsightWhereInput[]
    id?: UuidFilter<"FinancialInsight"> | string
    householdId?: UuidFilter<"FinancialInsight"> | string
    insightType?: StringFilter<"FinancialInsight"> | string
    title?: StringFilter<"FinancialInsight"> | string
    description?: StringFilter<"FinancialInsight"> | string
    data?: JsonFilter<"FinancialInsight">
    priority?: EnumInsightPriorityFilter<"FinancialInsight"> | $Enums.InsightPriority
    isActionable?: BoolFilter<"FinancialInsight"> | boolean
    isDismissed?: BoolFilter<"FinancialInsight"> | boolean
    validUntil?: DateTimeNullableFilter<"FinancialInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"FinancialInsight"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialInsight"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }

  export type FinancialInsightOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    isActionable?: SortOrder
    isDismissed?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
  }

  export type FinancialInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialInsightWhereInput | FinancialInsightWhereInput[]
    OR?: FinancialInsightWhereInput[]
    NOT?: FinancialInsightWhereInput | FinancialInsightWhereInput[]
    householdId?: UuidFilter<"FinancialInsight"> | string
    insightType?: StringFilter<"FinancialInsight"> | string
    title?: StringFilter<"FinancialInsight"> | string
    description?: StringFilter<"FinancialInsight"> | string
    data?: JsonFilter<"FinancialInsight">
    priority?: EnumInsightPriorityFilter<"FinancialInsight"> | $Enums.InsightPriority
    isActionable?: BoolFilter<"FinancialInsight"> | boolean
    isDismissed?: BoolFilter<"FinancialInsight"> | boolean
    validUntil?: DateTimeNullableFilter<"FinancialInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"FinancialInsight"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialInsight"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }, "id">

  export type FinancialInsightOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    isActionable?: SortOrder
    isDismissed?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinancialInsightCountOrderByAggregateInput
    _max?: FinancialInsightMaxOrderByAggregateInput
    _min?: FinancialInsightMinOrderByAggregateInput
  }

  export type FinancialInsightScalarWhereWithAggregatesInput = {
    AND?: FinancialInsightScalarWhereWithAggregatesInput | FinancialInsightScalarWhereWithAggregatesInput[]
    OR?: FinancialInsightScalarWhereWithAggregatesInput[]
    NOT?: FinancialInsightScalarWhereWithAggregatesInput | FinancialInsightScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FinancialInsight"> | string
    householdId?: UuidWithAggregatesFilter<"FinancialInsight"> | string
    insightType?: StringWithAggregatesFilter<"FinancialInsight"> | string
    title?: StringWithAggregatesFilter<"FinancialInsight"> | string
    description?: StringWithAggregatesFilter<"FinancialInsight"> | string
    data?: JsonWithAggregatesFilter<"FinancialInsight">
    priority?: EnumInsightPriorityWithAggregatesFilter<"FinancialInsight"> | $Enums.InsightPriority
    isActionable?: BoolWithAggregatesFilter<"FinancialInsight"> | boolean
    isDismissed?: BoolWithAggregatesFilter<"FinancialInsight"> | boolean
    validUntil?: DateTimeNullableWithAggregatesFilter<"FinancialInsight"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FinancialInsight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinancialInsight"> | Date | string
  }

  export type RecurringTransactionWhereInput = {
    AND?: RecurringTransactionWhereInput | RecurringTransactionWhereInput[]
    OR?: RecurringTransactionWhereInput[]
    NOT?: RecurringTransactionWhereInput | RecurringTransactionWhereInput[]
    id?: UuidFilter<"RecurringTransaction"> | string
    householdId?: UuidFilter<"RecurringTransaction"> | string
    name?: StringFilter<"RecurringTransaction"> | string
    description?: StringFilter<"RecurringTransaction"> | string
    amountCents?: BigIntFilter<"RecurringTransaction"> | bigint | number
    currency?: StringFilter<"RecurringTransaction"> | string
    accountId?: UuidFilter<"RecurringTransaction"> | string
    transferAccountId?: UuidNullableFilter<"RecurringTransaction"> | string | null
    categoryId?: UuidNullableFilter<"RecurringTransaction"> | string | null
    merchant?: StringNullableFilter<"RecurringTransaction"> | string | null
    frequency?: EnumRecurrenceFrequencyFilter<"RecurringTransaction"> | $Enums.RecurrenceFrequency
    intervalValue?: IntFilter<"RecurringTransaction"> | number
    startDate?: DateTimeFilter<"RecurringTransaction"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringTransaction"> | Date | string | null
    nextExecutionDate?: DateTimeFilter<"RecurringTransaction"> | Date | string
    lastExecutionDate?: DateTimeNullableFilter<"RecurringTransaction"> | Date | string | null
    executionCount?: IntFilter<"RecurringTransaction"> | number
    maxExecutions?: IntNullableFilter<"RecurringTransaction"> | number | null
    status?: EnumRecurringTransactionStatusFilter<"RecurringTransaction"> | $Enums.RecurringTransactionStatus
    metadata?: JsonFilter<"RecurringTransaction">
    createdBy?: UuidFilter<"RecurringTransaction"> | string
    createdAt?: DateTimeFilter<"RecurringTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringTransaction"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    transferAccount?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    executions?: RecurringTransactionExecutionListRelationFilter
  }

  export type RecurringTransactionOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    merchant?: SortOrderInput | SortOrder
    frequency?: SortOrder
    intervalValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextExecutionDate?: SortOrder
    lastExecutionDate?: SortOrderInput | SortOrder
    executionCount?: SortOrder
    maxExecutions?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    transferAccount?: AccountOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    executions?: RecurringTransactionExecutionOrderByRelationAggregateInput
  }

  export type RecurringTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurringTransactionWhereInput | RecurringTransactionWhereInput[]
    OR?: RecurringTransactionWhereInput[]
    NOT?: RecurringTransactionWhereInput | RecurringTransactionWhereInput[]
    householdId?: UuidFilter<"RecurringTransaction"> | string
    name?: StringFilter<"RecurringTransaction"> | string
    description?: StringFilter<"RecurringTransaction"> | string
    amountCents?: BigIntFilter<"RecurringTransaction"> | bigint | number
    currency?: StringFilter<"RecurringTransaction"> | string
    accountId?: UuidFilter<"RecurringTransaction"> | string
    transferAccountId?: UuidNullableFilter<"RecurringTransaction"> | string | null
    categoryId?: UuidNullableFilter<"RecurringTransaction"> | string | null
    merchant?: StringNullableFilter<"RecurringTransaction"> | string | null
    frequency?: EnumRecurrenceFrequencyFilter<"RecurringTransaction"> | $Enums.RecurrenceFrequency
    intervalValue?: IntFilter<"RecurringTransaction"> | number
    startDate?: DateTimeFilter<"RecurringTransaction"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringTransaction"> | Date | string | null
    nextExecutionDate?: DateTimeFilter<"RecurringTransaction"> | Date | string
    lastExecutionDate?: DateTimeNullableFilter<"RecurringTransaction"> | Date | string | null
    executionCount?: IntFilter<"RecurringTransaction"> | number
    maxExecutions?: IntNullableFilter<"RecurringTransaction"> | number | null
    status?: EnumRecurringTransactionStatusFilter<"RecurringTransaction"> | $Enums.RecurringTransactionStatus
    metadata?: JsonFilter<"RecurringTransaction">
    createdBy?: UuidFilter<"RecurringTransaction"> | string
    createdAt?: DateTimeFilter<"RecurringTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringTransaction"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    transferAccount?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    executions?: RecurringTransactionExecutionListRelationFilter
  }, "id">

  export type RecurringTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    merchant?: SortOrderInput | SortOrder
    frequency?: SortOrder
    intervalValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextExecutionDate?: SortOrder
    lastExecutionDate?: SortOrderInput | SortOrder
    executionCount?: SortOrder
    maxExecutions?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringTransactionCountOrderByAggregateInput
    _avg?: RecurringTransactionAvgOrderByAggregateInput
    _max?: RecurringTransactionMaxOrderByAggregateInput
    _min?: RecurringTransactionMinOrderByAggregateInput
    _sum?: RecurringTransactionSumOrderByAggregateInput
  }

  export type RecurringTransactionScalarWhereWithAggregatesInput = {
    AND?: RecurringTransactionScalarWhereWithAggregatesInput | RecurringTransactionScalarWhereWithAggregatesInput[]
    OR?: RecurringTransactionScalarWhereWithAggregatesInput[]
    NOT?: RecurringTransactionScalarWhereWithAggregatesInput | RecurringTransactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RecurringTransaction"> | string
    householdId?: UuidWithAggregatesFilter<"RecurringTransaction"> | string
    name?: StringWithAggregatesFilter<"RecurringTransaction"> | string
    description?: StringWithAggregatesFilter<"RecurringTransaction"> | string
    amountCents?: BigIntWithAggregatesFilter<"RecurringTransaction"> | bigint | number
    currency?: StringWithAggregatesFilter<"RecurringTransaction"> | string
    accountId?: UuidWithAggregatesFilter<"RecurringTransaction"> | string
    transferAccountId?: UuidNullableWithAggregatesFilter<"RecurringTransaction"> | string | null
    categoryId?: UuidNullableWithAggregatesFilter<"RecurringTransaction"> | string | null
    merchant?: StringNullableWithAggregatesFilter<"RecurringTransaction"> | string | null
    frequency?: EnumRecurrenceFrequencyWithAggregatesFilter<"RecurringTransaction"> | $Enums.RecurrenceFrequency
    intervalValue?: IntWithAggregatesFilter<"RecurringTransaction"> | number
    startDate?: DateTimeWithAggregatesFilter<"RecurringTransaction"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"RecurringTransaction"> | Date | string | null
    nextExecutionDate?: DateTimeWithAggregatesFilter<"RecurringTransaction"> | Date | string
    lastExecutionDate?: DateTimeNullableWithAggregatesFilter<"RecurringTransaction"> | Date | string | null
    executionCount?: IntWithAggregatesFilter<"RecurringTransaction"> | number
    maxExecutions?: IntNullableWithAggregatesFilter<"RecurringTransaction"> | number | null
    status?: EnumRecurringTransactionStatusWithAggregatesFilter<"RecurringTransaction"> | $Enums.RecurringTransactionStatus
    metadata?: JsonWithAggregatesFilter<"RecurringTransaction">
    createdBy?: UuidWithAggregatesFilter<"RecurringTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RecurringTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringTransaction"> | Date | string
  }

  export type RecurringTransactionExecutionWhereInput = {
    AND?: RecurringTransactionExecutionWhereInput | RecurringTransactionExecutionWhereInput[]
    OR?: RecurringTransactionExecutionWhereInput[]
    NOT?: RecurringTransactionExecutionWhereInput | RecurringTransactionExecutionWhereInput[]
    id?: UuidFilter<"RecurringTransactionExecution"> | string
    recurringTransactionId?: UuidFilter<"RecurringTransactionExecution"> | string
    transactionId?: UuidNullableFilter<"RecurringTransactionExecution"> | string | null
    scheduledDate?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
    executedDate?: DateTimeNullableFilter<"RecurringTransactionExecution"> | Date | string | null
    status?: StringFilter<"RecurringTransactionExecution"> | string
    errorMessage?: StringNullableFilter<"RecurringTransactionExecution"> | string | null
    retryCount?: IntFilter<"RecurringTransactionExecution"> | number
    createdAt?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
    recurringTransaction?: XOR<RecurringTransactionScalarRelationFilter, RecurringTransactionWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type RecurringTransactionExecutionOrderByWithRelationInput = {
    id?: SortOrder
    recurringTransactionId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    scheduledDate?: SortOrder
    executedDate?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recurringTransaction?: RecurringTransactionOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type RecurringTransactionExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurringTransactionExecutionWhereInput | RecurringTransactionExecutionWhereInput[]
    OR?: RecurringTransactionExecutionWhereInput[]
    NOT?: RecurringTransactionExecutionWhereInput | RecurringTransactionExecutionWhereInput[]
    recurringTransactionId?: UuidFilter<"RecurringTransactionExecution"> | string
    transactionId?: UuidNullableFilter<"RecurringTransactionExecution"> | string | null
    scheduledDate?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
    executedDate?: DateTimeNullableFilter<"RecurringTransactionExecution"> | Date | string | null
    status?: StringFilter<"RecurringTransactionExecution"> | string
    errorMessage?: StringNullableFilter<"RecurringTransactionExecution"> | string | null
    retryCount?: IntFilter<"RecurringTransactionExecution"> | number
    createdAt?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
    recurringTransaction?: XOR<RecurringTransactionScalarRelationFilter, RecurringTransactionWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id">

  export type RecurringTransactionExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    recurringTransactionId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    scheduledDate?: SortOrder
    executedDate?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringTransactionExecutionCountOrderByAggregateInput
    _avg?: RecurringTransactionExecutionAvgOrderByAggregateInput
    _max?: RecurringTransactionExecutionMaxOrderByAggregateInput
    _min?: RecurringTransactionExecutionMinOrderByAggregateInput
    _sum?: RecurringTransactionExecutionSumOrderByAggregateInput
  }

  export type RecurringTransactionExecutionScalarWhereWithAggregatesInput = {
    AND?: RecurringTransactionExecutionScalarWhereWithAggregatesInput | RecurringTransactionExecutionScalarWhereWithAggregatesInput[]
    OR?: RecurringTransactionExecutionScalarWhereWithAggregatesInput[]
    NOT?: RecurringTransactionExecutionScalarWhereWithAggregatesInput | RecurringTransactionExecutionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RecurringTransactionExecution"> | string
    recurringTransactionId?: UuidWithAggregatesFilter<"RecurringTransactionExecution"> | string
    transactionId?: UuidNullableWithAggregatesFilter<"RecurringTransactionExecution"> | string | null
    scheduledDate?: DateTimeWithAggregatesFilter<"RecurringTransactionExecution"> | Date | string
    executedDate?: DateTimeNullableWithAggregatesFilter<"RecurringTransactionExecution"> | Date | string | null
    status?: StringWithAggregatesFilter<"RecurringTransactionExecution"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"RecurringTransactionExecution"> | string | null
    retryCount?: IntWithAggregatesFilter<"RecurringTransactionExecution"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RecurringTransactionExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringTransactionExecution"> | Date | string
  }

  export type DocumentUploadWhereInput = {
    AND?: DocumentUploadWhereInput | DocumentUploadWhereInput[]
    OR?: DocumentUploadWhereInput[]
    NOT?: DocumentUploadWhereInput | DocumentUploadWhereInput[]
    id?: UuidFilter<"DocumentUpload"> | string
    householdId?: UuidFilter<"DocumentUpload"> | string
    fileName?: StringFilter<"DocumentUpload"> | string
    fileSize?: IntFilter<"DocumentUpload"> | number
    mimeType?: StringFilter<"DocumentUpload"> | string
    documentType?: EnumDocumentTypeFilter<"DocumentUpload"> | $Enums.DocumentType
    status?: EnumProcessingStatusFilter<"DocumentUpload"> | $Enums.ProcessingStatus
    uploadedBy?: UuidFilter<"DocumentUpload"> | string
    uploadedAt?: DateTimeFilter<"DocumentUpload"> | Date | string
    processedAt?: DateTimeNullableFilter<"DocumentUpload"> | Date | string | null
    storageUrl?: StringFilter<"DocumentUpload"> | string
    description?: StringNullableFilter<"DocumentUpload"> | string | null
    metadata?: JsonFilter<"DocumentUpload">
    createdAt?: DateTimeFilter<"DocumentUpload"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentUpload"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
    ocrResults?: OcrResultListRelationFilter
    transactionSuggestions?: TransactionSuggestionListRelationFilter
  }

  export type DocumentUploadOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    documentType?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    storageUrl?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
    ocrResults?: OcrResultOrderByRelationAggregateInput
    transactionSuggestions?: TransactionSuggestionOrderByRelationAggregateInput
  }

  export type DocumentUploadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentUploadWhereInput | DocumentUploadWhereInput[]
    OR?: DocumentUploadWhereInput[]
    NOT?: DocumentUploadWhereInput | DocumentUploadWhereInput[]
    householdId?: UuidFilter<"DocumentUpload"> | string
    fileName?: StringFilter<"DocumentUpload"> | string
    fileSize?: IntFilter<"DocumentUpload"> | number
    mimeType?: StringFilter<"DocumentUpload"> | string
    documentType?: EnumDocumentTypeFilter<"DocumentUpload"> | $Enums.DocumentType
    status?: EnumProcessingStatusFilter<"DocumentUpload"> | $Enums.ProcessingStatus
    uploadedBy?: UuidFilter<"DocumentUpload"> | string
    uploadedAt?: DateTimeFilter<"DocumentUpload"> | Date | string
    processedAt?: DateTimeNullableFilter<"DocumentUpload"> | Date | string | null
    storageUrl?: StringFilter<"DocumentUpload"> | string
    description?: StringNullableFilter<"DocumentUpload"> | string | null
    metadata?: JsonFilter<"DocumentUpload">
    createdAt?: DateTimeFilter<"DocumentUpload"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentUpload"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
    ocrResults?: OcrResultListRelationFilter
    transactionSuggestions?: TransactionSuggestionListRelationFilter
  }, "id">

  export type DocumentUploadOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    documentType?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    storageUrl?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentUploadCountOrderByAggregateInput
    _avg?: DocumentUploadAvgOrderByAggregateInput
    _max?: DocumentUploadMaxOrderByAggregateInput
    _min?: DocumentUploadMinOrderByAggregateInput
    _sum?: DocumentUploadSumOrderByAggregateInput
  }

  export type DocumentUploadScalarWhereWithAggregatesInput = {
    AND?: DocumentUploadScalarWhereWithAggregatesInput | DocumentUploadScalarWhereWithAggregatesInput[]
    OR?: DocumentUploadScalarWhereWithAggregatesInput[]
    NOT?: DocumentUploadScalarWhereWithAggregatesInput | DocumentUploadScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DocumentUpload"> | string
    householdId?: UuidWithAggregatesFilter<"DocumentUpload"> | string
    fileName?: StringWithAggregatesFilter<"DocumentUpload"> | string
    fileSize?: IntWithAggregatesFilter<"DocumentUpload"> | number
    mimeType?: StringWithAggregatesFilter<"DocumentUpload"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"DocumentUpload"> | $Enums.DocumentType
    status?: EnumProcessingStatusWithAggregatesFilter<"DocumentUpload"> | $Enums.ProcessingStatus
    uploadedBy?: UuidWithAggregatesFilter<"DocumentUpload"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"DocumentUpload"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"DocumentUpload"> | Date | string | null
    storageUrl?: StringWithAggregatesFilter<"DocumentUpload"> | string
    description?: StringNullableWithAggregatesFilter<"DocumentUpload"> | string | null
    metadata?: JsonWithAggregatesFilter<"DocumentUpload">
    createdAt?: DateTimeWithAggregatesFilter<"DocumentUpload"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentUpload"> | Date | string
  }

  export type OcrResultWhereInput = {
    AND?: OcrResultWhereInput | OcrResultWhereInput[]
    OR?: OcrResultWhereInput[]
    NOT?: OcrResultWhereInput | OcrResultWhereInput[]
    id?: UuidFilter<"OcrResult"> | string
    documentId?: UuidFilter<"OcrResult"> | string
    documentType?: EnumDocumentTypeFilter<"OcrResult"> | $Enums.DocumentType
    confidence?: DecimalFilter<"OcrResult"> | Decimal | DecimalJsLike | number | string
    extractedData?: JsonFilter<"OcrResult">
    rawText?: StringFilter<"OcrResult"> | string
    processedAt?: DateTimeFilter<"OcrResult"> | Date | string
    metadata?: JsonFilter<"OcrResult">
    createdAt?: DateTimeFilter<"OcrResult"> | Date | string
    document?: XOR<DocumentUploadScalarRelationFilter, DocumentUploadWhereInput>
    transactionSuggestions?: TransactionSuggestionListRelationFilter
  }

  export type OcrResultOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    confidence?: SortOrder
    extractedData?: SortOrder
    rawText?: SortOrder
    processedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    document?: DocumentUploadOrderByWithRelationInput
    transactionSuggestions?: TransactionSuggestionOrderByRelationAggregateInput
  }

  export type OcrResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OcrResultWhereInput | OcrResultWhereInput[]
    OR?: OcrResultWhereInput[]
    NOT?: OcrResultWhereInput | OcrResultWhereInput[]
    documentId?: UuidFilter<"OcrResult"> | string
    documentType?: EnumDocumentTypeFilter<"OcrResult"> | $Enums.DocumentType
    confidence?: DecimalFilter<"OcrResult"> | Decimal | DecimalJsLike | number | string
    extractedData?: JsonFilter<"OcrResult">
    rawText?: StringFilter<"OcrResult"> | string
    processedAt?: DateTimeFilter<"OcrResult"> | Date | string
    metadata?: JsonFilter<"OcrResult">
    createdAt?: DateTimeFilter<"OcrResult"> | Date | string
    document?: XOR<DocumentUploadScalarRelationFilter, DocumentUploadWhereInput>
    transactionSuggestions?: TransactionSuggestionListRelationFilter
  }, "id">

  export type OcrResultOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    confidence?: SortOrder
    extractedData?: SortOrder
    rawText?: SortOrder
    processedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: OcrResultCountOrderByAggregateInput
    _avg?: OcrResultAvgOrderByAggregateInput
    _max?: OcrResultMaxOrderByAggregateInput
    _min?: OcrResultMinOrderByAggregateInput
    _sum?: OcrResultSumOrderByAggregateInput
  }

  export type OcrResultScalarWhereWithAggregatesInput = {
    AND?: OcrResultScalarWhereWithAggregatesInput | OcrResultScalarWhereWithAggregatesInput[]
    OR?: OcrResultScalarWhereWithAggregatesInput[]
    NOT?: OcrResultScalarWhereWithAggregatesInput | OcrResultScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OcrResult"> | string
    documentId?: UuidWithAggregatesFilter<"OcrResult"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"OcrResult"> | $Enums.DocumentType
    confidence?: DecimalWithAggregatesFilter<"OcrResult"> | Decimal | DecimalJsLike | number | string
    extractedData?: JsonWithAggregatesFilter<"OcrResult">
    rawText?: StringWithAggregatesFilter<"OcrResult"> | string
    processedAt?: DateTimeWithAggregatesFilter<"OcrResult"> | Date | string
    metadata?: JsonWithAggregatesFilter<"OcrResult">
    createdAt?: DateTimeWithAggregatesFilter<"OcrResult"> | Date | string
  }

  export type TransactionSuggestionWhereInput = {
    AND?: TransactionSuggestionWhereInput | TransactionSuggestionWhereInput[]
    OR?: TransactionSuggestionWhereInput[]
    NOT?: TransactionSuggestionWhereInput | TransactionSuggestionWhereInput[]
    id?: UuidFilter<"TransactionSuggestion"> | string
    documentId?: UuidFilter<"TransactionSuggestion"> | string
    ocrResultId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    description?: StringFilter<"TransactionSuggestion"> | string
    amountCents?: BigIntFilter<"TransactionSuggestion"> | bigint | number
    currency?: StringFilter<"TransactionSuggestion"> | string
    date?: DateTimeFilter<"TransactionSuggestion"> | Date | string
    merchant?: StringNullableFilter<"TransactionSuggestion"> | string | null
    suggestedCategoryId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    suggestedCategoryName?: StringNullableFilter<"TransactionSuggestion"> | string | null
    confidence?: DecimalFilter<"TransactionSuggestion"> | Decimal | DecimalJsLike | number | string
    source?: StringFilter<"TransactionSuggestion"> | string
    status?: StringFilter<"TransactionSuggestion"> | string
    isApproved?: BoolFilter<"TransactionSuggestion"> | boolean
    approvedAt?: DateTimeNullableFilter<"TransactionSuggestion"> | Date | string | null
    metadata?: JsonFilter<"TransactionSuggestion">
    createdTransactionId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    createdAt?: DateTimeFilter<"TransactionSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionSuggestion"> | Date | string
    document?: XOR<DocumentUploadScalarRelationFilter, DocumentUploadWhereInput>
    ocrResult?: XOR<OcrResultNullableScalarRelationFilter, OcrResultWhereInput> | null
    suggestedCategory?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    createdTransaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type TransactionSuggestionOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    ocrResultId?: SortOrderInput | SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    merchant?: SortOrderInput | SortOrder
    suggestedCategoryId?: SortOrderInput | SortOrder
    suggestedCategoryName?: SortOrderInput | SortOrder
    confidence?: SortOrder
    source?: SortOrder
    status?: SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdTransactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentUploadOrderByWithRelationInput
    ocrResult?: OcrResultOrderByWithRelationInput
    suggestedCategory?: CategoryOrderByWithRelationInput
    createdTransaction?: TransactionOrderByWithRelationInput
  }

  export type TransactionSuggestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionSuggestionWhereInput | TransactionSuggestionWhereInput[]
    OR?: TransactionSuggestionWhereInput[]
    NOT?: TransactionSuggestionWhereInput | TransactionSuggestionWhereInput[]
    documentId?: UuidFilter<"TransactionSuggestion"> | string
    ocrResultId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    description?: StringFilter<"TransactionSuggestion"> | string
    amountCents?: BigIntFilter<"TransactionSuggestion"> | bigint | number
    currency?: StringFilter<"TransactionSuggestion"> | string
    date?: DateTimeFilter<"TransactionSuggestion"> | Date | string
    merchant?: StringNullableFilter<"TransactionSuggestion"> | string | null
    suggestedCategoryId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    suggestedCategoryName?: StringNullableFilter<"TransactionSuggestion"> | string | null
    confidence?: DecimalFilter<"TransactionSuggestion"> | Decimal | DecimalJsLike | number | string
    source?: StringFilter<"TransactionSuggestion"> | string
    status?: StringFilter<"TransactionSuggestion"> | string
    isApproved?: BoolFilter<"TransactionSuggestion"> | boolean
    approvedAt?: DateTimeNullableFilter<"TransactionSuggestion"> | Date | string | null
    metadata?: JsonFilter<"TransactionSuggestion">
    createdTransactionId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    createdAt?: DateTimeFilter<"TransactionSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionSuggestion"> | Date | string
    document?: XOR<DocumentUploadScalarRelationFilter, DocumentUploadWhereInput>
    ocrResult?: XOR<OcrResultNullableScalarRelationFilter, OcrResultWhereInput> | null
    suggestedCategory?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    createdTransaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id">

  export type TransactionSuggestionOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    ocrResultId?: SortOrderInput | SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    merchant?: SortOrderInput | SortOrder
    suggestedCategoryId?: SortOrderInput | SortOrder
    suggestedCategoryName?: SortOrderInput | SortOrder
    confidence?: SortOrder
    source?: SortOrder
    status?: SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdTransactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionSuggestionCountOrderByAggregateInput
    _avg?: TransactionSuggestionAvgOrderByAggregateInput
    _max?: TransactionSuggestionMaxOrderByAggregateInput
    _min?: TransactionSuggestionMinOrderByAggregateInput
    _sum?: TransactionSuggestionSumOrderByAggregateInput
  }

  export type TransactionSuggestionScalarWhereWithAggregatesInput = {
    AND?: TransactionSuggestionScalarWhereWithAggregatesInput | TransactionSuggestionScalarWhereWithAggregatesInput[]
    OR?: TransactionSuggestionScalarWhereWithAggregatesInput[]
    NOT?: TransactionSuggestionScalarWhereWithAggregatesInput | TransactionSuggestionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TransactionSuggestion"> | string
    documentId?: UuidWithAggregatesFilter<"TransactionSuggestion"> | string
    ocrResultId?: UuidNullableWithAggregatesFilter<"TransactionSuggestion"> | string | null
    description?: StringWithAggregatesFilter<"TransactionSuggestion"> | string
    amountCents?: BigIntWithAggregatesFilter<"TransactionSuggestion"> | bigint | number
    currency?: StringWithAggregatesFilter<"TransactionSuggestion"> | string
    date?: DateTimeWithAggregatesFilter<"TransactionSuggestion"> | Date | string
    merchant?: StringNullableWithAggregatesFilter<"TransactionSuggestion"> | string | null
    suggestedCategoryId?: UuidNullableWithAggregatesFilter<"TransactionSuggestion"> | string | null
    suggestedCategoryName?: StringNullableWithAggregatesFilter<"TransactionSuggestion"> | string | null
    confidence?: DecimalWithAggregatesFilter<"TransactionSuggestion"> | Decimal | DecimalJsLike | number | string
    source?: StringWithAggregatesFilter<"TransactionSuggestion"> | string
    status?: StringWithAggregatesFilter<"TransactionSuggestion"> | string
    isApproved?: BoolWithAggregatesFilter<"TransactionSuggestion"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"TransactionSuggestion"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"TransactionSuggestion">
    createdTransactionId?: UuidNullableWithAggregatesFilter<"TransactionSuggestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionSuggestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionSuggestion"> | Date | string
  }

  export type ZakatCalculationWhereInput = {
    AND?: ZakatCalculationWhereInput | ZakatCalculationWhereInput[]
    OR?: ZakatCalculationWhereInput[]
    NOT?: ZakatCalculationWhereInput | ZakatCalculationWhereInput[]
    id?: UuidFilter<"ZakatCalculation"> | string
    householdId?: UuidFilter<"ZakatCalculation"> | string
    calculationDate?: DateTimeFilter<"ZakatCalculation"> | Date | string
    hijriYear?: IntFilter<"ZakatCalculation"> | number
    nisabThresholdCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    totalZakatableAssetsCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    zakatAmountCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    currency?: StringFilter<"ZakatCalculation"> | string
    isZakatDue?: BoolFilter<"ZakatCalculation"> | boolean
    nextCalculationDate?: DateTimeFilter<"ZakatCalculation"> | Date | string
    metadata?: JsonFilter<"ZakatCalculation">
    createdAt?: DateTimeFilter<"ZakatCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"ZakatCalculation"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    assetBreakdown?: ZakatAssetBreakdownListRelationFilter
    zakatPayments?: ZakatPaymentListRelationFilter
  }

  export type ZakatCalculationOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    calculationDate?: SortOrder
    hijriYear?: SortOrder
    nisabThresholdCents?: SortOrder
    totalZakatableAssetsCents?: SortOrder
    zakatAmountCents?: SortOrder
    currency?: SortOrder
    isZakatDue?: SortOrder
    nextCalculationDate?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    assetBreakdown?: ZakatAssetBreakdownOrderByRelationAggregateInput
    zakatPayments?: ZakatPaymentOrderByRelationAggregateInput
  }

  export type ZakatCalculationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZakatCalculationWhereInput | ZakatCalculationWhereInput[]
    OR?: ZakatCalculationWhereInput[]
    NOT?: ZakatCalculationWhereInput | ZakatCalculationWhereInput[]
    householdId?: UuidFilter<"ZakatCalculation"> | string
    calculationDate?: DateTimeFilter<"ZakatCalculation"> | Date | string
    hijriYear?: IntFilter<"ZakatCalculation"> | number
    nisabThresholdCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    totalZakatableAssetsCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    zakatAmountCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    currency?: StringFilter<"ZakatCalculation"> | string
    isZakatDue?: BoolFilter<"ZakatCalculation"> | boolean
    nextCalculationDate?: DateTimeFilter<"ZakatCalculation"> | Date | string
    metadata?: JsonFilter<"ZakatCalculation">
    createdAt?: DateTimeFilter<"ZakatCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"ZakatCalculation"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    assetBreakdown?: ZakatAssetBreakdownListRelationFilter
    zakatPayments?: ZakatPaymentListRelationFilter
  }, "id">

  export type ZakatCalculationOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    calculationDate?: SortOrder
    hijriYear?: SortOrder
    nisabThresholdCents?: SortOrder
    totalZakatableAssetsCents?: SortOrder
    zakatAmountCents?: SortOrder
    currency?: SortOrder
    isZakatDue?: SortOrder
    nextCalculationDate?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZakatCalculationCountOrderByAggregateInput
    _avg?: ZakatCalculationAvgOrderByAggregateInput
    _max?: ZakatCalculationMaxOrderByAggregateInput
    _min?: ZakatCalculationMinOrderByAggregateInput
    _sum?: ZakatCalculationSumOrderByAggregateInput
  }

  export type ZakatCalculationScalarWhereWithAggregatesInput = {
    AND?: ZakatCalculationScalarWhereWithAggregatesInput | ZakatCalculationScalarWhereWithAggregatesInput[]
    OR?: ZakatCalculationScalarWhereWithAggregatesInput[]
    NOT?: ZakatCalculationScalarWhereWithAggregatesInput | ZakatCalculationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ZakatCalculation"> | string
    householdId?: UuidWithAggregatesFilter<"ZakatCalculation"> | string
    calculationDate?: DateTimeWithAggregatesFilter<"ZakatCalculation"> | Date | string
    hijriYear?: IntWithAggregatesFilter<"ZakatCalculation"> | number
    nisabThresholdCents?: BigIntWithAggregatesFilter<"ZakatCalculation"> | bigint | number
    totalZakatableAssetsCents?: BigIntWithAggregatesFilter<"ZakatCalculation"> | bigint | number
    zakatAmountCents?: BigIntWithAggregatesFilter<"ZakatCalculation"> | bigint | number
    currency?: StringWithAggregatesFilter<"ZakatCalculation"> | string
    isZakatDue?: BoolWithAggregatesFilter<"ZakatCalculation"> | boolean
    nextCalculationDate?: DateTimeWithAggregatesFilter<"ZakatCalculation"> | Date | string
    metadata?: JsonWithAggregatesFilter<"ZakatCalculation">
    createdAt?: DateTimeWithAggregatesFilter<"ZakatCalculation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ZakatCalculation"> | Date | string
  }

  export type ZakatAssetBreakdownWhereInput = {
    AND?: ZakatAssetBreakdownWhereInput | ZakatAssetBreakdownWhereInput[]
    OR?: ZakatAssetBreakdownWhereInput[]
    NOT?: ZakatAssetBreakdownWhereInput | ZakatAssetBreakdownWhereInput[]
    id?: UuidFilter<"ZakatAssetBreakdown"> | string
    zakatCalculationId?: UuidFilter<"ZakatAssetBreakdown"> | string
    assetType?: EnumZakatAssetTypeFilter<"ZakatAssetBreakdown"> | $Enums.ZakatAssetType
    accountId?: UuidNullableFilter<"ZakatAssetBreakdown"> | string | null
    accountName?: StringNullableFilter<"ZakatAssetBreakdown"> | string | null
    amountCents?: BigIntFilter<"ZakatAssetBreakdown"> | bigint | number
    currency?: StringFilter<"ZakatAssetBreakdown"> | string
    zakatRate?: DecimalFilter<"ZakatAssetBreakdown"> | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFilter<"ZakatAssetBreakdown"> | bigint | number
    haulCompleted?: BoolFilter<"ZakatAssetBreakdown"> | boolean
    haulStartDate?: DateTimeNullableFilter<"ZakatAssetBreakdown"> | Date | string | null
    metadata?: JsonFilter<"ZakatAssetBreakdown">
    createdAt?: DateTimeFilter<"ZakatAssetBreakdown"> | Date | string
    zakatCalculation?: XOR<ZakatCalculationScalarRelationFilter, ZakatCalculationWhereInput>
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
  }

  export type ZakatAssetBreakdownOrderByWithRelationInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrder
    assetType?: SortOrder
    accountId?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    zakatRate?: SortOrder
    zakatAmountCents?: SortOrder
    haulCompleted?: SortOrder
    haulStartDate?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    zakatCalculation?: ZakatCalculationOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
  }

  export type ZakatAssetBreakdownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZakatAssetBreakdownWhereInput | ZakatAssetBreakdownWhereInput[]
    OR?: ZakatAssetBreakdownWhereInput[]
    NOT?: ZakatAssetBreakdownWhereInput | ZakatAssetBreakdownWhereInput[]
    zakatCalculationId?: UuidFilter<"ZakatAssetBreakdown"> | string
    assetType?: EnumZakatAssetTypeFilter<"ZakatAssetBreakdown"> | $Enums.ZakatAssetType
    accountId?: UuidNullableFilter<"ZakatAssetBreakdown"> | string | null
    accountName?: StringNullableFilter<"ZakatAssetBreakdown"> | string | null
    amountCents?: BigIntFilter<"ZakatAssetBreakdown"> | bigint | number
    currency?: StringFilter<"ZakatAssetBreakdown"> | string
    zakatRate?: DecimalFilter<"ZakatAssetBreakdown"> | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFilter<"ZakatAssetBreakdown"> | bigint | number
    haulCompleted?: BoolFilter<"ZakatAssetBreakdown"> | boolean
    haulStartDate?: DateTimeNullableFilter<"ZakatAssetBreakdown"> | Date | string | null
    metadata?: JsonFilter<"ZakatAssetBreakdown">
    createdAt?: DateTimeFilter<"ZakatAssetBreakdown"> | Date | string
    zakatCalculation?: XOR<ZakatCalculationScalarRelationFilter, ZakatCalculationWhereInput>
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
  }, "id">

  export type ZakatAssetBreakdownOrderByWithAggregationInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrder
    assetType?: SortOrder
    accountId?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    zakatRate?: SortOrder
    zakatAmountCents?: SortOrder
    haulCompleted?: SortOrder
    haulStartDate?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: ZakatAssetBreakdownCountOrderByAggregateInput
    _avg?: ZakatAssetBreakdownAvgOrderByAggregateInput
    _max?: ZakatAssetBreakdownMaxOrderByAggregateInput
    _min?: ZakatAssetBreakdownMinOrderByAggregateInput
    _sum?: ZakatAssetBreakdownSumOrderByAggregateInput
  }

  export type ZakatAssetBreakdownScalarWhereWithAggregatesInput = {
    AND?: ZakatAssetBreakdownScalarWhereWithAggregatesInput | ZakatAssetBreakdownScalarWhereWithAggregatesInput[]
    OR?: ZakatAssetBreakdownScalarWhereWithAggregatesInput[]
    NOT?: ZakatAssetBreakdownScalarWhereWithAggregatesInput | ZakatAssetBreakdownScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ZakatAssetBreakdown"> | string
    zakatCalculationId?: UuidWithAggregatesFilter<"ZakatAssetBreakdown"> | string
    assetType?: EnumZakatAssetTypeWithAggregatesFilter<"ZakatAssetBreakdown"> | $Enums.ZakatAssetType
    accountId?: UuidNullableWithAggregatesFilter<"ZakatAssetBreakdown"> | string | null
    accountName?: StringNullableWithAggregatesFilter<"ZakatAssetBreakdown"> | string | null
    amountCents?: BigIntWithAggregatesFilter<"ZakatAssetBreakdown"> | bigint | number
    currency?: StringWithAggregatesFilter<"ZakatAssetBreakdown"> | string
    zakatRate?: DecimalWithAggregatesFilter<"ZakatAssetBreakdown"> | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntWithAggregatesFilter<"ZakatAssetBreakdown"> | bigint | number
    haulCompleted?: BoolWithAggregatesFilter<"ZakatAssetBreakdown"> | boolean
    haulStartDate?: DateTimeNullableWithAggregatesFilter<"ZakatAssetBreakdown"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"ZakatAssetBreakdown">
    createdAt?: DateTimeWithAggregatesFilter<"ZakatAssetBreakdown"> | Date | string
  }

  export type ZakatReminderWhereInput = {
    AND?: ZakatReminderWhereInput | ZakatReminderWhereInput[]
    OR?: ZakatReminderWhereInput[]
    NOT?: ZakatReminderWhereInput | ZakatReminderWhereInput[]
    id?: UuidFilter<"ZakatReminder"> | string
    householdId?: UuidFilter<"ZakatReminder"> | string
    reminderType?: EnumZakatReminderTypeFilter<"ZakatReminder"> | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFilter<"ZakatReminder"> | Date | string
    hijriDate?: StringFilter<"ZakatReminder"> | string
    zakatAmountCents?: BigIntNullableFilter<"ZakatReminder"> | bigint | number | null
    currency?: StringNullableFilter<"ZakatReminder"> | string | null
    message?: StringFilter<"ZakatReminder"> | string
    isActive?: BoolFilter<"ZakatReminder"> | boolean
    isSent?: BoolFilter<"ZakatReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"ZakatReminder"> | Date | string | null
    metadata?: JsonFilter<"ZakatReminder">
    createdAt?: DateTimeFilter<"ZakatReminder"> | Date | string
    updatedAt?: DateTimeFilter<"ZakatReminder"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }

  export type ZakatReminderOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    reminderType?: SortOrder
    scheduledDate?: SortOrder
    hijriDate?: SortOrder
    zakatAmountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    message?: SortOrder
    isActive?: SortOrder
    isSent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
  }

  export type ZakatReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZakatReminderWhereInput | ZakatReminderWhereInput[]
    OR?: ZakatReminderWhereInput[]
    NOT?: ZakatReminderWhereInput | ZakatReminderWhereInput[]
    householdId?: UuidFilter<"ZakatReminder"> | string
    reminderType?: EnumZakatReminderTypeFilter<"ZakatReminder"> | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFilter<"ZakatReminder"> | Date | string
    hijriDate?: StringFilter<"ZakatReminder"> | string
    zakatAmountCents?: BigIntNullableFilter<"ZakatReminder"> | bigint | number | null
    currency?: StringNullableFilter<"ZakatReminder"> | string | null
    message?: StringFilter<"ZakatReminder"> | string
    isActive?: BoolFilter<"ZakatReminder"> | boolean
    isSent?: BoolFilter<"ZakatReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"ZakatReminder"> | Date | string | null
    metadata?: JsonFilter<"ZakatReminder">
    createdAt?: DateTimeFilter<"ZakatReminder"> | Date | string
    updatedAt?: DateTimeFilter<"ZakatReminder"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
  }, "id">

  export type ZakatReminderOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    reminderType?: SortOrder
    scheduledDate?: SortOrder
    hijriDate?: SortOrder
    zakatAmountCents?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    message?: SortOrder
    isActive?: SortOrder
    isSent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZakatReminderCountOrderByAggregateInput
    _avg?: ZakatReminderAvgOrderByAggregateInput
    _max?: ZakatReminderMaxOrderByAggregateInput
    _min?: ZakatReminderMinOrderByAggregateInput
    _sum?: ZakatReminderSumOrderByAggregateInput
  }

  export type ZakatReminderScalarWhereWithAggregatesInput = {
    AND?: ZakatReminderScalarWhereWithAggregatesInput | ZakatReminderScalarWhereWithAggregatesInput[]
    OR?: ZakatReminderScalarWhereWithAggregatesInput[]
    NOT?: ZakatReminderScalarWhereWithAggregatesInput | ZakatReminderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ZakatReminder"> | string
    householdId?: UuidWithAggregatesFilter<"ZakatReminder"> | string
    reminderType?: EnumZakatReminderTypeWithAggregatesFilter<"ZakatReminder"> | $Enums.ZakatReminderType
    scheduledDate?: DateTimeWithAggregatesFilter<"ZakatReminder"> | Date | string
    hijriDate?: StringWithAggregatesFilter<"ZakatReminder"> | string
    zakatAmountCents?: BigIntNullableWithAggregatesFilter<"ZakatReminder"> | bigint | number | null
    currency?: StringNullableWithAggregatesFilter<"ZakatReminder"> | string | null
    message?: StringWithAggregatesFilter<"ZakatReminder"> | string
    isActive?: BoolWithAggregatesFilter<"ZakatReminder"> | boolean
    isSent?: BoolWithAggregatesFilter<"ZakatReminder"> | boolean
    sentAt?: DateTimeNullableWithAggregatesFilter<"ZakatReminder"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"ZakatReminder">
    createdAt?: DateTimeWithAggregatesFilter<"ZakatReminder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ZakatReminder"> | Date | string
  }

  export type ZakatPaymentWhereInput = {
    AND?: ZakatPaymentWhereInput | ZakatPaymentWhereInput[]
    OR?: ZakatPaymentWhereInput[]
    NOT?: ZakatPaymentWhereInput | ZakatPaymentWhereInput[]
    id?: UuidFilter<"ZakatPayment"> | string
    zakatCalculationId?: UuidNullableFilter<"ZakatPayment"> | string | null
    householdId?: UuidFilter<"ZakatPayment"> | string
    amountCents?: BigIntFilter<"ZakatPayment"> | bigint | number
    currency?: StringFilter<"ZakatPayment"> | string
    paymentDate?: DateTimeFilter<"ZakatPayment"> | Date | string
    hijriDate?: StringFilter<"ZakatPayment"> | string
    transactionId?: UuidNullableFilter<"ZakatPayment"> | string | null
    notes?: StringNullableFilter<"ZakatPayment"> | string | null
    metadata?: JsonFilter<"ZakatPayment">
    createdAt?: DateTimeFilter<"ZakatPayment"> | Date | string
    zakatCalculation?: XOR<ZakatCalculationNullableScalarRelationFilter, ZakatCalculationWhereInput> | null
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type ZakatPaymentOrderByWithRelationInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrderInput | SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    hijriDate?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    zakatCalculation?: ZakatCalculationOrderByWithRelationInput
    household?: HouseholdOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type ZakatPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZakatPaymentWhereInput | ZakatPaymentWhereInput[]
    OR?: ZakatPaymentWhereInput[]
    NOT?: ZakatPaymentWhereInput | ZakatPaymentWhereInput[]
    zakatCalculationId?: UuidNullableFilter<"ZakatPayment"> | string | null
    householdId?: UuidFilter<"ZakatPayment"> | string
    amountCents?: BigIntFilter<"ZakatPayment"> | bigint | number
    currency?: StringFilter<"ZakatPayment"> | string
    paymentDate?: DateTimeFilter<"ZakatPayment"> | Date | string
    hijriDate?: StringFilter<"ZakatPayment"> | string
    transactionId?: UuidNullableFilter<"ZakatPayment"> | string | null
    notes?: StringNullableFilter<"ZakatPayment"> | string | null
    metadata?: JsonFilter<"ZakatPayment">
    createdAt?: DateTimeFilter<"ZakatPayment"> | Date | string
    zakatCalculation?: XOR<ZakatCalculationNullableScalarRelationFilter, ZakatCalculationWhereInput> | null
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id">

  export type ZakatPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrderInput | SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    hijriDate?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: ZakatPaymentCountOrderByAggregateInput
    _avg?: ZakatPaymentAvgOrderByAggregateInput
    _max?: ZakatPaymentMaxOrderByAggregateInput
    _min?: ZakatPaymentMinOrderByAggregateInput
    _sum?: ZakatPaymentSumOrderByAggregateInput
  }

  export type ZakatPaymentScalarWhereWithAggregatesInput = {
    AND?: ZakatPaymentScalarWhereWithAggregatesInput | ZakatPaymentScalarWhereWithAggregatesInput[]
    OR?: ZakatPaymentScalarWhereWithAggregatesInput[]
    NOT?: ZakatPaymentScalarWhereWithAggregatesInput | ZakatPaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ZakatPayment"> | string
    zakatCalculationId?: UuidNullableWithAggregatesFilter<"ZakatPayment"> | string | null
    householdId?: UuidWithAggregatesFilter<"ZakatPayment"> | string
    amountCents?: BigIntWithAggregatesFilter<"ZakatPayment"> | bigint | number
    currency?: StringWithAggregatesFilter<"ZakatPayment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"ZakatPayment"> | Date | string
    hijriDate?: StringWithAggregatesFilter<"ZakatPayment"> | string
    transactionId?: UuidNullableWithAggregatesFilter<"ZakatPayment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ZakatPayment"> | string | null
    metadata?: JsonWithAggregatesFilter<"ZakatPayment">
    createdAt?: DateTimeWithAggregatesFilter<"ZakatPayment"> | Date | string
  }

  export type ShariaCompliantAccountWhereInput = {
    AND?: ShariaCompliantAccountWhereInput | ShariaCompliantAccountWhereInput[]
    OR?: ShariaCompliantAccountWhereInput[]
    NOT?: ShariaCompliantAccountWhereInput | ShariaCompliantAccountWhereInput[]
    id?: UuidFilter<"ShariaCompliantAccount"> | string
    accountId?: UuidFilter<"ShariaCompliantAccount"> | string
    complianceStatus?: EnumShariaComplianceStatusFilter<"ShariaCompliantAccount"> | $Enums.ShariaComplianceStatus
    complianceNotes?: StringNullableFilter<"ShariaCompliantAccount"> | string | null
    lastReviewDate?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    nextReviewDate?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    reviewedBy?: UuidNullableFilter<"ShariaCompliantAccount"> | string | null
    metadata?: JsonFilter<"ShariaCompliantAccount">
    createdAt?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ShariaCompliantAccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    complianceStatus?: SortOrder
    complianceNotes?: SortOrderInput | SortOrder
    lastReviewDate?: SortOrder
    nextReviewDate?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type ShariaCompliantAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    AND?: ShariaCompliantAccountWhereInput | ShariaCompliantAccountWhereInput[]
    OR?: ShariaCompliantAccountWhereInput[]
    NOT?: ShariaCompliantAccountWhereInput | ShariaCompliantAccountWhereInput[]
    complianceStatus?: EnumShariaComplianceStatusFilter<"ShariaCompliantAccount"> | $Enums.ShariaComplianceStatus
    complianceNotes?: StringNullableFilter<"ShariaCompliantAccount"> | string | null
    lastReviewDate?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    nextReviewDate?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    reviewedBy?: UuidNullableFilter<"ShariaCompliantAccount"> | string | null
    metadata?: JsonFilter<"ShariaCompliantAccount">
    createdAt?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "accountId">

  export type ShariaCompliantAccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    complianceStatus?: SortOrder
    complianceNotes?: SortOrderInput | SortOrder
    lastReviewDate?: SortOrder
    nextReviewDate?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShariaCompliantAccountCountOrderByAggregateInput
    _max?: ShariaCompliantAccountMaxOrderByAggregateInput
    _min?: ShariaCompliantAccountMinOrderByAggregateInput
  }

  export type ShariaCompliantAccountScalarWhereWithAggregatesInput = {
    AND?: ShariaCompliantAccountScalarWhereWithAggregatesInput | ShariaCompliantAccountScalarWhereWithAggregatesInput[]
    OR?: ShariaCompliantAccountScalarWhereWithAggregatesInput[]
    NOT?: ShariaCompliantAccountScalarWhereWithAggregatesInput | ShariaCompliantAccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ShariaCompliantAccount"> | string
    accountId?: UuidWithAggregatesFilter<"ShariaCompliantAccount"> | string
    complianceStatus?: EnumShariaComplianceStatusWithAggregatesFilter<"ShariaCompliantAccount"> | $Enums.ShariaComplianceStatus
    complianceNotes?: StringNullableWithAggregatesFilter<"ShariaCompliantAccount"> | string | null
    lastReviewDate?: DateTimeWithAggregatesFilter<"ShariaCompliantAccount"> | Date | string
    nextReviewDate?: DateTimeWithAggregatesFilter<"ShariaCompliantAccount"> | Date | string
    reviewedBy?: UuidNullableWithAggregatesFilter<"ShariaCompliantAccount"> | string | null
    metadata?: JsonWithAggregatesFilter<"ShariaCompliantAccount">
    createdAt?: DateTimeWithAggregatesFilter<"ShariaCompliantAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShariaCompliantAccount"> | Date | string
  }

  export type IslamicFinanceReportWhereInput = {
    AND?: IslamicFinanceReportWhereInput | IslamicFinanceReportWhereInput[]
    OR?: IslamicFinanceReportWhereInput[]
    NOT?: IslamicFinanceReportWhereInput | IslamicFinanceReportWhereInput[]
    id?: UuidFilter<"IslamicFinanceReport"> | string
    householdId?: UuidFilter<"IslamicFinanceReport"> | string
    reportType?: EnumIslamicReportTypeFilter<"IslamicFinanceReport"> | $Enums.IslamicReportType
    periodStartDate?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    periodEndDate?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    periodType?: StringFilter<"IslamicFinanceReport"> | string
    reportData?: JsonFilter<"IslamicFinanceReport">
    generatedAt?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    generatedBy?: UuidNullableFilter<"IslamicFinanceReport"> | string | null
    metadata?: JsonFilter<"IslamicFinanceReport">
    createdAt?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    generator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type IslamicFinanceReportOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    reportType?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    periodType?: SortOrder
    reportData?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    generator?: UserOrderByWithRelationInput
  }

  export type IslamicFinanceReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IslamicFinanceReportWhereInput | IslamicFinanceReportWhereInput[]
    OR?: IslamicFinanceReportWhereInput[]
    NOT?: IslamicFinanceReportWhereInput | IslamicFinanceReportWhereInput[]
    householdId?: UuidFilter<"IslamicFinanceReport"> | string
    reportType?: EnumIslamicReportTypeFilter<"IslamicFinanceReport"> | $Enums.IslamicReportType
    periodStartDate?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    periodEndDate?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    periodType?: StringFilter<"IslamicFinanceReport"> | string
    reportData?: JsonFilter<"IslamicFinanceReport">
    generatedAt?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    generatedBy?: UuidNullableFilter<"IslamicFinanceReport"> | string | null
    metadata?: JsonFilter<"IslamicFinanceReport">
    createdAt?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    generator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type IslamicFinanceReportOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    reportType?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    periodType?: SortOrder
    reportData?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: IslamicFinanceReportCountOrderByAggregateInput
    _max?: IslamicFinanceReportMaxOrderByAggregateInput
    _min?: IslamicFinanceReportMinOrderByAggregateInput
  }

  export type IslamicFinanceReportScalarWhereWithAggregatesInput = {
    AND?: IslamicFinanceReportScalarWhereWithAggregatesInput | IslamicFinanceReportScalarWhereWithAggregatesInput[]
    OR?: IslamicFinanceReportScalarWhereWithAggregatesInput[]
    NOT?: IslamicFinanceReportScalarWhereWithAggregatesInput | IslamicFinanceReportScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"IslamicFinanceReport"> | string
    householdId?: UuidWithAggregatesFilter<"IslamicFinanceReport"> | string
    reportType?: EnumIslamicReportTypeWithAggregatesFilter<"IslamicFinanceReport"> | $Enums.IslamicReportType
    periodStartDate?: DateTimeWithAggregatesFilter<"IslamicFinanceReport"> | Date | string
    periodEndDate?: DateTimeWithAggregatesFilter<"IslamicFinanceReport"> | Date | string
    periodType?: StringWithAggregatesFilter<"IslamicFinanceReport"> | string
    reportData?: JsonWithAggregatesFilter<"IslamicFinanceReport">
    generatedAt?: DateTimeWithAggregatesFilter<"IslamicFinanceReport"> | Date | string
    generatedBy?: UuidNullableWithAggregatesFilter<"IslamicFinanceReport"> | string | null
    metadata?: JsonWithAggregatesFilter<"IslamicFinanceReport">
    createdAt?: DateTimeWithAggregatesFilter<"IslamicFinanceReport"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    householdId?: UuidFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionText?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonFilter<"Notification">
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    channels?: EnumNotificationChannelNullableListFilter<"Notification">
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    deliveries?: NotificationDeliveryListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionText?: SortOrderInput | SortOrder
    metadata?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    channels?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    household?: HouseholdOrderByWithRelationInput
    deliveries?: NotificationDeliveryOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: UuidFilter<"Notification"> | string
    householdId?: UuidFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionText?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonFilter<"Notification">
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    channels?: EnumNotificationChannelNullableListFilter<"Notification">
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    household?: XOR<HouseholdScalarRelationFilter, HouseholdWhereInput>
    deliveries?: NotificationDeliveryListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionText?: SortOrderInput | SortOrder
    metadata?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    channels?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    userId?: UuidWithAggregatesFilter<"Notification"> | string
    householdId?: UuidWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionText?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonWithAggregatesFilter<"Notification">
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    channels?: EnumNotificationChannelNullableListFilter<"Notification">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationDeliveryWhereInput = {
    AND?: NotificationDeliveryWhereInput | NotificationDeliveryWhereInput[]
    OR?: NotificationDeliveryWhereInput[]
    NOT?: NotificationDeliveryWhereInput | NotificationDeliveryWhereInput[]
    id?: UuidFilter<"NotificationDelivery"> | string
    notificationId?: UuidFilter<"NotificationDelivery"> | string
    channel?: EnumNotificationChannelFilter<"NotificationDelivery"> | $Enums.NotificationChannel
    status?: EnumNotificationStatusFilter<"NotificationDelivery"> | $Enums.NotificationStatus
    deliveredAt?: DateTimeNullableFilter<"NotificationDelivery"> | Date | string | null
    failureReason?: StringNullableFilter<"NotificationDelivery"> | string | null
    retryCount?: IntFilter<"NotificationDelivery"> | number
    metadata?: JsonFilter<"NotificationDelivery">
    createdAt?: DateTimeFilter<"NotificationDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationDelivery"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
  }

  export type NotificationDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
  }

  export type NotificationDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationDeliveryWhereInput | NotificationDeliveryWhereInput[]
    OR?: NotificationDeliveryWhereInput[]
    NOT?: NotificationDeliveryWhereInput | NotificationDeliveryWhereInput[]
    notificationId?: UuidFilter<"NotificationDelivery"> | string
    channel?: EnumNotificationChannelFilter<"NotificationDelivery"> | $Enums.NotificationChannel
    status?: EnumNotificationStatusFilter<"NotificationDelivery"> | $Enums.NotificationStatus
    deliveredAt?: DateTimeNullableFilter<"NotificationDelivery"> | Date | string | null
    failureReason?: StringNullableFilter<"NotificationDelivery"> | string | null
    retryCount?: IntFilter<"NotificationDelivery"> | number
    metadata?: JsonFilter<"NotificationDelivery">
    createdAt?: DateTimeFilter<"NotificationDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationDelivery"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
  }, "id">

  export type NotificationDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationDeliveryCountOrderByAggregateInput
    _avg?: NotificationDeliveryAvgOrderByAggregateInput
    _max?: NotificationDeliveryMaxOrderByAggregateInput
    _min?: NotificationDeliveryMinOrderByAggregateInput
    _sum?: NotificationDeliverySumOrderByAggregateInput
  }

  export type NotificationDeliveryScalarWhereWithAggregatesInput = {
    AND?: NotificationDeliveryScalarWhereWithAggregatesInput | NotificationDeliveryScalarWhereWithAggregatesInput[]
    OR?: NotificationDeliveryScalarWhereWithAggregatesInput[]
    NOT?: NotificationDeliveryScalarWhereWithAggregatesInput | NotificationDeliveryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NotificationDelivery"> | string
    notificationId?: UuidWithAggregatesFilter<"NotificationDelivery"> | string
    channel?: EnumNotificationChannelWithAggregatesFilter<"NotificationDelivery"> | $Enums.NotificationChannel
    status?: EnumNotificationStatusWithAggregatesFilter<"NotificationDelivery"> | $Enums.NotificationStatus
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"NotificationDelivery"> | Date | string | null
    failureReason?: StringNullableWithAggregatesFilter<"NotificationDelivery"> | string | null
    retryCount?: IntWithAggregatesFilter<"NotificationDelivery"> | number
    metadata?: JsonWithAggregatesFilter<"NotificationDelivery">
    createdAt?: DateTimeWithAggregatesFilter<"NotificationDelivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationDelivery"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: UuidFilter<"NotificationPreference"> | string
    userId?: UuidFilter<"NotificationPreference"> | string
    budgetAlerts?: JsonFilter<"NotificationPreference">
    debtReminders?: JsonFilter<"NotificationPreference">
    zakatReminders?: JsonFilter<"NotificationPreference">
    priceAlerts?: JsonFilter<"NotificationPreference">
    transactionAlerts?: JsonFilter<"NotificationPreference">
    monthlyReports?: JsonFilter<"NotificationPreference">
    securityAlerts?: JsonFilter<"NotificationPreference">
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    budgetAlerts?: SortOrder
    debtReminders?: SortOrder
    zakatReminders?: SortOrder
    priceAlerts?: SortOrder
    transactionAlerts?: SortOrder
    monthlyReports?: SortOrder
    securityAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    budgetAlerts?: JsonFilter<"NotificationPreference">
    debtReminders?: JsonFilter<"NotificationPreference">
    zakatReminders?: JsonFilter<"NotificationPreference">
    priceAlerts?: JsonFilter<"NotificationPreference">
    transactionAlerts?: JsonFilter<"NotificationPreference">
    monthlyReports?: JsonFilter<"NotificationPreference">
    securityAlerts?: JsonFilter<"NotificationPreference">
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    budgetAlerts?: SortOrder
    debtReminders?: SortOrder
    zakatReminders?: SortOrder
    priceAlerts?: SortOrder
    transactionAlerts?: SortOrder
    monthlyReports?: SortOrder
    securityAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NotificationPreference"> | string
    userId?: UuidWithAggregatesFilter<"NotificationPreference"> | string
    budgetAlerts?: JsonWithAggregatesFilter<"NotificationPreference">
    debtReminders?: JsonWithAggregatesFilter<"NotificationPreference">
    zakatReminders?: JsonWithAggregatesFilter<"NotificationPreference">
    priceAlerts?: JsonWithAggregatesFilter<"NotificationPreference">
    transactionAlerts?: JsonWithAggregatesFilter<"NotificationPreference">
    monthlyReports?: JsonWithAggregatesFilter<"NotificationPreference">
    securityAlerts?: JsonWithAggregatesFilter<"NotificationPreference">
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: UuidFilter<"PushSubscription"> | string
    userId?: UuidFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    isActive?: BoolFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_endpoint?: PushSubscriptionUserIdEndpointCompoundUniqueInput
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    userId?: UuidFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    isActive?: BoolFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PushSubscription"> | string
    userId?: UuidWithAggregatesFilter<"PushSubscription"> | string
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    p256dh?: StringWithAggregatesFilter<"PushSubscription"> | string
    auth?: StringWithAggregatesFilter<"PushSubscription"> | string
    userAgent?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    isActive?: BoolWithAggregatesFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: UuidFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    type?: EnumNotificationTypeFilter<"EmailTemplate"> | $Enums.NotificationType
    subject?: StringFilter<"EmailTemplate"> | string
    htmlContent?: StringFilter<"EmailTemplate"> | string
    textContent?: StringFilter<"EmailTemplate"> | string
    variables?: JsonFilter<"EmailTemplate">
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    type?: EnumNotificationTypeFilter<"EmailTemplate"> | $Enums.NotificationType
    subject?: StringFilter<"EmailTemplate"> | string
    htmlContent?: StringFilter<"EmailTemplate"> | string
    textContent?: StringFilter<"EmailTemplate"> | string
    variables?: JsonFilter<"EmailTemplate">
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }, "id" | "name">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"EmailTemplate"> | $Enums.NotificationType
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    htmlContent?: StringWithAggregatesFilter<"EmailTemplate"> | string
    textContent?: StringWithAggregatesFilter<"EmailTemplate"> | string
    variables?: JsonWithAggregatesFilter<"EmailTemplate">
    isActive?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdCreateInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdCreateManyInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HouseholdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdMemberCreateInput = {
    id?: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutHouseholdMembersInput
    household: HouseholdCreateNestedOneWithoutMembersInput
  }

  export type HouseholdMemberUncheckedCreateInput = {
    id?: string
    userId: string
    householdId: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
  }

  export type HouseholdMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHouseholdMembersNestedInput
    household?: HouseholdUpdateOneRequiredWithoutMembersNestedInput
  }

  export type HouseholdMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdMemberCreateManyInput = {
    id?: string
    userId: string
    householdId: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
  }

  export type HouseholdMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionCreateInput = {
    id?: string
    name: string
    code?: string | null
    logoUrl?: string | null
    country?: string
    type: $Enums.InstitutionType
    createdAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    logoUrl?: string | null
    country?: string
    type: $Enums.InstitutionType
    createdAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    logoUrl?: string | null
    country?: string
    type: $Enums.InstitutionType
    createdAt?: Date | string
  }

  export type InstitutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantCreateInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    color?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutMerchantDataInput
  }

  export type MerchantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    color?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutMerchantDataInput
  }

  export type MerchantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutMerchantDataNestedInput
  }

  export type MerchantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutMerchantDataNestedInput
  }

  export type MerchantCreateManyInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    color?: string | null
    createdAt?: Date | string
  }

  export type MerchantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagCreateInput = {
    tag: string
    transaction: TransactionCreateNestedOneWithoutTagsInput
  }

  export type TransactionTagUncheckedCreateInput = {
    transactionId: string
    tag: string
  }

  export type TransactionTagUpdateInput = {
    tag?: StringFieldUpdateOperationsInput | string
    transaction?: TransactionUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TransactionTagUncheckedUpdateInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionTagCreateManyInput = {
    transactionId: string
    tag: string
  }

  export type TransactionTagUpdateManyMutationInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionTagUncheckedUpdateManyInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionSplitCreateInput = {
    id?: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutSplitsInput
    category: CategoryCreateNestedOneWithoutTransactionSplitsInput
  }

  export type TransactionSplitUncheckedCreateInput = {
    id?: string
    transactionId: string
    categoryId: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionSplitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutSplitsNestedInput
    category?: CategoryUpdateOneRequiredWithoutTransactionSplitsNestedInput
  }

  export type TransactionSplitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSplitCreateManyInput = {
    id?: string
    transactionId: string
    categoryId: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionSplitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSplitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateInput = {
    id?: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutLedgerEntriesInput
    account: AccountCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateInput = {
    id?: string
    transactionId: string
    accountId: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutLedgerEntriesNestedInput
    account?: AccountUpdateOneRequiredWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyInput = {
    id?: string
    transactionId: string
    accountId: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtCreateInput = {
    id?: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint | number
    currentBalanceCents: bigint | number
    currency?: string
    interestRate?: Decimal | DecimalJsLike | number | string | null
    marginRate?: Decimal | DecimalJsLike | number | string | null
    startDate: Date | string
    maturityDate?: Date | string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutDebtsInput
    payments?: DebtPaymentCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateInput = {
    id?: string
    householdId: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint | number
    currentBalanceCents: bigint | number
    currency?: string
    interestRate?: Decimal | DecimalJsLike | number | string | null
    marginRate?: Decimal | DecimalJsLike | number | string | null
    startDate: Date | string
    maturityDate?: Date | string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: DebtPaymentUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutDebtsNestedInput
    payments?: DebtPaymentUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: DebtPaymentUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtCreateManyInput = {
    id?: string
    householdId: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint | number
    currentBalanceCents: bigint | number
    currency?: string
    interestRate?: Decimal | DecimalJsLike | number | string | null
    marginRate?: Decimal | DecimalJsLike | number | string | null
    startDate: Date | string
    maturityDate?: Date | string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentCreateInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    principalAmountCents: bigint | number
    interestAmountCents?: bigint | number
    transactionId?: string | null
    createdAt?: Date | string
    debt: DebtCreateNestedOneWithoutPaymentsInput
  }

  export type DebtPaymentUncheckedCreateInput = {
    id?: string
    debtId: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    principalAmountCents: bigint | number
    interestAmountCents?: bigint | number
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type DebtPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    interestAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debt?: DebtUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type DebtPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    interestAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentCreateManyInput = {
    id?: string
    debtId: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    principalAmountCents: bigint | number
    interestAmountCents?: bigint | number
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type DebtPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    interestAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    interestAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    id?: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint | number
    currency?: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutBudgetsInput
    categories?: BudgetCategoryCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    householdId: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint | number
    currency?: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: BudgetCategoryUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutBudgetsNestedInput
    categories?: BudgetCategoryUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: BudgetCategoryUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: string
    householdId: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint | number
    currency?: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryCreateInput = {
    id?: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    budget: BudgetCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutBudgetCategoriesInput
  }

  export type BudgetCategoryUncheckedCreateInput = {
    id?: string
    budgetId: string
    categoryId: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutBudgetCategoriesNestedInput
  }

  export type BudgetCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryCreateManyInput = {
    id?: string
    budgetId: string
    categoryId: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateInput = {
    id?: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutWishlistItemsInput
    creator: UserCreateNestedOneWithoutCreatedWishlistItemsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateInput = {
    id?: string
    householdId: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutWishlistItemInput
  }

  export type WishlistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutWishlistItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWishlistItemsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutWishlistItemNestedInput
  }

  export type WishlistItemCreateManyInput = {
    id?: string
    householdId: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateInput = {
    id?: string
    priceCents: bigint | number
    currency?: string
    recordedAt?: Date | string
    wishlistItem: WishlistItemCreateNestedOneWithoutPriceHistoryInput
  }

  export type PriceHistoryUncheckedCreateInput = {
    id?: string
    wishlistItemId: string
    priceCents: bigint | number
    currency?: string
    recordedAt?: Date | string
  }

  export type PriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wishlistItem?: WishlistItemUpdateOneRequiredWithoutPriceHistoryNestedInput
  }

  export type PriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wishlistItemId?: StringFieldUpdateOperationsInput | string
    priceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateManyInput = {
    id?: string
    wishlistItemId: string
    priceCents: bigint | number
    currency?: string
    recordedAt?: Date | string
  }

  export type PriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    wishlistItemId?: StringFieldUpdateOperationsInput | string
    priceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryCreateInput = {
    id?: string
    giver: string
    type: $Enums.GratitudeType
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdAt?: Date | string
    household: HouseholdCreateNestedOneWithoutGratitudeEntriesInput
    category?: CategoryCreateNestedOneWithoutGratitudeEntriesInput
    transaction?: TransactionCreateNestedOneWithoutGratitudeEntriesInput
    creator: UserCreateNestedOneWithoutCreatedGratitudeEntriesInput
  }

  export type GratitudeEntryUncheckedCreateInput = {
    id?: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    categoryId?: string | null
    transactionId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdBy: string
    createdAt?: Date | string
  }

  export type GratitudeEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutGratitudeEntriesNestedInput
    category?: CategoryUpdateOneWithoutGratitudeEntriesNestedInput
    transaction?: TransactionUpdateOneWithoutGratitudeEntriesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedGratitudeEntriesNestedInput
  }

  export type GratitudeEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryCreateManyInput = {
    id?: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    categoryId?: string | null
    transactionId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdBy: string
    createdAt?: Date | string
  }

  export type GratitudeEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateCreateInput = {
    id?: string
    fromCurrency: string
    toCurrency: string
    rate: Decimal | DecimalJsLike | number | string
    date: Date | string
    source?: string | null
    createdAt?: Date | string
  }

  export type ExchangeRateUncheckedCreateInput = {
    id?: string
    fromCurrency: string
    toCurrency: string
    rate: Decimal | DecimalJsLike | number | string
    date: Date | string
    source?: string | null
    createdAt?: Date | string
  }

  export type ExchangeRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateCreateManyInput = {
    id?: string
    fromCurrency: string
    toCurrency: string
    rate: Decimal | DecimalJsLike | number | string
    date: Date | string
    source?: string | null
    createdAt?: Date | string
  }

  export type ExchangeRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyCreateInput = {
    id?: string
    name: string
    credentialId: string
    publicKey: string
    counter?: number
    transports?: PasskeyCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPasskeysInput
  }

  export type PasskeyUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    credentialId: string
    publicKey: string
    counter?: number
    transports?: PasskeyCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type PasskeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: PasskeyUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPasskeysNestedInput
  }

  export type PasskeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: PasskeyUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasskeyCreateManyInput = {
    id?: string
    userId: string
    name: string
    credentialId: string
    publicKey: string
    counter?: number
    transports?: PasskeyCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type PasskeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: PasskeyUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasskeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: PasskeyUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEventCreateInput = {
    id?: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutUserEventsInput
    household: HouseholdCreateNestedOneWithoutUserEventsInput
  }

  export type UserEventUncheckedCreateInput = {
    id?: string
    userId: string
    householdId: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type UserEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserEventsNestedInput
    household?: HouseholdUpdateOneRequiredWithoutUserEventsNestedInput
  }

  export type UserEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEventCreateManyInput = {
    id?: string
    userId: string
    householdId: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type UserEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendingPatternCreateInput = {
    id?: string
    userId?: string | null
    patternType: string
    categoryId?: string | null
    merchant?: string | null
    dayOfWeek?: number | null
    hourOfDay?: number | null
    month?: number | null
    averageAmountCents: bigint | number
    frequency: number
    confidenceScore?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
    household: HouseholdCreateNestedOneWithoutSpendingPatternsInput
  }

  export type SpendingPatternUncheckedCreateInput = {
    id?: string
    householdId: string
    userId?: string | null
    patternType: string
    categoryId?: string | null
    merchant?: string | null
    dayOfWeek?: number | null
    hourOfDay?: number | null
    month?: number | null
    averageAmountCents: bigint | number
    frequency: number
    confidenceScore?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
  }

  export type SpendingPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    patternType?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    hourOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    averageAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: IntFieldUpdateOperationsInput | number
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutSpendingPatternsNestedInput
  }

  export type SpendingPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    patternType?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    hourOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    averageAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: IntFieldUpdateOperationsInput | number
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendingPatternCreateManyInput = {
    id?: string
    householdId: string
    userId?: string | null
    patternType: string
    categoryId?: string | null
    merchant?: string | null
    dayOfWeek?: number | null
    hourOfDay?: number | null
    month?: number | null
    averageAmountCents: bigint | number
    frequency: number
    confidenceScore?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
  }

  export type SpendingPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    patternType?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    hourOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    averageAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: IntFieldUpdateOperationsInput | number
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendingPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    patternType?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    hourOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    averageAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: IntFieldUpdateOperationsInput | number
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialInsightCreateInput = {
    id?: string
    insightType: string
    title: string
    description: string
    data?: JsonNullValueInput | InputJsonValue
    priority: $Enums.InsightPriority
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutFinancialInsightsInput
  }

  export type FinancialInsightUncheckedCreateInput = {
    id?: string
    householdId: string
    insightType: string
    title: string
    description: string
    data?: JsonNullValueInput | InputJsonValue
    priority: $Enums.InsightPriority
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActionable?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutFinancialInsightsNestedInput
  }

  export type FinancialInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActionable?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialInsightCreateManyInput = {
    id?: string
    householdId: string
    insightType: string
    title: string
    description: string
    data?: JsonNullValueInput | InputJsonValue
    priority: $Enums.InsightPriority
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActionable?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActionable?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionCreateInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutRecurringTransactionsInput
    account: AccountCreateNestedOneWithoutRecurringTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutRecurringTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutRecurringTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedRecurringTransactionsInput
    executions?: RecurringTransactionExecutionCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionUncheckedCreateInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutRecurringTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutRecurringTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringTransactionsNestedInput
    executions?: RecurringTransactionExecutionUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionCreateManyInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionExecutionCreateInput = {
    id?: string
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    recurringTransaction: RecurringTransactionCreateNestedOneWithoutExecutionsInput
    transaction?: TransactionCreateNestedOneWithoutRecurringTransactionExecutionsInput
  }

  export type RecurringTransactionExecutionUncheckedCreateInput = {
    id?: string
    recurringTransactionId: string
    transactionId?: string | null
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recurringTransaction?: RecurringTransactionUpdateOneRequiredWithoutExecutionsNestedInput
    transaction?: TransactionUpdateOneWithoutRecurringTransactionExecutionsNestedInput
  }

  export type RecurringTransactionExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recurringTransactionId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionExecutionCreateManyInput = {
    id?: string
    recurringTransactionId: string
    transactionId?: string | null
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recurringTransactionId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUploadCreateInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutDocumentUploadsInput
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
    ocrResults?: OcrResultCreateNestedManyWithoutDocumentInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadUncheckedCreateInput = {
    id?: string
    householdId: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedBy: string
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ocrResults?: OcrResultUncheckedCreateNestedManyWithoutDocumentInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutDocumentUploadsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
    ocrResults?: OcrResultUpdateManyWithoutDocumentNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUploadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ocrResults?: OcrResultUncheckedUpdateManyWithoutDocumentNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUploadCreateManyInput = {
    id?: string
    householdId: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedBy: string
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUploadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUploadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OcrResultCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    confidence: Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText: string
    processedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    document: DocumentUploadCreateNestedOneWithoutOcrResultsInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutOcrResultInput
  }

  export type OcrResultUncheckedCreateInput = {
    id?: string
    documentId: string
    documentType: $Enums.DocumentType
    confidence: Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText: string
    processedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutOcrResultInput
  }

  export type OcrResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUploadUpdateOneRequiredWithoutOcrResultsNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutOcrResultNestedInput
  }

  export type OcrResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutOcrResultNestedInput
  }

  export type OcrResultCreateManyInput = {
    id?: string
    documentId: string
    documentType: $Enums.DocumentType
    confidence: Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText: string
    processedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OcrResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OcrResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionCreateInput = {
    id?: string
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentUploadCreateNestedOneWithoutTransactionSuggestionsInput
    ocrResult?: OcrResultCreateNestedOneWithoutTransactionSuggestionsInput
    suggestedCategory?: CategoryCreateNestedOneWithoutTransactionSuggestionsInput
    createdTransaction?: TransactionCreateNestedOneWithoutCreatedFromSuggestionInput
  }

  export type TransactionSuggestionUncheckedCreateInput = {
    id?: string
    documentId: string
    ocrResultId?: string | null
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryId?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionSuggestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUploadUpdateOneRequiredWithoutTransactionSuggestionsNestedInput
    ocrResult?: OcrResultUpdateOneWithoutTransactionSuggestionsNestedInput
    suggestedCategory?: CategoryUpdateOneWithoutTransactionSuggestionsNestedInput
    createdTransaction?: TransactionUpdateOneWithoutCreatedFromSuggestionNestedInput
  }

  export type TransactionSuggestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    ocrResultId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionCreateManyInput = {
    id?: string
    documentId: string
    ocrResultId?: string | null
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryId?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionSuggestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    ocrResultId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatCalculationCreateInput = {
    id?: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutZakatCalculationsInput
    assetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutZakatCalculationInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutZakatCalculationInput
  }

  export type ZakatCalculationUncheckedCreateInput = {
    id?: string
    householdId: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutZakatCalculationInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutZakatCalculationInput
  }

  export type ZakatCalculationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutZakatCalculationsNestedInput
    assetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutZakatCalculationNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutZakatCalculationNestedInput
  }

  export type ZakatCalculationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutZakatCalculationNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutZakatCalculationNestedInput
  }

  export type ZakatCalculationCreateManyInput = {
    id?: string
    householdId: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatCalculationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatCalculationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatAssetBreakdownCreateInput = {
    id?: string
    assetType: $Enums.ZakatAssetType
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    zakatCalculation: ZakatCalculationCreateNestedOneWithoutAssetBreakdownInput
    account?: AccountCreateNestedOneWithoutZakatAssetBreakdownInput
  }

  export type ZakatAssetBreakdownUncheckedCreateInput = {
    id?: string
    zakatCalculationId: string
    assetType: $Enums.ZakatAssetType
    accountId?: string | null
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatAssetBreakdownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zakatCalculation?: ZakatCalculationUpdateOneRequiredWithoutAssetBreakdownNestedInput
    account?: AccountUpdateOneWithoutZakatAssetBreakdownNestedInput
  }

  export type ZakatAssetBreakdownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatAssetBreakdownCreateManyInput = {
    id?: string
    zakatCalculationId: string
    assetType: $Enums.ZakatAssetType
    accountId?: string | null
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatAssetBreakdownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatAssetBreakdownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatReminderCreateInput = {
    id?: string
    reminderType: $Enums.ZakatReminderType
    scheduledDate: Date | string
    hijriDate: string
    zakatAmountCents?: bigint | number | null
    currency?: string | null
    message: string
    isActive?: boolean
    isSent?: boolean
    sentAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutZakatRemindersInput
  }

  export type ZakatReminderUncheckedCreateInput = {
    id?: string
    householdId: string
    reminderType: $Enums.ZakatReminderType
    scheduledDate: Date | string
    hijriDate: string
    zakatAmountCents?: bigint | number | null
    currency?: string | null
    message: string
    isActive?: boolean
    isSent?: boolean
    sentAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumZakatReminderTypeFieldUpdateOperationsInput | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    zakatAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutZakatRemindersNestedInput
  }

  export type ZakatReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumZakatReminderTypeFieldUpdateOperationsInput | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    zakatAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatReminderCreateManyInput = {
    id?: string
    householdId: string
    reminderType: $Enums.ZakatReminderType
    scheduledDate: Date | string
    hijriDate: string
    zakatAmountCents?: bigint | number | null
    currency?: string | null
    message: string
    isActive?: boolean
    isSent?: boolean
    sentAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumZakatReminderTypeFieldUpdateOperationsInput | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    zakatAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumZakatReminderTypeFieldUpdateOperationsInput | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    zakatAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentCreateInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    zakatCalculation?: ZakatCalculationCreateNestedOneWithoutZakatPaymentsInput
    household: HouseholdCreateNestedOneWithoutZakatPaymentsInput
    transaction?: TransactionCreateNestedOneWithoutZakatPaymentsInput
  }

  export type ZakatPaymentUncheckedCreateInput = {
    id?: string
    zakatCalculationId?: string | null
    householdId: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    transactionId?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zakatCalculation?: ZakatCalculationUpdateOneWithoutZakatPaymentsNestedInput
    household?: HouseholdUpdateOneRequiredWithoutZakatPaymentsNestedInput
    transaction?: TransactionUpdateOneWithoutZakatPaymentsNestedInput
  }

  export type ZakatPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentCreateManyInput = {
    id?: string
    zakatCalculationId?: string | null
    householdId: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    transactionId?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShariaCompliantAccountCreateInput = {
    id?: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes?: string | null
    lastReviewDate: Date | string
    nextReviewDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutShariaComplianceInput
    reviewer?: UserCreateNestedOneWithoutShariaReviewsInput
  }

  export type ShariaCompliantAccountUncheckedCreateInput = {
    id?: string
    accountId: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes?: string | null
    lastReviewDate: Date | string
    nextReviewDate: Date | string
    reviewedBy?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShariaCompliantAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutShariaComplianceNestedInput
    reviewer?: UserUpdateOneWithoutShariaReviewsNestedInput
  }

  export type ShariaCompliantAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShariaCompliantAccountCreateManyInput = {
    id?: string
    accountId: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes?: string | null
    lastReviewDate: Date | string
    nextReviewDate: Date | string
    reviewedBy?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShariaCompliantAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShariaCompliantAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IslamicFinanceReportCreateInput = {
    id?: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    household: HouseholdCreateNestedOneWithoutIslamicFinanceReportsInput
    generator?: UserCreateNestedOneWithoutGeneratedIslamicReportsInput
  }

  export type IslamicFinanceReportUncheckedCreateInput = {
    id?: string
    householdId: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IslamicFinanceReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutIslamicFinanceReportsNestedInput
    generator?: UserUpdateOneWithoutGeneratedIslamicReportsNestedInput
  }

  export type IslamicFinanceReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IslamicFinanceReportCreateManyInput = {
    id?: string
    householdId: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IslamicFinanceReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IslamicFinanceReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    household: HouseholdCreateNestedOneWithoutNotificationsInput
    deliveries?: NotificationDeliveryCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    householdId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    household?: HouseholdUpdateOneRequiredWithoutNotificationsNestedInput
    deliveries?: NotificationDeliveryUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    householdId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDeliveryCreateInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    deliveredAt?: Date | string | null
    failureReason?: string | null
    retryCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutDeliveriesInput
  }

  export type NotificationDeliveryUncheckedCreateInput = {
    id?: string
    notificationId: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    deliveredAt?: Date | string | null
    failureReason?: string | null
    retryCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type NotificationDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDeliveryCreateManyInput = {
    id?: string
    notificationId: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    deliveredAt?: Date | string | null
    failureReason?: string | null
    retryCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPushSubscriptionsInput
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    type: $Enums.NotificationType
    subject: string
    htmlContent: string
    textContent: string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.NotificationType
    subject: string
    htmlContent: string
    textContent: string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    type: $Enums.NotificationType
    subject: string
    htmlContent: string
    textContent: string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    textContent?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type HouseholdMemberListRelationFilter = {
    every?: HouseholdMemberWhereInput
    some?: HouseholdMemberWhereInput
    none?: HouseholdMemberWhereInput
  }

  export type PasskeyListRelationFilter = {
    every?: PasskeyWhereInput
    some?: PasskeyWhereInput
    none?: PasskeyWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type WishlistItemListRelationFilter = {
    every?: WishlistItemWhereInput
    some?: WishlistItemWhereInput
    none?: WishlistItemWhereInput
  }

  export type GratitudeEntryListRelationFilter = {
    every?: GratitudeEntryWhereInput
    some?: GratitudeEntryWhereInput
    none?: GratitudeEntryWhereInput
  }

  export type RecurringTransactionListRelationFilter = {
    every?: RecurringTransactionWhereInput
    some?: RecurringTransactionWhereInput
    none?: RecurringTransactionWhereInput
  }

  export type DocumentUploadListRelationFilter = {
    every?: DocumentUploadWhereInput
    some?: DocumentUploadWhereInput
    none?: DocumentUploadWhereInput
  }

  export type UserEventListRelationFilter = {
    every?: UserEventWhereInput
    some?: UserEventWhereInput
    none?: UserEventWhereInput
  }

  export type ShariaCompliantAccountListRelationFilter = {
    every?: ShariaCompliantAccountWhereInput
    some?: ShariaCompliantAccountWhereInput
    none?: ShariaCompliantAccountWhereInput
  }

  export type IslamicFinanceReportListRelationFilter = {
    every?: IslamicFinanceReportWhereInput
    some?: IslamicFinanceReportWhereInput
    none?: IslamicFinanceReportWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput
    some?: PushSubscriptionWhereInput
    none?: PushSubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type HouseholdMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasskeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GratitudeEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentUploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShariaCompliantAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IslamicFinanceReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type DebtListRelationFilter = {
    every?: DebtWhereInput
    some?: DebtWhereInput
    none?: DebtWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type SpendingPatternListRelationFilter = {
    every?: SpendingPatternWhereInput
    some?: SpendingPatternWhereInput
    none?: SpendingPatternWhereInput
  }

  export type FinancialInsightListRelationFilter = {
    every?: FinancialInsightWhereInput
    some?: FinancialInsightWhereInput
    none?: FinancialInsightWhereInput
  }

  export type ZakatCalculationListRelationFilter = {
    every?: ZakatCalculationWhereInput
    some?: ZakatCalculationWhereInput
    none?: ZakatCalculationWhereInput
  }

  export type ZakatReminderListRelationFilter = {
    every?: ZakatReminderWhereInput
    some?: ZakatReminderWhereInput
    none?: ZakatReminderWhereInput
  }

  export type ZakatPaymentListRelationFilter = {
    every?: ZakatPaymentWhereInput
    some?: ZakatPaymentWhereInput
    none?: ZakatPaymentWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpendingPatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialInsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZakatCalculationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZakatReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZakatPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HouseholdCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HouseholdMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HouseholdMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumHouseholdRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRole | EnumHouseholdRoleFieldRefInput<$PrismaModel>
    in?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumHouseholdRoleFilter<$PrismaModel> | $Enums.HouseholdRole
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type HouseholdScalarRelationFilter = {
    is?: HouseholdWhereInput
    isNot?: HouseholdWhereInput
  }

  export type HouseholdMemberUserIdHouseholdIdCompoundUniqueInput = {
    userId: string
    householdId: string
  }

  export type HouseholdMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
  }

  export type HouseholdMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type HouseholdMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumHouseholdRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRole | EnumHouseholdRoleFieldRefInput<$PrismaModel>
    in?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumHouseholdRoleWithAggregatesFilter<$PrismaModel> | $Enums.HouseholdRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHouseholdRoleFilter<$PrismaModel>
    _max?: NestedEnumHouseholdRoleFilter<$PrismaModel>
  }

  export type EnumInstitutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeFilter<$PrismaModel> | $Enums.InstitutionType
  }

  export type InstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
    country?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
    country?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type InstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    logoUrl?: SortOrder
    country?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInstitutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionTypeFilter<$PrismaModel>
    _max?: NestedEnumInstitutionTypeFilter<$PrismaModel>
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type InstitutionNullableScalarRelationFilter = {
    is?: InstitutionWhereInput | null
    isNot?: InstitutionWhereInput | null
  }

  export type LedgerEntryListRelationFilter = {
    every?: LedgerEntryWhereInput
    some?: LedgerEntryWhereInput
    none?: LedgerEntryWhereInput
  }

  export type ZakatAssetBreakdownListRelationFilter = {
    every?: ZakatAssetBreakdownWhereInput
    some?: ZakatAssetBreakdownWhereInput
    none?: ZakatAssetBreakdownWhereInput
  }

  export type ShariaCompliantAccountNullableScalarRelationFilter = {
    is?: ShariaCompliantAccountWhereInput | null
    isNot?: ShariaCompliantAccountWhereInput | null
  }

  export type LedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZakatAssetBreakdownOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    currency?: SortOrder
    institutionId?: SortOrder
    accountNumber?: SortOrder
    balanceCents?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    balanceCents?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    currency?: SortOrder
    institutionId?: SortOrder
    accountNumber?: SortOrder
    balanceCents?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subtype?: SortOrder
    currency?: SortOrder
    institutionId?: SortOrder
    accountNumber?: SortOrder
    balanceCents?: SortOrder
    isActive?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    balanceCents?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type MerchantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type MerchantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type MerchantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCategoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeFilter<$PrismaModel> | $Enums.CategoryType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type HouseholdNullableScalarRelationFilter = {
    is?: HouseholdWhereInput | null
    isNot?: HouseholdWhereInput | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type TransactionSplitListRelationFilter = {
    every?: TransactionSplitWhereInput
    some?: TransactionSplitWhereInput
    none?: TransactionSplitWhereInput
  }

  export type BudgetCategoryListRelationFilter = {
    every?: BudgetCategoryWhereInput
    some?: BudgetCategoryWhereInput
    none?: BudgetCategoryWhereInput
  }

  export type TransactionSuggestionListRelationFilter = {
    every?: TransactionSuggestionWhereInput
    some?: TransactionSuggestionWhereInput
    none?: TransactionSuggestionWhereInput
  }

  export type TransactionSplitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionSuggestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryHouseholdIdSlugCompoundUniqueInput = {
    householdId: string
    slug: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    householdId?: SortOrder
    isActive?: SortOrder
    isEditable?: SortOrder
    isArchived?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    householdId?: SortOrder
    isActive?: SortOrder
    isEditable?: SortOrder
    isArchived?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    householdId?: SortOrder
    isActive?: SortOrder
    isEditable?: SortOrder
    isArchived?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumCategoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.CategoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryTypeFilter<$PrismaModel>
    _max?: NestedEnumCategoryTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type MerchantNullableScalarRelationFilter = {
    is?: MerchantWhereInput | null
    isNot?: MerchantWhereInput | null
  }

  export type TransactionTagListRelationFilter = {
    every?: TransactionTagWhereInput
    some?: TransactionTagWhereInput
    none?: TransactionTagWhereInput
  }

  export type RecurringTransactionExecutionListRelationFilter = {
    every?: RecurringTransactionExecutionWhereInput
    some?: RecurringTransactionExecutionWhereInput
    none?: RecurringTransactionExecutionWhereInput
  }

  export type TransactionTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringTransactionExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    originalAmountCents?: SortOrder
    originalCurrency?: SortOrder
    exchangeRate?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    merchantId?: SortOrder
    merchantName?: SortOrder
    merchantLogoUrl?: SortOrder
    merchantColor?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrder
    receiptUrl?: SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amountCents?: SortOrder
    originalAmountCents?: SortOrder
    exchangeRate?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    originalAmountCents?: SortOrder
    originalCurrency?: SortOrder
    exchangeRate?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    merchantId?: SortOrder
    merchantName?: SortOrder
    merchantLogoUrl?: SortOrder
    merchantColor?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrder
    receiptUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    originalAmountCents?: SortOrder
    originalCurrency?: SortOrder
    exchangeRate?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    merchantId?: SortOrder
    merchantName?: SortOrder
    merchantLogoUrl?: SortOrder
    merchantColor?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrder
    receiptUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amountCents?: SortOrder
    originalAmountCents?: SortOrder
    exchangeRate?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type TransactionTagTransactionIdTagCompoundUniqueInput = {
    transactionId: string
    tag: string
  }

  export type TransactionTagCountOrderByAggregateInput = {
    transactionId?: SortOrder
    tag?: SortOrder
  }

  export type TransactionTagMaxOrderByAggregateInput = {
    transactionId?: SortOrder
    tag?: SortOrder
  }

  export type TransactionTagMinOrderByAggregateInput = {
    transactionId?: SortOrder
    tag?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type TransactionSplitCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    categoryId?: SortOrder
    amountCents?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSplitAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type TransactionSplitMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    categoryId?: SortOrder
    amountCents?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSplitMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    categoryId?: SortOrder
    amountCents?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSplitSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type EnumLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTypeFilter<$PrismaModel> | $Enums.LedgerType
  }

  export type LedgerEntryCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type LedgerEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntrySumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type EnumLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerTypeFilter<$PrismaModel>
  }

  export type EnumDebtTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DebtType | EnumDebtTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DebtType[] | ListEnumDebtTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebtType[] | ListEnumDebtTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDebtTypeFilter<$PrismaModel> | $Enums.DebtType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DebtPaymentListRelationFilter = {
    every?: DebtPaymentWhereInput
    some?: DebtPaymentWhereInput
    none?: DebtPaymentWhereInput
  }

  export type DebtPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    creditor?: SortOrder
    principalAmountCents?: SortOrder
    currentBalanceCents?: SortOrder
    currency?: SortOrder
    interestRate?: SortOrder
    marginRate?: SortOrder
    startDate?: SortOrder
    maturityDate?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtAvgOrderByAggregateInput = {
    principalAmountCents?: SortOrder
    currentBalanceCents?: SortOrder
    interestRate?: SortOrder
    marginRate?: SortOrder
  }

  export type DebtMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    creditor?: SortOrder
    principalAmountCents?: SortOrder
    currentBalanceCents?: SortOrder
    currency?: SortOrder
    interestRate?: SortOrder
    marginRate?: SortOrder
    startDate?: SortOrder
    maturityDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    creditor?: SortOrder
    principalAmountCents?: SortOrder
    currentBalanceCents?: SortOrder
    currency?: SortOrder
    interestRate?: SortOrder
    marginRate?: SortOrder
    startDate?: SortOrder
    maturityDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtSumOrderByAggregateInput = {
    principalAmountCents?: SortOrder
    currentBalanceCents?: SortOrder
    interestRate?: SortOrder
    marginRate?: SortOrder
  }

  export type EnumDebtTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DebtType | EnumDebtTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DebtType[] | ListEnumDebtTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebtType[] | ListEnumDebtTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDebtTypeWithAggregatesFilter<$PrismaModel> | $Enums.DebtType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDebtTypeFilter<$PrismaModel>
    _max?: NestedEnumDebtTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DebtScalarRelationFilter = {
    is?: DebtWhereInput
    isNot?: DebtWhereInput
  }

  export type DebtPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    principalAmountCents?: SortOrder
    interestAmountCents?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtPaymentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
    principalAmountCents?: SortOrder
    interestAmountCents?: SortOrder
  }

  export type DebtPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    principalAmountCents?: SortOrder
    interestAmountCents?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    debtId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    principalAmountCents?: SortOrder
    interestAmountCents?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type DebtPaymentSumOrderByAggregateInput = {
    amountCents?: SortOrder
    principalAmountCents?: SortOrder
    interestAmountCents?: SortOrder
  }

  export type EnumBudgetPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodFilter<$PrismaModel> | $Enums.BudgetPeriod
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    period?: SortOrder
    totalAllocatedCents?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    totalAllocatedCents?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    period?: SortOrder
    totalAllocatedCents?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    period?: SortOrder
    totalAllocatedCents?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    totalAllocatedCents?: SortOrder
  }

  export type EnumBudgetPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel> | $Enums.BudgetPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetPeriodFilter<$PrismaModel>
    _max?: NestedEnumBudgetPeriodFilter<$PrismaModel>
  }

  export type BudgetScalarRelationFilter = {
    is?: BudgetWhereInput
    isNot?: BudgetWhereInput
  }

  export type BudgetCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    allocatedAmountCents?: SortOrder
    spentAmountCents?: SortOrder
    carryOverCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetCategoryAvgOrderByAggregateInput = {
    allocatedAmountCents?: SortOrder
    spentAmountCents?: SortOrder
    carryOverCents?: SortOrder
  }

  export type BudgetCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    allocatedAmountCents?: SortOrder
    spentAmountCents?: SortOrder
    carryOverCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    allocatedAmountCents?: SortOrder
    spentAmountCents?: SortOrder
    carryOverCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetCategorySumOrderByAggregateInput = {
    allocatedAmountCents?: SortOrder
    spentAmountCents?: SortOrder
    carryOverCents?: SortOrder
  }

  export type PriceHistoryListRelationFilter = {
    every?: PriceHistoryWhereInput
    some?: PriceHistoryWhereInput
    none?: PriceHistoryWhereInput
  }

  export type PriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistItemCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    currentPriceCents?: SortOrder
    targetPriceCents?: SortOrder
    currency?: SortOrder
    imageUrl?: SortOrder
    merchant?: SortOrder
    linkedGoalId?: SortOrder
    isPurchased?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistItemAvgOrderByAggregateInput = {
    currentPriceCents?: SortOrder
    targetPriceCents?: SortOrder
  }

  export type WishlistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    currentPriceCents?: SortOrder
    targetPriceCents?: SortOrder
    currency?: SortOrder
    imageUrl?: SortOrder
    merchant?: SortOrder
    linkedGoalId?: SortOrder
    isPurchased?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistItemMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    currentPriceCents?: SortOrder
    targetPriceCents?: SortOrder
    currency?: SortOrder
    imageUrl?: SortOrder
    merchant?: SortOrder
    linkedGoalId?: SortOrder
    isPurchased?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistItemSumOrderByAggregateInput = {
    currentPriceCents?: SortOrder
    targetPriceCents?: SortOrder
  }

  export type WishlistItemScalarRelationFilter = {
    is?: WishlistItemWhereInput
    isNot?: WishlistItemWhereInput
  }

  export type PriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    wishlistItemId?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    recordedAt?: SortOrder
  }

  export type PriceHistoryAvgOrderByAggregateInput = {
    priceCents?: SortOrder
  }

  export type PriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    wishlistItemId?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    recordedAt?: SortOrder
  }

  export type PriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    wishlistItemId?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    recordedAt?: SortOrder
  }

  export type PriceHistorySumOrderByAggregateInput = {
    priceCents?: SortOrder
  }

  export type EnumGratitudeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GratitudeType | EnumGratitudeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GratitudeType[] | ListEnumGratitudeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GratitudeType[] | ListEnumGratitudeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGratitudeTypeFilter<$PrismaModel> | $Enums.GratitudeType
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type GratitudeEntryCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    giver?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    transactionId?: SortOrder
    estimatedValueCents?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type GratitudeEntryAvgOrderByAggregateInput = {
    estimatedValueCents?: SortOrder
  }

  export type GratitudeEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    giver?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    transactionId?: SortOrder
    estimatedValueCents?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type GratitudeEntryMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    giver?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    transactionId?: SortOrder
    estimatedValueCents?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type GratitudeEntrySumOrderByAggregateInput = {
    estimatedValueCents?: SortOrder
  }

  export type EnumGratitudeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GratitudeType | EnumGratitudeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GratitudeType[] | ListEnumGratitudeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GratitudeType[] | ListEnumGratitudeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGratitudeTypeWithAggregatesFilter<$PrismaModel> | $Enums.GratitudeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGratitudeTypeFilter<$PrismaModel>
    _max?: NestedEnumGratitudeTypeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ExchangeRateFromCurrencyToCurrencyDateCompoundUniqueInput = {
    fromCurrency: string
    toCurrency: string
    date: Date | string
  }

  export type ExchangeRateCountOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type ExchangeRateAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type ExchangeRateMaxOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type ExchangeRateMinOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type ExchangeRateSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PasskeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type PasskeyAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type PasskeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type PasskeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type PasskeySumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type UserEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type UserEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    eventType?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type UserEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    eventType?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type SpendingPatternCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    dayOfWeek?: SortOrder
    hourOfDay?: SortOrder
    month?: SortOrder
    averageAmountCents?: SortOrder
    frequency?: SortOrder
    confidenceScore?: SortOrder
    lastUpdated?: SortOrder
  }

  export type SpendingPatternAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    hourOfDay?: SortOrder
    month?: SortOrder
    averageAmountCents?: SortOrder
    frequency?: SortOrder
    confidenceScore?: SortOrder
  }

  export type SpendingPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    dayOfWeek?: SortOrder
    hourOfDay?: SortOrder
    month?: SortOrder
    averageAmountCents?: SortOrder
    frequency?: SortOrder
    confidenceScore?: SortOrder
    lastUpdated?: SortOrder
  }

  export type SpendingPatternMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    dayOfWeek?: SortOrder
    hourOfDay?: SortOrder
    month?: SortOrder
    averageAmountCents?: SortOrder
    frequency?: SortOrder
    confidenceScore?: SortOrder
    lastUpdated?: SortOrder
  }

  export type SpendingPatternSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    hourOfDay?: SortOrder
    month?: SortOrder
    averageAmountCents?: SortOrder
    frequency?: SortOrder
    confidenceScore?: SortOrder
  }

  export type EnumInsightPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightPriority | EnumInsightPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightPriorityFilter<$PrismaModel> | $Enums.InsightPriority
  }

  export type FinancialInsightCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    isActionable?: SortOrder
    isDismissed?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isActionable?: SortOrder
    isDismissed?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialInsightMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isActionable?: SortOrder
    isDismissed?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInsightPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightPriority | EnumInsightPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightPriorityWithAggregatesFilter<$PrismaModel> | $Enums.InsightPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightPriorityFilter<$PrismaModel>
    _max?: NestedEnumInsightPriorityFilter<$PrismaModel>
  }

  export type EnumRecurrenceFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFrequency | EnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel> | $Enums.RecurrenceFrequency
  }

  export type EnumRecurringTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringTransactionStatus | EnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringTransactionStatus[] | ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringTransactionStatus[] | ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringTransactionStatusFilter<$PrismaModel> | $Enums.RecurringTransactionStatus
  }

  export type RecurringTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    frequency?: SortOrder
    intervalValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextExecutionDate?: SortOrder
    lastExecutionDate?: SortOrder
    executionCount?: SortOrder
    maxExecutions?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTransactionAvgOrderByAggregateInput = {
    amountCents?: SortOrder
    intervalValue?: SortOrder
    executionCount?: SortOrder
    maxExecutions?: SortOrder
  }

  export type RecurringTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    frequency?: SortOrder
    intervalValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextExecutionDate?: SortOrder
    lastExecutionDate?: SortOrder
    executionCount?: SortOrder
    maxExecutions?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    accountId?: SortOrder
    transferAccountId?: SortOrder
    categoryId?: SortOrder
    merchant?: SortOrder
    frequency?: SortOrder
    intervalValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextExecutionDate?: SortOrder
    lastExecutionDate?: SortOrder
    executionCount?: SortOrder
    maxExecutions?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTransactionSumOrderByAggregateInput = {
    amountCents?: SortOrder
    intervalValue?: SortOrder
    executionCount?: SortOrder
    maxExecutions?: SortOrder
  }

  export type EnumRecurrenceFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFrequency | EnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.RecurrenceFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel>
  }

  export type EnumRecurringTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringTransactionStatus | EnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringTransactionStatus[] | ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringTransactionStatus[] | ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecurringTransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurringTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumRecurringTransactionStatusFilter<$PrismaModel>
  }

  export type RecurringTransactionScalarRelationFilter = {
    is?: RecurringTransactionWhereInput
    isNot?: RecurringTransactionWhereInput
  }

  export type RecurringTransactionExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    recurringTransactionId?: SortOrder
    transactionId?: SortOrder
    scheduledDate?: SortOrder
    executedDate?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTransactionExecutionAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type RecurringTransactionExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    recurringTransactionId?: SortOrder
    transactionId?: SortOrder
    scheduledDate?: SortOrder
    executedDate?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTransactionExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    recurringTransactionId?: SortOrder
    transactionId?: SortOrder
    scheduledDate?: SortOrder
    executedDate?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringTransactionExecutionSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type OcrResultListRelationFilter = {
    every?: OcrResultWhereInput
    some?: OcrResultWhereInput
    none?: OcrResultWhereInput
  }

  export type OcrResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentUploadCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    documentType?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrder
    storageUrl?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentUploadAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentUploadMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    documentType?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrder
    storageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentUploadMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    documentType?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrder
    storageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentUploadSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type DocumentUploadScalarRelationFilter = {
    is?: DocumentUploadWhereInput
    isNot?: DocumentUploadWhereInput
  }

  export type OcrResultCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    confidence?: SortOrder
    extractedData?: SortOrder
    rawText?: SortOrder
    processedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type OcrResultAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type OcrResultMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    confidence?: SortOrder
    rawText?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OcrResultMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    confidence?: SortOrder
    rawText?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OcrResultSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type OcrResultNullableScalarRelationFilter = {
    is?: OcrResultWhereInput | null
    isNot?: OcrResultWhereInput | null
  }

  export type TransactionSuggestionCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    ocrResultId?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    merchant?: SortOrder
    suggestedCategoryId?: SortOrder
    suggestedCategoryName?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    status?: SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrder
    metadata?: SortOrder
    createdTransactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSuggestionAvgOrderByAggregateInput = {
    amountCents?: SortOrder
    confidence?: SortOrder
  }

  export type TransactionSuggestionMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    ocrResultId?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    merchant?: SortOrder
    suggestedCategoryId?: SortOrder
    suggestedCategoryName?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    status?: SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrder
    createdTransactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSuggestionMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    ocrResultId?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    merchant?: SortOrder
    suggestedCategoryId?: SortOrder
    suggestedCategoryName?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    status?: SortOrder
    isApproved?: SortOrder
    approvedAt?: SortOrder
    createdTransactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSuggestionSumOrderByAggregateInput = {
    amountCents?: SortOrder
    confidence?: SortOrder
  }

  export type ZakatCalculationCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    calculationDate?: SortOrder
    hijriYear?: SortOrder
    nisabThresholdCents?: SortOrder
    totalZakatableAssetsCents?: SortOrder
    zakatAmountCents?: SortOrder
    currency?: SortOrder
    isZakatDue?: SortOrder
    nextCalculationDate?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZakatCalculationAvgOrderByAggregateInput = {
    hijriYear?: SortOrder
    nisabThresholdCents?: SortOrder
    totalZakatableAssetsCents?: SortOrder
    zakatAmountCents?: SortOrder
  }

  export type ZakatCalculationMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    calculationDate?: SortOrder
    hijriYear?: SortOrder
    nisabThresholdCents?: SortOrder
    totalZakatableAssetsCents?: SortOrder
    zakatAmountCents?: SortOrder
    currency?: SortOrder
    isZakatDue?: SortOrder
    nextCalculationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZakatCalculationMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    calculationDate?: SortOrder
    hijriYear?: SortOrder
    nisabThresholdCents?: SortOrder
    totalZakatableAssetsCents?: SortOrder
    zakatAmountCents?: SortOrder
    currency?: SortOrder
    isZakatDue?: SortOrder
    nextCalculationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZakatCalculationSumOrderByAggregateInput = {
    hijriYear?: SortOrder
    nisabThresholdCents?: SortOrder
    totalZakatableAssetsCents?: SortOrder
    zakatAmountCents?: SortOrder
  }

  export type EnumZakatAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZakatAssetType | EnumZakatAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZakatAssetType[] | ListEnumZakatAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZakatAssetType[] | ListEnumZakatAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZakatAssetTypeFilter<$PrismaModel> | $Enums.ZakatAssetType
  }

  export type ZakatCalculationScalarRelationFilter = {
    is?: ZakatCalculationWhereInput
    isNot?: ZakatCalculationWhereInput
  }

  export type ZakatAssetBreakdownCountOrderByAggregateInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrder
    assetType?: SortOrder
    accountId?: SortOrder
    accountName?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    zakatRate?: SortOrder
    zakatAmountCents?: SortOrder
    haulCompleted?: SortOrder
    haulStartDate?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ZakatAssetBreakdownAvgOrderByAggregateInput = {
    amountCents?: SortOrder
    zakatRate?: SortOrder
    zakatAmountCents?: SortOrder
  }

  export type ZakatAssetBreakdownMaxOrderByAggregateInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrder
    assetType?: SortOrder
    accountId?: SortOrder
    accountName?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    zakatRate?: SortOrder
    zakatAmountCents?: SortOrder
    haulCompleted?: SortOrder
    haulStartDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ZakatAssetBreakdownMinOrderByAggregateInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrder
    assetType?: SortOrder
    accountId?: SortOrder
    accountName?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    zakatRate?: SortOrder
    zakatAmountCents?: SortOrder
    haulCompleted?: SortOrder
    haulStartDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ZakatAssetBreakdownSumOrderByAggregateInput = {
    amountCents?: SortOrder
    zakatRate?: SortOrder
    zakatAmountCents?: SortOrder
  }

  export type EnumZakatAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZakatAssetType | EnumZakatAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZakatAssetType[] | ListEnumZakatAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZakatAssetType[] | ListEnumZakatAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZakatAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZakatAssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZakatAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumZakatAssetTypeFilter<$PrismaModel>
  }

  export type EnumZakatReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZakatReminderType | EnumZakatReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZakatReminderType[] | ListEnumZakatReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZakatReminderType[] | ListEnumZakatReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZakatReminderTypeFilter<$PrismaModel> | $Enums.ZakatReminderType
  }

  export type ZakatReminderCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    reminderType?: SortOrder
    scheduledDate?: SortOrder
    hijriDate?: SortOrder
    zakatAmountCents?: SortOrder
    currency?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    isSent?: SortOrder
    sentAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZakatReminderAvgOrderByAggregateInput = {
    zakatAmountCents?: SortOrder
  }

  export type ZakatReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    reminderType?: SortOrder
    scheduledDate?: SortOrder
    hijriDate?: SortOrder
    zakatAmountCents?: SortOrder
    currency?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    isSent?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZakatReminderMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    reminderType?: SortOrder
    scheduledDate?: SortOrder
    hijriDate?: SortOrder
    zakatAmountCents?: SortOrder
    currency?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    isSent?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZakatReminderSumOrderByAggregateInput = {
    zakatAmountCents?: SortOrder
  }

  export type EnumZakatReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZakatReminderType | EnumZakatReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZakatReminderType[] | ListEnumZakatReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZakatReminderType[] | ListEnumZakatReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZakatReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZakatReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZakatReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumZakatReminderTypeFilter<$PrismaModel>
  }

  export type ZakatCalculationNullableScalarRelationFilter = {
    is?: ZakatCalculationWhereInput | null
    isNot?: ZakatCalculationWhereInput | null
  }

  export type ZakatPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    hijriDate?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ZakatPaymentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type ZakatPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    hijriDate?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ZakatPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    zakatCalculationId?: SortOrder
    householdId?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    hijriDate?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ZakatPaymentSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type EnumShariaComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShariaComplianceStatus | EnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShariaComplianceStatus[] | ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShariaComplianceStatus[] | ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShariaComplianceStatusFilter<$PrismaModel> | $Enums.ShariaComplianceStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ShariaCompliantAccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    complianceStatus?: SortOrder
    complianceNotes?: SortOrder
    lastReviewDate?: SortOrder
    nextReviewDate?: SortOrder
    reviewedBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShariaCompliantAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    complianceStatus?: SortOrder
    complianceNotes?: SortOrder
    lastReviewDate?: SortOrder
    nextReviewDate?: SortOrder
    reviewedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShariaCompliantAccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    complianceStatus?: SortOrder
    complianceNotes?: SortOrder
    lastReviewDate?: SortOrder
    nextReviewDate?: SortOrder
    reviewedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumShariaComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShariaComplianceStatus | EnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShariaComplianceStatus[] | ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShariaComplianceStatus[] | ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShariaComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShariaComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShariaComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumShariaComplianceStatusFilter<$PrismaModel>
  }

  export type EnumIslamicReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IslamicReportType | EnumIslamicReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IslamicReportType[] | ListEnumIslamicReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IslamicReportType[] | ListEnumIslamicReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIslamicReportTypeFilter<$PrismaModel> | $Enums.IslamicReportType
  }

  export type IslamicFinanceReportCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    reportType?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    periodType?: SortOrder
    reportData?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type IslamicFinanceReportMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    reportType?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    periodType?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type IslamicFinanceReportMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    reportType?: SortOrder
    periodStartDate?: SortOrder
    periodEndDate?: SortOrder
    periodType?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumIslamicReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IslamicReportType | EnumIslamicReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IslamicReportType[] | ListEnumIslamicReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IslamicReportType[] | ListEnumIslamicReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIslamicReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.IslamicReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIslamicReportTypeFilter<$PrismaModel>
    _max?: NestedEnumIslamicReportTypeFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type EnumNotificationChannelNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel> | null
    has?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    hasSome?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type NotificationDeliveryListRelationFilter = {
    every?: NotificationDeliveryWhereInput
    some?: NotificationDeliveryWhereInput
    none?: NotificationDeliveryWhereInput
  }

  export type NotificationDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    actionText?: SortOrder
    metadata?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    channels?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    actionText?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    actionText?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type NotificationDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationDeliveryAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type NotificationDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationDeliverySumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    budgetAlerts?: SortOrder
    debtReminders?: SortOrder
    zakatReminders?: SortOrder
    priceAlerts?: SortOrder
    transactionAlerts?: SortOrder
    monthlyReports?: SortOrder
    securityAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionUserIdEndpointCompoundUniqueInput = {
    userId: string
    endpoint: string
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    textContent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HouseholdMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput> | HouseholdMemberCreateWithoutUserInput[] | HouseholdMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutUserInput | HouseholdMemberCreateOrConnectWithoutUserInput[]
    createMany?: HouseholdMemberCreateManyUserInputEnvelope
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type PasskeyCreateNestedManyWithoutUserInput = {
    create?: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput> | PasskeyCreateWithoutUserInput[] | PasskeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutUserInput | PasskeyCreateOrConnectWithoutUserInput[]
    createMany?: PasskeyCreateManyUserInputEnvelope
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type WishlistItemCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WishlistItemCreateWithoutCreatorInput, WishlistItemUncheckedCreateWithoutCreatorInput> | WishlistItemCreateWithoutCreatorInput[] | WishlistItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutCreatorInput | WishlistItemCreateOrConnectWithoutCreatorInput[]
    createMany?: WishlistItemCreateManyCreatorInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type GratitudeEntryCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GratitudeEntryCreateWithoutCreatorInput, GratitudeEntryUncheckedCreateWithoutCreatorInput> | GratitudeEntryCreateWithoutCreatorInput[] | GratitudeEntryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutCreatorInput | GratitudeEntryCreateOrConnectWithoutCreatorInput[]
    createMany?: GratitudeEntryCreateManyCreatorInputEnvelope
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
  }

  export type RecurringTransactionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RecurringTransactionCreateWithoutCreatorInput, RecurringTransactionUncheckedCreateWithoutCreatorInput> | RecurringTransactionCreateWithoutCreatorInput[] | RecurringTransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutCreatorInput | RecurringTransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: RecurringTransactionCreateManyCreatorInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type DocumentUploadCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentUploadCreateWithoutUploaderInput, DocumentUploadUncheckedCreateWithoutUploaderInput> | DocumentUploadCreateWithoutUploaderInput[] | DocumentUploadUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutUploaderInput | DocumentUploadCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentUploadCreateManyUploaderInputEnvelope
    connect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
  }

  export type UserEventCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEventCreateWithoutUserInput, UserEventUncheckedCreateWithoutUserInput> | UserEventCreateWithoutUserInput[] | UserEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEventCreateOrConnectWithoutUserInput | UserEventCreateOrConnectWithoutUserInput[]
    createMany?: UserEventCreateManyUserInputEnvelope
    connect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
  }

  export type ShariaCompliantAccountCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ShariaCompliantAccountCreateWithoutReviewerInput, ShariaCompliantAccountUncheckedCreateWithoutReviewerInput> | ShariaCompliantAccountCreateWithoutReviewerInput[] | ShariaCompliantAccountUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ShariaCompliantAccountCreateOrConnectWithoutReviewerInput | ShariaCompliantAccountCreateOrConnectWithoutReviewerInput[]
    createMany?: ShariaCompliantAccountCreateManyReviewerInputEnvelope
    connect?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
  }

  export type IslamicFinanceReportCreateNestedManyWithoutGeneratorInput = {
    create?: XOR<IslamicFinanceReportCreateWithoutGeneratorInput, IslamicFinanceReportUncheckedCreateWithoutGeneratorInput> | IslamicFinanceReportCreateWithoutGeneratorInput[] | IslamicFinanceReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: IslamicFinanceReportCreateOrConnectWithoutGeneratorInput | IslamicFinanceReportCreateOrConnectWithoutGeneratorInput[]
    createMany?: IslamicFinanceReportCreateManyGeneratorInputEnvelope
    connect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type HouseholdMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput> | HouseholdMemberCreateWithoutUserInput[] | HouseholdMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutUserInput | HouseholdMemberCreateOrConnectWithoutUserInput[]
    createMany?: HouseholdMemberCreateManyUserInputEnvelope
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type PasskeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput> | PasskeyCreateWithoutUserInput[] | PasskeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutUserInput | PasskeyCreateOrConnectWithoutUserInput[]
    createMany?: PasskeyCreateManyUserInputEnvelope
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WishlistItemCreateWithoutCreatorInput, WishlistItemUncheckedCreateWithoutCreatorInput> | WishlistItemCreateWithoutCreatorInput[] | WishlistItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutCreatorInput | WishlistItemCreateOrConnectWithoutCreatorInput[]
    createMany?: WishlistItemCreateManyCreatorInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GratitudeEntryCreateWithoutCreatorInput, GratitudeEntryUncheckedCreateWithoutCreatorInput> | GratitudeEntryCreateWithoutCreatorInput[] | GratitudeEntryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutCreatorInput | GratitudeEntryCreateOrConnectWithoutCreatorInput[]
    createMany?: GratitudeEntryCreateManyCreatorInputEnvelope
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
  }

  export type RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RecurringTransactionCreateWithoutCreatorInput, RecurringTransactionUncheckedCreateWithoutCreatorInput> | RecurringTransactionCreateWithoutCreatorInput[] | RecurringTransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutCreatorInput | RecurringTransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: RecurringTransactionCreateManyCreatorInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentUploadCreateWithoutUploaderInput, DocumentUploadUncheckedCreateWithoutUploaderInput> | DocumentUploadCreateWithoutUploaderInput[] | DocumentUploadUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutUploaderInput | DocumentUploadCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentUploadCreateManyUploaderInputEnvelope
    connect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
  }

  export type UserEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEventCreateWithoutUserInput, UserEventUncheckedCreateWithoutUserInput> | UserEventCreateWithoutUserInput[] | UserEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEventCreateOrConnectWithoutUserInput | UserEventCreateOrConnectWithoutUserInput[]
    createMany?: UserEventCreateManyUserInputEnvelope
    connect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
  }

  export type ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ShariaCompliantAccountCreateWithoutReviewerInput, ShariaCompliantAccountUncheckedCreateWithoutReviewerInput> | ShariaCompliantAccountCreateWithoutReviewerInput[] | ShariaCompliantAccountUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ShariaCompliantAccountCreateOrConnectWithoutReviewerInput | ShariaCompliantAccountCreateOrConnectWithoutReviewerInput[]
    createMany?: ShariaCompliantAccountCreateManyReviewerInputEnvelope
    connect?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
  }

  export type IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput = {
    create?: XOR<IslamicFinanceReportCreateWithoutGeneratorInput, IslamicFinanceReportUncheckedCreateWithoutGeneratorInput> | IslamicFinanceReportCreateWithoutGeneratorInput[] | IslamicFinanceReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: IslamicFinanceReportCreateOrConnectWithoutGeneratorInput | IslamicFinanceReportCreateOrConnectWithoutGeneratorInput[]
    createMany?: IslamicFinanceReportCreateManyGeneratorInputEnvelope
    connect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type HouseholdMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput> | HouseholdMemberCreateWithoutUserInput[] | HouseholdMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutUserInput | HouseholdMemberCreateOrConnectWithoutUserInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutUserInput | HouseholdMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HouseholdMemberCreateManyUserInputEnvelope
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutUserInput | HouseholdMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutUserInput | HouseholdMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type PasskeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput> | PasskeyCreateWithoutUserInput[] | PasskeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutUserInput | PasskeyCreateOrConnectWithoutUserInput[]
    upsert?: PasskeyUpsertWithWhereUniqueWithoutUserInput | PasskeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasskeyCreateManyUserInputEnvelope
    set?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    disconnect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    delete?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    update?: PasskeyUpdateWithWhereUniqueWithoutUserInput | PasskeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasskeyUpdateManyWithWhereWithoutUserInput | PasskeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatorInput | TransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatorInput | TransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatorInput | TransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WishlistItemUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WishlistItemCreateWithoutCreatorInput, WishlistItemUncheckedCreateWithoutCreatorInput> | WishlistItemCreateWithoutCreatorInput[] | WishlistItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutCreatorInput | WishlistItemCreateOrConnectWithoutCreatorInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutCreatorInput | WishlistItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WishlistItemCreateManyCreatorInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutCreatorInput | WishlistItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutCreatorInput | WishlistItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type GratitudeEntryUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GratitudeEntryCreateWithoutCreatorInput, GratitudeEntryUncheckedCreateWithoutCreatorInput> | GratitudeEntryCreateWithoutCreatorInput[] | GratitudeEntryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutCreatorInput | GratitudeEntryCreateOrConnectWithoutCreatorInput[]
    upsert?: GratitudeEntryUpsertWithWhereUniqueWithoutCreatorInput | GratitudeEntryUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GratitudeEntryCreateManyCreatorInputEnvelope
    set?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    disconnect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    delete?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    update?: GratitudeEntryUpdateWithWhereUniqueWithoutCreatorInput | GratitudeEntryUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GratitudeEntryUpdateManyWithWhereWithoutCreatorInput | GratitudeEntryUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
  }

  export type RecurringTransactionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutCreatorInput, RecurringTransactionUncheckedCreateWithoutCreatorInput> | RecurringTransactionCreateWithoutCreatorInput[] | RecurringTransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutCreatorInput | RecurringTransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutCreatorInput | RecurringTransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RecurringTransactionCreateManyCreatorInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutCreatorInput | RecurringTransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutCreatorInput | RecurringTransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type DocumentUploadUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentUploadCreateWithoutUploaderInput, DocumentUploadUncheckedCreateWithoutUploaderInput> | DocumentUploadCreateWithoutUploaderInput[] | DocumentUploadUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutUploaderInput | DocumentUploadCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentUploadUpsertWithWhereUniqueWithoutUploaderInput | DocumentUploadUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentUploadCreateManyUploaderInputEnvelope
    set?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    disconnect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    delete?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    connect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    update?: DocumentUploadUpdateWithWhereUniqueWithoutUploaderInput | DocumentUploadUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentUploadUpdateManyWithWhereWithoutUploaderInput | DocumentUploadUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentUploadScalarWhereInput | DocumentUploadScalarWhereInput[]
  }

  export type UserEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEventCreateWithoutUserInput, UserEventUncheckedCreateWithoutUserInput> | UserEventCreateWithoutUserInput[] | UserEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEventCreateOrConnectWithoutUserInput | UserEventCreateOrConnectWithoutUserInput[]
    upsert?: UserEventUpsertWithWhereUniqueWithoutUserInput | UserEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEventCreateManyUserInputEnvelope
    set?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    disconnect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    delete?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    connect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    update?: UserEventUpdateWithWhereUniqueWithoutUserInput | UserEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEventUpdateManyWithWhereWithoutUserInput | UserEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEventScalarWhereInput | UserEventScalarWhereInput[]
  }

  export type ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ShariaCompliantAccountCreateWithoutReviewerInput, ShariaCompliantAccountUncheckedCreateWithoutReviewerInput> | ShariaCompliantAccountCreateWithoutReviewerInput[] | ShariaCompliantAccountUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ShariaCompliantAccountCreateOrConnectWithoutReviewerInput | ShariaCompliantAccountCreateOrConnectWithoutReviewerInput[]
    upsert?: ShariaCompliantAccountUpsertWithWhereUniqueWithoutReviewerInput | ShariaCompliantAccountUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ShariaCompliantAccountCreateManyReviewerInputEnvelope
    set?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
    disconnect?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
    delete?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
    connect?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
    update?: ShariaCompliantAccountUpdateWithWhereUniqueWithoutReviewerInput | ShariaCompliantAccountUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ShariaCompliantAccountUpdateManyWithWhereWithoutReviewerInput | ShariaCompliantAccountUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ShariaCompliantAccountScalarWhereInput | ShariaCompliantAccountScalarWhereInput[]
  }

  export type IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput = {
    create?: XOR<IslamicFinanceReportCreateWithoutGeneratorInput, IslamicFinanceReportUncheckedCreateWithoutGeneratorInput> | IslamicFinanceReportCreateWithoutGeneratorInput[] | IslamicFinanceReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: IslamicFinanceReportCreateOrConnectWithoutGeneratorInput | IslamicFinanceReportCreateOrConnectWithoutGeneratorInput[]
    upsert?: IslamicFinanceReportUpsertWithWhereUniqueWithoutGeneratorInput | IslamicFinanceReportUpsertWithWhereUniqueWithoutGeneratorInput[]
    createMany?: IslamicFinanceReportCreateManyGeneratorInputEnvelope
    set?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    disconnect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    delete?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    connect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    update?: IslamicFinanceReportUpdateWithWhereUniqueWithoutGeneratorInput | IslamicFinanceReportUpdateWithWhereUniqueWithoutGeneratorInput[]
    updateMany?: IslamicFinanceReportUpdateManyWithWhereWithoutGeneratorInput | IslamicFinanceReportUpdateManyWithWhereWithoutGeneratorInput[]
    deleteMany?: IslamicFinanceReportScalarWhereInput | IslamicFinanceReportScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput> | HouseholdMemberCreateWithoutUserInput[] | HouseholdMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutUserInput | HouseholdMemberCreateOrConnectWithoutUserInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutUserInput | HouseholdMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HouseholdMemberCreateManyUserInputEnvelope
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutUserInput | HouseholdMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutUserInput | HouseholdMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type PasskeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput> | PasskeyCreateWithoutUserInput[] | PasskeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutUserInput | PasskeyCreateOrConnectWithoutUserInput[]
    upsert?: PasskeyUpsertWithWhereUniqueWithoutUserInput | PasskeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasskeyCreateManyUserInputEnvelope
    set?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    disconnect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    delete?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    update?: PasskeyUpdateWithWhereUniqueWithoutUserInput | PasskeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasskeyUpdateManyWithWhereWithoutUserInput | PasskeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatorInput | TransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatorInput | TransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatorInput | TransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WishlistItemCreateWithoutCreatorInput, WishlistItemUncheckedCreateWithoutCreatorInput> | WishlistItemCreateWithoutCreatorInput[] | WishlistItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutCreatorInput | WishlistItemCreateOrConnectWithoutCreatorInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutCreatorInput | WishlistItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WishlistItemCreateManyCreatorInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutCreatorInput | WishlistItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutCreatorInput | WishlistItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GratitudeEntryCreateWithoutCreatorInput, GratitudeEntryUncheckedCreateWithoutCreatorInput> | GratitudeEntryCreateWithoutCreatorInput[] | GratitudeEntryUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutCreatorInput | GratitudeEntryCreateOrConnectWithoutCreatorInput[]
    upsert?: GratitudeEntryUpsertWithWhereUniqueWithoutCreatorInput | GratitudeEntryUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GratitudeEntryCreateManyCreatorInputEnvelope
    set?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    disconnect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    delete?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    update?: GratitudeEntryUpdateWithWhereUniqueWithoutCreatorInput | GratitudeEntryUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GratitudeEntryUpdateManyWithWhereWithoutCreatorInput | GratitudeEntryUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutCreatorInput, RecurringTransactionUncheckedCreateWithoutCreatorInput> | RecurringTransactionCreateWithoutCreatorInput[] | RecurringTransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutCreatorInput | RecurringTransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutCreatorInput | RecurringTransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RecurringTransactionCreateManyCreatorInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutCreatorInput | RecurringTransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutCreatorInput | RecurringTransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentUploadCreateWithoutUploaderInput, DocumentUploadUncheckedCreateWithoutUploaderInput> | DocumentUploadCreateWithoutUploaderInput[] | DocumentUploadUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutUploaderInput | DocumentUploadCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentUploadUpsertWithWhereUniqueWithoutUploaderInput | DocumentUploadUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentUploadCreateManyUploaderInputEnvelope
    set?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    disconnect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    delete?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    connect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    update?: DocumentUploadUpdateWithWhereUniqueWithoutUploaderInput | DocumentUploadUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentUploadUpdateManyWithWhereWithoutUploaderInput | DocumentUploadUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentUploadScalarWhereInput | DocumentUploadScalarWhereInput[]
  }

  export type UserEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEventCreateWithoutUserInput, UserEventUncheckedCreateWithoutUserInput> | UserEventCreateWithoutUserInput[] | UserEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEventCreateOrConnectWithoutUserInput | UserEventCreateOrConnectWithoutUserInput[]
    upsert?: UserEventUpsertWithWhereUniqueWithoutUserInput | UserEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEventCreateManyUserInputEnvelope
    set?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    disconnect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    delete?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    connect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    update?: UserEventUpdateWithWhereUniqueWithoutUserInput | UserEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEventUpdateManyWithWhereWithoutUserInput | UserEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEventScalarWhereInput | UserEventScalarWhereInput[]
  }

  export type ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ShariaCompliantAccountCreateWithoutReviewerInput, ShariaCompliantAccountUncheckedCreateWithoutReviewerInput> | ShariaCompliantAccountCreateWithoutReviewerInput[] | ShariaCompliantAccountUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ShariaCompliantAccountCreateOrConnectWithoutReviewerInput | ShariaCompliantAccountCreateOrConnectWithoutReviewerInput[]
    upsert?: ShariaCompliantAccountUpsertWithWhereUniqueWithoutReviewerInput | ShariaCompliantAccountUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ShariaCompliantAccountCreateManyReviewerInputEnvelope
    set?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
    disconnect?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
    delete?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
    connect?: ShariaCompliantAccountWhereUniqueInput | ShariaCompliantAccountWhereUniqueInput[]
    update?: ShariaCompliantAccountUpdateWithWhereUniqueWithoutReviewerInput | ShariaCompliantAccountUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ShariaCompliantAccountUpdateManyWithWhereWithoutReviewerInput | ShariaCompliantAccountUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ShariaCompliantAccountScalarWhereInput | ShariaCompliantAccountScalarWhereInput[]
  }

  export type IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput = {
    create?: XOR<IslamicFinanceReportCreateWithoutGeneratorInput, IslamicFinanceReportUncheckedCreateWithoutGeneratorInput> | IslamicFinanceReportCreateWithoutGeneratorInput[] | IslamicFinanceReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: IslamicFinanceReportCreateOrConnectWithoutGeneratorInput | IslamicFinanceReportCreateOrConnectWithoutGeneratorInput[]
    upsert?: IslamicFinanceReportUpsertWithWhereUniqueWithoutGeneratorInput | IslamicFinanceReportUpsertWithWhereUniqueWithoutGeneratorInput[]
    createMany?: IslamicFinanceReportCreateManyGeneratorInputEnvelope
    set?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    disconnect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    delete?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    connect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    update?: IslamicFinanceReportUpdateWithWhereUniqueWithoutGeneratorInput | IslamicFinanceReportUpdateWithWhereUniqueWithoutGeneratorInput[]
    updateMany?: IslamicFinanceReportUpdateManyWithWhereWithoutGeneratorInput | IslamicFinanceReportUpdateManyWithWhereWithoutGeneratorInput[]
    deleteMany?: IslamicFinanceReportScalarWhereInput | IslamicFinanceReportScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type HouseholdMemberCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput> | HouseholdMemberCreateWithoutHouseholdInput[] | HouseholdMemberUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutHouseholdInput | HouseholdMemberCreateOrConnectWithoutHouseholdInput[]
    createMany?: HouseholdMemberCreateManyHouseholdInputEnvelope
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<AccountCreateWithoutHouseholdInput, AccountUncheckedCreateWithoutHouseholdInput> | AccountCreateWithoutHouseholdInput[] | AccountUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutHouseholdInput | AccountCreateOrConnectWithoutHouseholdInput[]
    createMany?: AccountCreateManyHouseholdInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<TransactionCreateWithoutHouseholdInput, TransactionUncheckedCreateWithoutHouseholdInput> | TransactionCreateWithoutHouseholdInput[] | TransactionUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutHouseholdInput | TransactionCreateOrConnectWithoutHouseholdInput[]
    createMany?: TransactionCreateManyHouseholdInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type DebtCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<DebtCreateWithoutHouseholdInput, DebtUncheckedCreateWithoutHouseholdInput> | DebtCreateWithoutHouseholdInput[] | DebtUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutHouseholdInput | DebtCreateOrConnectWithoutHouseholdInput[]
    createMany?: DebtCreateManyHouseholdInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<BudgetCreateWithoutHouseholdInput, BudgetUncheckedCreateWithoutHouseholdInput> | BudgetCreateWithoutHouseholdInput[] | BudgetUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutHouseholdInput | BudgetCreateOrConnectWithoutHouseholdInput[]
    createMany?: BudgetCreateManyHouseholdInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type WishlistItemCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<WishlistItemCreateWithoutHouseholdInput, WishlistItemUncheckedCreateWithoutHouseholdInput> | WishlistItemCreateWithoutHouseholdInput[] | WishlistItemUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutHouseholdInput | WishlistItemCreateOrConnectWithoutHouseholdInput[]
    createMany?: WishlistItemCreateManyHouseholdInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type GratitudeEntryCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<GratitudeEntryCreateWithoutHouseholdInput, GratitudeEntryUncheckedCreateWithoutHouseholdInput> | GratitudeEntryCreateWithoutHouseholdInput[] | GratitudeEntryUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutHouseholdInput | GratitudeEntryCreateOrConnectWithoutHouseholdInput[]
    createMany?: GratitudeEntryCreateManyHouseholdInputEnvelope
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<CategoryCreateWithoutHouseholdInput, CategoryUncheckedCreateWithoutHouseholdInput> | CategoryCreateWithoutHouseholdInput[] | CategoryUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutHouseholdInput | CategoryCreateOrConnectWithoutHouseholdInput[]
    createMany?: CategoryCreateManyHouseholdInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type RecurringTransactionCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<RecurringTransactionCreateWithoutHouseholdInput, RecurringTransactionUncheckedCreateWithoutHouseholdInput> | RecurringTransactionCreateWithoutHouseholdInput[] | RecurringTransactionUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutHouseholdInput | RecurringTransactionCreateOrConnectWithoutHouseholdInput[]
    createMany?: RecurringTransactionCreateManyHouseholdInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type DocumentUploadCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<DocumentUploadCreateWithoutHouseholdInput, DocumentUploadUncheckedCreateWithoutHouseholdInput> | DocumentUploadCreateWithoutHouseholdInput[] | DocumentUploadUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutHouseholdInput | DocumentUploadCreateOrConnectWithoutHouseholdInput[]
    createMany?: DocumentUploadCreateManyHouseholdInputEnvelope
    connect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
  }

  export type UserEventCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<UserEventCreateWithoutHouseholdInput, UserEventUncheckedCreateWithoutHouseholdInput> | UserEventCreateWithoutHouseholdInput[] | UserEventUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: UserEventCreateOrConnectWithoutHouseholdInput | UserEventCreateOrConnectWithoutHouseholdInput[]
    createMany?: UserEventCreateManyHouseholdInputEnvelope
    connect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
  }

  export type SpendingPatternCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<SpendingPatternCreateWithoutHouseholdInput, SpendingPatternUncheckedCreateWithoutHouseholdInput> | SpendingPatternCreateWithoutHouseholdInput[] | SpendingPatternUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: SpendingPatternCreateOrConnectWithoutHouseholdInput | SpendingPatternCreateOrConnectWithoutHouseholdInput[]
    createMany?: SpendingPatternCreateManyHouseholdInputEnvelope
    connect?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
  }

  export type FinancialInsightCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<FinancialInsightCreateWithoutHouseholdInput, FinancialInsightUncheckedCreateWithoutHouseholdInput> | FinancialInsightCreateWithoutHouseholdInput[] | FinancialInsightUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: FinancialInsightCreateOrConnectWithoutHouseholdInput | FinancialInsightCreateOrConnectWithoutHouseholdInput[]
    createMany?: FinancialInsightCreateManyHouseholdInputEnvelope
    connect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
  }

  export type ZakatCalculationCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ZakatCalculationCreateWithoutHouseholdInput, ZakatCalculationUncheckedCreateWithoutHouseholdInput> | ZakatCalculationCreateWithoutHouseholdInput[] | ZakatCalculationUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatCalculationCreateOrConnectWithoutHouseholdInput | ZakatCalculationCreateOrConnectWithoutHouseholdInput[]
    createMany?: ZakatCalculationCreateManyHouseholdInputEnvelope
    connect?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
  }

  export type ZakatReminderCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ZakatReminderCreateWithoutHouseholdInput, ZakatReminderUncheckedCreateWithoutHouseholdInput> | ZakatReminderCreateWithoutHouseholdInput[] | ZakatReminderUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatReminderCreateOrConnectWithoutHouseholdInput | ZakatReminderCreateOrConnectWithoutHouseholdInput[]
    createMany?: ZakatReminderCreateManyHouseholdInputEnvelope
    connect?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
  }

  export type ZakatPaymentCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ZakatPaymentCreateWithoutHouseholdInput, ZakatPaymentUncheckedCreateWithoutHouseholdInput> | ZakatPaymentCreateWithoutHouseholdInput[] | ZakatPaymentUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutHouseholdInput | ZakatPaymentCreateOrConnectWithoutHouseholdInput[]
    createMany?: ZakatPaymentCreateManyHouseholdInputEnvelope
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
  }

  export type IslamicFinanceReportCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<IslamicFinanceReportCreateWithoutHouseholdInput, IslamicFinanceReportUncheckedCreateWithoutHouseholdInput> | IslamicFinanceReportCreateWithoutHouseholdInput[] | IslamicFinanceReportUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: IslamicFinanceReportCreateOrConnectWithoutHouseholdInput | IslamicFinanceReportCreateOrConnectWithoutHouseholdInput[]
    createMany?: IslamicFinanceReportCreateManyHouseholdInputEnvelope
    connect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<NotificationCreateWithoutHouseholdInput, NotificationUncheckedCreateWithoutHouseholdInput> | NotificationCreateWithoutHouseholdInput[] | NotificationUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutHouseholdInput | NotificationCreateOrConnectWithoutHouseholdInput[]
    createMany?: NotificationCreateManyHouseholdInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput> | HouseholdMemberCreateWithoutHouseholdInput[] | HouseholdMemberUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutHouseholdInput | HouseholdMemberCreateOrConnectWithoutHouseholdInput[]
    createMany?: HouseholdMemberCreateManyHouseholdInputEnvelope
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<AccountCreateWithoutHouseholdInput, AccountUncheckedCreateWithoutHouseholdInput> | AccountCreateWithoutHouseholdInput[] | AccountUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutHouseholdInput | AccountCreateOrConnectWithoutHouseholdInput[]
    createMany?: AccountCreateManyHouseholdInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<TransactionCreateWithoutHouseholdInput, TransactionUncheckedCreateWithoutHouseholdInput> | TransactionCreateWithoutHouseholdInput[] | TransactionUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutHouseholdInput | TransactionCreateOrConnectWithoutHouseholdInput[]
    createMany?: TransactionCreateManyHouseholdInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type DebtUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<DebtCreateWithoutHouseholdInput, DebtUncheckedCreateWithoutHouseholdInput> | DebtCreateWithoutHouseholdInput[] | DebtUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutHouseholdInput | DebtCreateOrConnectWithoutHouseholdInput[]
    createMany?: DebtCreateManyHouseholdInputEnvelope
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<BudgetCreateWithoutHouseholdInput, BudgetUncheckedCreateWithoutHouseholdInput> | BudgetCreateWithoutHouseholdInput[] | BudgetUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutHouseholdInput | BudgetCreateOrConnectWithoutHouseholdInput[]
    createMany?: BudgetCreateManyHouseholdInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<WishlistItemCreateWithoutHouseholdInput, WishlistItemUncheckedCreateWithoutHouseholdInput> | WishlistItemCreateWithoutHouseholdInput[] | WishlistItemUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutHouseholdInput | WishlistItemCreateOrConnectWithoutHouseholdInput[]
    createMany?: WishlistItemCreateManyHouseholdInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<GratitudeEntryCreateWithoutHouseholdInput, GratitudeEntryUncheckedCreateWithoutHouseholdInput> | GratitudeEntryCreateWithoutHouseholdInput[] | GratitudeEntryUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutHouseholdInput | GratitudeEntryCreateOrConnectWithoutHouseholdInput[]
    createMany?: GratitudeEntryCreateManyHouseholdInputEnvelope
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<CategoryCreateWithoutHouseholdInput, CategoryUncheckedCreateWithoutHouseholdInput> | CategoryCreateWithoutHouseholdInput[] | CategoryUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutHouseholdInput | CategoryCreateOrConnectWithoutHouseholdInput[]
    createMany?: CategoryCreateManyHouseholdInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<RecurringTransactionCreateWithoutHouseholdInput, RecurringTransactionUncheckedCreateWithoutHouseholdInput> | RecurringTransactionCreateWithoutHouseholdInput[] | RecurringTransactionUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutHouseholdInput | RecurringTransactionCreateOrConnectWithoutHouseholdInput[]
    createMany?: RecurringTransactionCreateManyHouseholdInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<DocumentUploadCreateWithoutHouseholdInput, DocumentUploadUncheckedCreateWithoutHouseholdInput> | DocumentUploadCreateWithoutHouseholdInput[] | DocumentUploadUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutHouseholdInput | DocumentUploadCreateOrConnectWithoutHouseholdInput[]
    createMany?: DocumentUploadCreateManyHouseholdInputEnvelope
    connect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
  }

  export type UserEventUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<UserEventCreateWithoutHouseholdInput, UserEventUncheckedCreateWithoutHouseholdInput> | UserEventCreateWithoutHouseholdInput[] | UserEventUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: UserEventCreateOrConnectWithoutHouseholdInput | UserEventCreateOrConnectWithoutHouseholdInput[]
    createMany?: UserEventCreateManyHouseholdInputEnvelope
    connect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
  }

  export type SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<SpendingPatternCreateWithoutHouseholdInput, SpendingPatternUncheckedCreateWithoutHouseholdInput> | SpendingPatternCreateWithoutHouseholdInput[] | SpendingPatternUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: SpendingPatternCreateOrConnectWithoutHouseholdInput | SpendingPatternCreateOrConnectWithoutHouseholdInput[]
    createMany?: SpendingPatternCreateManyHouseholdInputEnvelope
    connect?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
  }

  export type FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<FinancialInsightCreateWithoutHouseholdInput, FinancialInsightUncheckedCreateWithoutHouseholdInput> | FinancialInsightCreateWithoutHouseholdInput[] | FinancialInsightUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: FinancialInsightCreateOrConnectWithoutHouseholdInput | FinancialInsightCreateOrConnectWithoutHouseholdInput[]
    createMany?: FinancialInsightCreateManyHouseholdInputEnvelope
    connect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
  }

  export type ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ZakatCalculationCreateWithoutHouseholdInput, ZakatCalculationUncheckedCreateWithoutHouseholdInput> | ZakatCalculationCreateWithoutHouseholdInput[] | ZakatCalculationUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatCalculationCreateOrConnectWithoutHouseholdInput | ZakatCalculationCreateOrConnectWithoutHouseholdInput[]
    createMany?: ZakatCalculationCreateManyHouseholdInputEnvelope
    connect?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
  }

  export type ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ZakatReminderCreateWithoutHouseholdInput, ZakatReminderUncheckedCreateWithoutHouseholdInput> | ZakatReminderCreateWithoutHouseholdInput[] | ZakatReminderUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatReminderCreateOrConnectWithoutHouseholdInput | ZakatReminderCreateOrConnectWithoutHouseholdInput[]
    createMany?: ZakatReminderCreateManyHouseholdInputEnvelope
    connect?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
  }

  export type ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ZakatPaymentCreateWithoutHouseholdInput, ZakatPaymentUncheckedCreateWithoutHouseholdInput> | ZakatPaymentCreateWithoutHouseholdInput[] | ZakatPaymentUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutHouseholdInput | ZakatPaymentCreateOrConnectWithoutHouseholdInput[]
    createMany?: ZakatPaymentCreateManyHouseholdInputEnvelope
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
  }

  export type IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<IslamicFinanceReportCreateWithoutHouseholdInput, IslamicFinanceReportUncheckedCreateWithoutHouseholdInput> | IslamicFinanceReportCreateWithoutHouseholdInput[] | IslamicFinanceReportUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: IslamicFinanceReportCreateOrConnectWithoutHouseholdInput | IslamicFinanceReportCreateOrConnectWithoutHouseholdInput[]
    createMany?: IslamicFinanceReportCreateManyHouseholdInputEnvelope
    connect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<NotificationCreateWithoutHouseholdInput, NotificationUncheckedCreateWithoutHouseholdInput> | NotificationCreateWithoutHouseholdInput[] | NotificationUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutHouseholdInput | NotificationCreateOrConnectWithoutHouseholdInput[]
    createMany?: NotificationCreateManyHouseholdInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type HouseholdMemberUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput> | HouseholdMemberCreateWithoutHouseholdInput[] | HouseholdMemberUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutHouseholdInput | HouseholdMemberCreateOrConnectWithoutHouseholdInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput | HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: HouseholdMemberCreateManyHouseholdInputEnvelope
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput | HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput | HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<AccountCreateWithoutHouseholdInput, AccountUncheckedCreateWithoutHouseholdInput> | AccountCreateWithoutHouseholdInput[] | AccountUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutHouseholdInput | AccountCreateOrConnectWithoutHouseholdInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutHouseholdInput | AccountUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: AccountCreateManyHouseholdInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutHouseholdInput | AccountUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutHouseholdInput | AccountUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<TransactionCreateWithoutHouseholdInput, TransactionUncheckedCreateWithoutHouseholdInput> | TransactionCreateWithoutHouseholdInput[] | TransactionUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutHouseholdInput | TransactionCreateOrConnectWithoutHouseholdInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutHouseholdInput | TransactionUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: TransactionCreateManyHouseholdInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutHouseholdInput | TransactionUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutHouseholdInput | TransactionUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type DebtUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<DebtCreateWithoutHouseholdInput, DebtUncheckedCreateWithoutHouseholdInput> | DebtCreateWithoutHouseholdInput[] | DebtUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutHouseholdInput | DebtCreateOrConnectWithoutHouseholdInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutHouseholdInput | DebtUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: DebtCreateManyHouseholdInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutHouseholdInput | DebtUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutHouseholdInput | DebtUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<BudgetCreateWithoutHouseholdInput, BudgetUncheckedCreateWithoutHouseholdInput> | BudgetCreateWithoutHouseholdInput[] | BudgetUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutHouseholdInput | BudgetCreateOrConnectWithoutHouseholdInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutHouseholdInput | BudgetUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: BudgetCreateManyHouseholdInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutHouseholdInput | BudgetUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutHouseholdInput | BudgetUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type WishlistItemUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<WishlistItemCreateWithoutHouseholdInput, WishlistItemUncheckedCreateWithoutHouseholdInput> | WishlistItemCreateWithoutHouseholdInput[] | WishlistItemUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutHouseholdInput | WishlistItemCreateOrConnectWithoutHouseholdInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutHouseholdInput | WishlistItemUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: WishlistItemCreateManyHouseholdInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutHouseholdInput | WishlistItemUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutHouseholdInput | WishlistItemUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type GratitudeEntryUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<GratitudeEntryCreateWithoutHouseholdInput, GratitudeEntryUncheckedCreateWithoutHouseholdInput> | GratitudeEntryCreateWithoutHouseholdInput[] | GratitudeEntryUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutHouseholdInput | GratitudeEntryCreateOrConnectWithoutHouseholdInput[]
    upsert?: GratitudeEntryUpsertWithWhereUniqueWithoutHouseholdInput | GratitudeEntryUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: GratitudeEntryCreateManyHouseholdInputEnvelope
    set?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    disconnect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    delete?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    update?: GratitudeEntryUpdateWithWhereUniqueWithoutHouseholdInput | GratitudeEntryUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: GratitudeEntryUpdateManyWithWhereWithoutHouseholdInput | GratitudeEntryUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<CategoryCreateWithoutHouseholdInput, CategoryUncheckedCreateWithoutHouseholdInput> | CategoryCreateWithoutHouseholdInput[] | CategoryUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutHouseholdInput | CategoryCreateOrConnectWithoutHouseholdInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutHouseholdInput | CategoryUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: CategoryCreateManyHouseholdInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutHouseholdInput | CategoryUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutHouseholdInput | CategoryUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type RecurringTransactionUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutHouseholdInput, RecurringTransactionUncheckedCreateWithoutHouseholdInput> | RecurringTransactionCreateWithoutHouseholdInput[] | RecurringTransactionUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutHouseholdInput | RecurringTransactionCreateOrConnectWithoutHouseholdInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutHouseholdInput | RecurringTransactionUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: RecurringTransactionCreateManyHouseholdInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutHouseholdInput | RecurringTransactionUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutHouseholdInput | RecurringTransactionUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type DocumentUploadUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<DocumentUploadCreateWithoutHouseholdInput, DocumentUploadUncheckedCreateWithoutHouseholdInput> | DocumentUploadCreateWithoutHouseholdInput[] | DocumentUploadUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutHouseholdInput | DocumentUploadCreateOrConnectWithoutHouseholdInput[]
    upsert?: DocumentUploadUpsertWithWhereUniqueWithoutHouseholdInput | DocumentUploadUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: DocumentUploadCreateManyHouseholdInputEnvelope
    set?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    disconnect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    delete?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    connect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    update?: DocumentUploadUpdateWithWhereUniqueWithoutHouseholdInput | DocumentUploadUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: DocumentUploadUpdateManyWithWhereWithoutHouseholdInput | DocumentUploadUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: DocumentUploadScalarWhereInput | DocumentUploadScalarWhereInput[]
  }

  export type UserEventUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<UserEventCreateWithoutHouseholdInput, UserEventUncheckedCreateWithoutHouseholdInput> | UserEventCreateWithoutHouseholdInput[] | UserEventUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: UserEventCreateOrConnectWithoutHouseholdInput | UserEventCreateOrConnectWithoutHouseholdInput[]
    upsert?: UserEventUpsertWithWhereUniqueWithoutHouseholdInput | UserEventUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: UserEventCreateManyHouseholdInputEnvelope
    set?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    disconnect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    delete?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    connect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    update?: UserEventUpdateWithWhereUniqueWithoutHouseholdInput | UserEventUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: UserEventUpdateManyWithWhereWithoutHouseholdInput | UserEventUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: UserEventScalarWhereInput | UserEventScalarWhereInput[]
  }

  export type SpendingPatternUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<SpendingPatternCreateWithoutHouseholdInput, SpendingPatternUncheckedCreateWithoutHouseholdInput> | SpendingPatternCreateWithoutHouseholdInput[] | SpendingPatternUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: SpendingPatternCreateOrConnectWithoutHouseholdInput | SpendingPatternCreateOrConnectWithoutHouseholdInput[]
    upsert?: SpendingPatternUpsertWithWhereUniqueWithoutHouseholdInput | SpendingPatternUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: SpendingPatternCreateManyHouseholdInputEnvelope
    set?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
    disconnect?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
    delete?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
    connect?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
    update?: SpendingPatternUpdateWithWhereUniqueWithoutHouseholdInput | SpendingPatternUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: SpendingPatternUpdateManyWithWhereWithoutHouseholdInput | SpendingPatternUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: SpendingPatternScalarWhereInput | SpendingPatternScalarWhereInput[]
  }

  export type FinancialInsightUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<FinancialInsightCreateWithoutHouseholdInput, FinancialInsightUncheckedCreateWithoutHouseholdInput> | FinancialInsightCreateWithoutHouseholdInput[] | FinancialInsightUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: FinancialInsightCreateOrConnectWithoutHouseholdInput | FinancialInsightCreateOrConnectWithoutHouseholdInput[]
    upsert?: FinancialInsightUpsertWithWhereUniqueWithoutHouseholdInput | FinancialInsightUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: FinancialInsightCreateManyHouseholdInputEnvelope
    set?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    disconnect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    delete?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    connect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    update?: FinancialInsightUpdateWithWhereUniqueWithoutHouseholdInput | FinancialInsightUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: FinancialInsightUpdateManyWithWhereWithoutHouseholdInput | FinancialInsightUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: FinancialInsightScalarWhereInput | FinancialInsightScalarWhereInput[]
  }

  export type ZakatCalculationUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ZakatCalculationCreateWithoutHouseholdInput, ZakatCalculationUncheckedCreateWithoutHouseholdInput> | ZakatCalculationCreateWithoutHouseholdInput[] | ZakatCalculationUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatCalculationCreateOrConnectWithoutHouseholdInput | ZakatCalculationCreateOrConnectWithoutHouseholdInput[]
    upsert?: ZakatCalculationUpsertWithWhereUniqueWithoutHouseholdInput | ZakatCalculationUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ZakatCalculationCreateManyHouseholdInputEnvelope
    set?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
    disconnect?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
    delete?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
    connect?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
    update?: ZakatCalculationUpdateWithWhereUniqueWithoutHouseholdInput | ZakatCalculationUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ZakatCalculationUpdateManyWithWhereWithoutHouseholdInput | ZakatCalculationUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ZakatCalculationScalarWhereInput | ZakatCalculationScalarWhereInput[]
  }

  export type ZakatReminderUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ZakatReminderCreateWithoutHouseholdInput, ZakatReminderUncheckedCreateWithoutHouseholdInput> | ZakatReminderCreateWithoutHouseholdInput[] | ZakatReminderUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatReminderCreateOrConnectWithoutHouseholdInput | ZakatReminderCreateOrConnectWithoutHouseholdInput[]
    upsert?: ZakatReminderUpsertWithWhereUniqueWithoutHouseholdInput | ZakatReminderUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ZakatReminderCreateManyHouseholdInputEnvelope
    set?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
    disconnect?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
    delete?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
    connect?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
    update?: ZakatReminderUpdateWithWhereUniqueWithoutHouseholdInput | ZakatReminderUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ZakatReminderUpdateManyWithWhereWithoutHouseholdInput | ZakatReminderUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ZakatReminderScalarWhereInput | ZakatReminderScalarWhereInput[]
  }

  export type ZakatPaymentUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ZakatPaymentCreateWithoutHouseholdInput, ZakatPaymentUncheckedCreateWithoutHouseholdInput> | ZakatPaymentCreateWithoutHouseholdInput[] | ZakatPaymentUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutHouseholdInput | ZakatPaymentCreateOrConnectWithoutHouseholdInput[]
    upsert?: ZakatPaymentUpsertWithWhereUniqueWithoutHouseholdInput | ZakatPaymentUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ZakatPaymentCreateManyHouseholdInputEnvelope
    set?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    disconnect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    delete?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    update?: ZakatPaymentUpdateWithWhereUniqueWithoutHouseholdInput | ZakatPaymentUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ZakatPaymentUpdateManyWithWhereWithoutHouseholdInput | ZakatPaymentUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ZakatPaymentScalarWhereInput | ZakatPaymentScalarWhereInput[]
  }

  export type IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<IslamicFinanceReportCreateWithoutHouseholdInput, IslamicFinanceReportUncheckedCreateWithoutHouseholdInput> | IslamicFinanceReportCreateWithoutHouseholdInput[] | IslamicFinanceReportUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: IslamicFinanceReportCreateOrConnectWithoutHouseholdInput | IslamicFinanceReportCreateOrConnectWithoutHouseholdInput[]
    upsert?: IslamicFinanceReportUpsertWithWhereUniqueWithoutHouseholdInput | IslamicFinanceReportUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: IslamicFinanceReportCreateManyHouseholdInputEnvelope
    set?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    disconnect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    delete?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    connect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    update?: IslamicFinanceReportUpdateWithWhereUniqueWithoutHouseholdInput | IslamicFinanceReportUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: IslamicFinanceReportUpdateManyWithWhereWithoutHouseholdInput | IslamicFinanceReportUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: IslamicFinanceReportScalarWhereInput | IslamicFinanceReportScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<NotificationCreateWithoutHouseholdInput, NotificationUncheckedCreateWithoutHouseholdInput> | NotificationCreateWithoutHouseholdInput[] | NotificationUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutHouseholdInput | NotificationCreateOrConnectWithoutHouseholdInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutHouseholdInput | NotificationUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: NotificationCreateManyHouseholdInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutHouseholdInput | NotificationUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutHouseholdInput | NotificationUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput> | HouseholdMemberCreateWithoutHouseholdInput[] | HouseholdMemberUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutHouseholdInput | HouseholdMemberCreateOrConnectWithoutHouseholdInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput | HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: HouseholdMemberCreateManyHouseholdInputEnvelope
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput | HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput | HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<AccountCreateWithoutHouseholdInput, AccountUncheckedCreateWithoutHouseholdInput> | AccountCreateWithoutHouseholdInput[] | AccountUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutHouseholdInput | AccountCreateOrConnectWithoutHouseholdInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutHouseholdInput | AccountUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: AccountCreateManyHouseholdInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutHouseholdInput | AccountUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutHouseholdInput | AccountUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<TransactionCreateWithoutHouseholdInput, TransactionUncheckedCreateWithoutHouseholdInput> | TransactionCreateWithoutHouseholdInput[] | TransactionUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutHouseholdInput | TransactionCreateOrConnectWithoutHouseholdInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutHouseholdInput | TransactionUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: TransactionCreateManyHouseholdInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutHouseholdInput | TransactionUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutHouseholdInput | TransactionUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type DebtUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<DebtCreateWithoutHouseholdInput, DebtUncheckedCreateWithoutHouseholdInput> | DebtCreateWithoutHouseholdInput[] | DebtUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: DebtCreateOrConnectWithoutHouseholdInput | DebtCreateOrConnectWithoutHouseholdInput[]
    upsert?: DebtUpsertWithWhereUniqueWithoutHouseholdInput | DebtUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: DebtCreateManyHouseholdInputEnvelope
    set?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    disconnect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    delete?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    connect?: DebtWhereUniqueInput | DebtWhereUniqueInput[]
    update?: DebtUpdateWithWhereUniqueWithoutHouseholdInput | DebtUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: DebtUpdateManyWithWhereWithoutHouseholdInput | DebtUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: DebtScalarWhereInput | DebtScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<BudgetCreateWithoutHouseholdInput, BudgetUncheckedCreateWithoutHouseholdInput> | BudgetCreateWithoutHouseholdInput[] | BudgetUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutHouseholdInput | BudgetCreateOrConnectWithoutHouseholdInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutHouseholdInput | BudgetUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: BudgetCreateManyHouseholdInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutHouseholdInput | BudgetUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutHouseholdInput | BudgetUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<WishlistItemCreateWithoutHouseholdInput, WishlistItemUncheckedCreateWithoutHouseholdInput> | WishlistItemCreateWithoutHouseholdInput[] | WishlistItemUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutHouseholdInput | WishlistItemCreateOrConnectWithoutHouseholdInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutHouseholdInput | WishlistItemUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: WishlistItemCreateManyHouseholdInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutHouseholdInput | WishlistItemUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutHouseholdInput | WishlistItemUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<GratitudeEntryCreateWithoutHouseholdInput, GratitudeEntryUncheckedCreateWithoutHouseholdInput> | GratitudeEntryCreateWithoutHouseholdInput[] | GratitudeEntryUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutHouseholdInput | GratitudeEntryCreateOrConnectWithoutHouseholdInput[]
    upsert?: GratitudeEntryUpsertWithWhereUniqueWithoutHouseholdInput | GratitudeEntryUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: GratitudeEntryCreateManyHouseholdInputEnvelope
    set?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    disconnect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    delete?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    update?: GratitudeEntryUpdateWithWhereUniqueWithoutHouseholdInput | GratitudeEntryUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: GratitudeEntryUpdateManyWithWhereWithoutHouseholdInput | GratitudeEntryUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<CategoryCreateWithoutHouseholdInput, CategoryUncheckedCreateWithoutHouseholdInput> | CategoryCreateWithoutHouseholdInput[] | CategoryUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutHouseholdInput | CategoryCreateOrConnectWithoutHouseholdInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutHouseholdInput | CategoryUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: CategoryCreateManyHouseholdInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutHouseholdInput | CategoryUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutHouseholdInput | CategoryUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutHouseholdInput, RecurringTransactionUncheckedCreateWithoutHouseholdInput> | RecurringTransactionCreateWithoutHouseholdInput[] | RecurringTransactionUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutHouseholdInput | RecurringTransactionCreateOrConnectWithoutHouseholdInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutHouseholdInput | RecurringTransactionUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: RecurringTransactionCreateManyHouseholdInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutHouseholdInput | RecurringTransactionUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutHouseholdInput | RecurringTransactionUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<DocumentUploadCreateWithoutHouseholdInput, DocumentUploadUncheckedCreateWithoutHouseholdInput> | DocumentUploadCreateWithoutHouseholdInput[] | DocumentUploadUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutHouseholdInput | DocumentUploadCreateOrConnectWithoutHouseholdInput[]
    upsert?: DocumentUploadUpsertWithWhereUniqueWithoutHouseholdInput | DocumentUploadUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: DocumentUploadCreateManyHouseholdInputEnvelope
    set?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    disconnect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    delete?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    connect?: DocumentUploadWhereUniqueInput | DocumentUploadWhereUniqueInput[]
    update?: DocumentUploadUpdateWithWhereUniqueWithoutHouseholdInput | DocumentUploadUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: DocumentUploadUpdateManyWithWhereWithoutHouseholdInput | DocumentUploadUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: DocumentUploadScalarWhereInput | DocumentUploadScalarWhereInput[]
  }

  export type UserEventUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<UserEventCreateWithoutHouseholdInput, UserEventUncheckedCreateWithoutHouseholdInput> | UserEventCreateWithoutHouseholdInput[] | UserEventUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: UserEventCreateOrConnectWithoutHouseholdInput | UserEventCreateOrConnectWithoutHouseholdInput[]
    upsert?: UserEventUpsertWithWhereUniqueWithoutHouseholdInput | UserEventUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: UserEventCreateManyHouseholdInputEnvelope
    set?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    disconnect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    delete?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    connect?: UserEventWhereUniqueInput | UserEventWhereUniqueInput[]
    update?: UserEventUpdateWithWhereUniqueWithoutHouseholdInput | UserEventUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: UserEventUpdateManyWithWhereWithoutHouseholdInput | UserEventUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: UserEventScalarWhereInput | UserEventScalarWhereInput[]
  }

  export type SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<SpendingPatternCreateWithoutHouseholdInput, SpendingPatternUncheckedCreateWithoutHouseholdInput> | SpendingPatternCreateWithoutHouseholdInput[] | SpendingPatternUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: SpendingPatternCreateOrConnectWithoutHouseholdInput | SpendingPatternCreateOrConnectWithoutHouseholdInput[]
    upsert?: SpendingPatternUpsertWithWhereUniqueWithoutHouseholdInput | SpendingPatternUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: SpendingPatternCreateManyHouseholdInputEnvelope
    set?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
    disconnect?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
    delete?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
    connect?: SpendingPatternWhereUniqueInput | SpendingPatternWhereUniqueInput[]
    update?: SpendingPatternUpdateWithWhereUniqueWithoutHouseholdInput | SpendingPatternUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: SpendingPatternUpdateManyWithWhereWithoutHouseholdInput | SpendingPatternUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: SpendingPatternScalarWhereInput | SpendingPatternScalarWhereInput[]
  }

  export type FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<FinancialInsightCreateWithoutHouseholdInput, FinancialInsightUncheckedCreateWithoutHouseholdInput> | FinancialInsightCreateWithoutHouseholdInput[] | FinancialInsightUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: FinancialInsightCreateOrConnectWithoutHouseholdInput | FinancialInsightCreateOrConnectWithoutHouseholdInput[]
    upsert?: FinancialInsightUpsertWithWhereUniqueWithoutHouseholdInput | FinancialInsightUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: FinancialInsightCreateManyHouseholdInputEnvelope
    set?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    disconnect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    delete?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    connect?: FinancialInsightWhereUniqueInput | FinancialInsightWhereUniqueInput[]
    update?: FinancialInsightUpdateWithWhereUniqueWithoutHouseholdInput | FinancialInsightUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: FinancialInsightUpdateManyWithWhereWithoutHouseholdInput | FinancialInsightUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: FinancialInsightScalarWhereInput | FinancialInsightScalarWhereInput[]
  }

  export type ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ZakatCalculationCreateWithoutHouseholdInput, ZakatCalculationUncheckedCreateWithoutHouseholdInput> | ZakatCalculationCreateWithoutHouseholdInput[] | ZakatCalculationUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatCalculationCreateOrConnectWithoutHouseholdInput | ZakatCalculationCreateOrConnectWithoutHouseholdInput[]
    upsert?: ZakatCalculationUpsertWithWhereUniqueWithoutHouseholdInput | ZakatCalculationUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ZakatCalculationCreateManyHouseholdInputEnvelope
    set?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
    disconnect?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
    delete?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
    connect?: ZakatCalculationWhereUniqueInput | ZakatCalculationWhereUniqueInput[]
    update?: ZakatCalculationUpdateWithWhereUniqueWithoutHouseholdInput | ZakatCalculationUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ZakatCalculationUpdateManyWithWhereWithoutHouseholdInput | ZakatCalculationUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ZakatCalculationScalarWhereInput | ZakatCalculationScalarWhereInput[]
  }

  export type ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ZakatReminderCreateWithoutHouseholdInput, ZakatReminderUncheckedCreateWithoutHouseholdInput> | ZakatReminderCreateWithoutHouseholdInput[] | ZakatReminderUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatReminderCreateOrConnectWithoutHouseholdInput | ZakatReminderCreateOrConnectWithoutHouseholdInput[]
    upsert?: ZakatReminderUpsertWithWhereUniqueWithoutHouseholdInput | ZakatReminderUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ZakatReminderCreateManyHouseholdInputEnvelope
    set?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
    disconnect?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
    delete?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
    connect?: ZakatReminderWhereUniqueInput | ZakatReminderWhereUniqueInput[]
    update?: ZakatReminderUpdateWithWhereUniqueWithoutHouseholdInput | ZakatReminderUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ZakatReminderUpdateManyWithWhereWithoutHouseholdInput | ZakatReminderUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ZakatReminderScalarWhereInput | ZakatReminderScalarWhereInput[]
  }

  export type ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ZakatPaymentCreateWithoutHouseholdInput, ZakatPaymentUncheckedCreateWithoutHouseholdInput> | ZakatPaymentCreateWithoutHouseholdInput[] | ZakatPaymentUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutHouseholdInput | ZakatPaymentCreateOrConnectWithoutHouseholdInput[]
    upsert?: ZakatPaymentUpsertWithWhereUniqueWithoutHouseholdInput | ZakatPaymentUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ZakatPaymentCreateManyHouseholdInputEnvelope
    set?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    disconnect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    delete?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    update?: ZakatPaymentUpdateWithWhereUniqueWithoutHouseholdInput | ZakatPaymentUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ZakatPaymentUpdateManyWithWhereWithoutHouseholdInput | ZakatPaymentUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ZakatPaymentScalarWhereInput | ZakatPaymentScalarWhereInput[]
  }

  export type IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<IslamicFinanceReportCreateWithoutHouseholdInput, IslamicFinanceReportUncheckedCreateWithoutHouseholdInput> | IslamicFinanceReportCreateWithoutHouseholdInput[] | IslamicFinanceReportUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: IslamicFinanceReportCreateOrConnectWithoutHouseholdInput | IslamicFinanceReportCreateOrConnectWithoutHouseholdInput[]
    upsert?: IslamicFinanceReportUpsertWithWhereUniqueWithoutHouseholdInput | IslamicFinanceReportUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: IslamicFinanceReportCreateManyHouseholdInputEnvelope
    set?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    disconnect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    delete?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    connect?: IslamicFinanceReportWhereUniqueInput | IslamicFinanceReportWhereUniqueInput[]
    update?: IslamicFinanceReportUpdateWithWhereUniqueWithoutHouseholdInput | IslamicFinanceReportUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: IslamicFinanceReportUpdateManyWithWhereWithoutHouseholdInput | IslamicFinanceReportUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: IslamicFinanceReportScalarWhereInput | IslamicFinanceReportScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<NotificationCreateWithoutHouseholdInput, NotificationUncheckedCreateWithoutHouseholdInput> | NotificationCreateWithoutHouseholdInput[] | NotificationUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutHouseholdInput | NotificationCreateOrConnectWithoutHouseholdInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutHouseholdInput | NotificationUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: NotificationCreateManyHouseholdInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutHouseholdInput | NotificationUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutHouseholdInput | NotificationUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHouseholdMembersInput = {
    create?: XOR<UserCreateWithoutHouseholdMembersInput, UserUncheckedCreateWithoutHouseholdMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutHouseholdMembersInput
    connect?: UserWhereUniqueInput
  }

  export type HouseholdCreateNestedOneWithoutMembersInput = {
    create?: XOR<HouseholdCreateWithoutMembersInput, HouseholdUncheckedCreateWithoutMembersInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutMembersInput
    connect?: HouseholdWhereUniqueInput
  }

  export type EnumHouseholdRoleFieldUpdateOperationsInput = {
    set?: $Enums.HouseholdRole
  }

  export type UserUpdateOneRequiredWithoutHouseholdMembersNestedInput = {
    create?: XOR<UserCreateWithoutHouseholdMembersInput, UserUncheckedCreateWithoutHouseholdMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutHouseholdMembersInput
    upsert?: UserUpsertWithoutHouseholdMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHouseholdMembersInput, UserUpdateWithoutHouseholdMembersInput>, UserUncheckedUpdateWithoutHouseholdMembersInput>
  }

  export type HouseholdUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<HouseholdCreateWithoutMembersInput, HouseholdUncheckedCreateWithoutMembersInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutMembersInput
    upsert?: HouseholdUpsertWithoutMembersInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutMembersInput, HouseholdUpdateWithoutMembersInput>, HouseholdUncheckedUpdateWithoutMembersInput>
  }

  export type AccountCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<AccountCreateWithoutInstitutionInput, AccountUncheckedCreateWithoutInstitutionInput> | AccountCreateWithoutInstitutionInput[] | AccountUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutInstitutionInput | AccountCreateOrConnectWithoutInstitutionInput[]
    createMany?: AccountCreateManyInstitutionInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<AccountCreateWithoutInstitutionInput, AccountUncheckedCreateWithoutInstitutionInput> | AccountCreateWithoutInstitutionInput[] | AccountUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutInstitutionInput | AccountCreateOrConnectWithoutInstitutionInput[]
    createMany?: AccountCreateManyInstitutionInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type EnumInstitutionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InstitutionType
  }

  export type AccountUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<AccountCreateWithoutInstitutionInput, AccountUncheckedCreateWithoutInstitutionInput> | AccountCreateWithoutInstitutionInput[] | AccountUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutInstitutionInput | AccountCreateOrConnectWithoutInstitutionInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutInstitutionInput | AccountUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: AccountCreateManyInstitutionInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutInstitutionInput | AccountUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutInstitutionInput | AccountUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<AccountCreateWithoutInstitutionInput, AccountUncheckedCreateWithoutInstitutionInput> | AccountCreateWithoutInstitutionInput[] | AccountUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutInstitutionInput | AccountCreateOrConnectWithoutInstitutionInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutInstitutionInput | AccountUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: AccountCreateManyInstitutionInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutInstitutionInput | AccountUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutInstitutionInput | AccountUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type HouseholdCreateNestedOneWithoutAccountsInput = {
    create?: XOR<HouseholdCreateWithoutAccountsInput, HouseholdUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutAccountsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutAccountsInput = {
    create?: XOR<InstitutionCreateWithoutAccountsInput, InstitutionUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutAccountsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutTransferAccountInput = {
    create?: XOR<TransactionCreateWithoutTransferAccountInput, TransactionUncheckedCreateWithoutTransferAccountInput> | TransactionCreateWithoutTransferAccountInput[] | TransactionUncheckedCreateWithoutTransferAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTransferAccountInput | TransactionCreateOrConnectWithoutTransferAccountInput[]
    createMany?: TransactionCreateManyTransferAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type RecurringTransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<RecurringTransactionCreateWithoutAccountInput, RecurringTransactionUncheckedCreateWithoutAccountInput> | RecurringTransactionCreateWithoutAccountInput[] | RecurringTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutAccountInput | RecurringTransactionCreateOrConnectWithoutAccountInput[]
    createMany?: RecurringTransactionCreateManyAccountInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type RecurringTransactionCreateNestedManyWithoutTransferAccountInput = {
    create?: XOR<RecurringTransactionCreateWithoutTransferAccountInput, RecurringTransactionUncheckedCreateWithoutTransferAccountInput> | RecurringTransactionCreateWithoutTransferAccountInput[] | RecurringTransactionUncheckedCreateWithoutTransferAccountInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutTransferAccountInput | RecurringTransactionCreateOrConnectWithoutTransferAccountInput[]
    createMany?: RecurringTransactionCreateManyTransferAccountInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutAccountInput = {
    create?: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput> | LedgerEntryCreateWithoutAccountInput[] | LedgerEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutAccountInput | LedgerEntryCreateOrConnectWithoutAccountInput[]
    createMany?: LedgerEntryCreateManyAccountInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type ZakatAssetBreakdownCreateNestedManyWithoutAccountInput = {
    create?: XOR<ZakatAssetBreakdownCreateWithoutAccountInput, ZakatAssetBreakdownUncheckedCreateWithoutAccountInput> | ZakatAssetBreakdownCreateWithoutAccountInput[] | ZakatAssetBreakdownUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ZakatAssetBreakdownCreateOrConnectWithoutAccountInput | ZakatAssetBreakdownCreateOrConnectWithoutAccountInput[]
    createMany?: ZakatAssetBreakdownCreateManyAccountInputEnvelope
    connect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
  }

  export type ShariaCompliantAccountCreateNestedOneWithoutAccountInput = {
    create?: XOR<ShariaCompliantAccountCreateWithoutAccountInput, ShariaCompliantAccountUncheckedCreateWithoutAccountInput>
    connectOrCreate?: ShariaCompliantAccountCreateOrConnectWithoutAccountInput
    connect?: ShariaCompliantAccountWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutTransferAccountInput = {
    create?: XOR<TransactionCreateWithoutTransferAccountInput, TransactionUncheckedCreateWithoutTransferAccountInput> | TransactionCreateWithoutTransferAccountInput[] | TransactionUncheckedCreateWithoutTransferAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTransferAccountInput | TransactionCreateOrConnectWithoutTransferAccountInput[]
    createMany?: TransactionCreateManyTransferAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<RecurringTransactionCreateWithoutAccountInput, RecurringTransactionUncheckedCreateWithoutAccountInput> | RecurringTransactionCreateWithoutAccountInput[] | RecurringTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutAccountInput | RecurringTransactionCreateOrConnectWithoutAccountInput[]
    createMany?: RecurringTransactionCreateManyAccountInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput = {
    create?: XOR<RecurringTransactionCreateWithoutTransferAccountInput, RecurringTransactionUncheckedCreateWithoutTransferAccountInput> | RecurringTransactionCreateWithoutTransferAccountInput[] | RecurringTransactionUncheckedCreateWithoutTransferAccountInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutTransferAccountInput | RecurringTransactionCreateOrConnectWithoutTransferAccountInput[]
    createMany?: RecurringTransactionCreateManyTransferAccountInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput> | LedgerEntryCreateWithoutAccountInput[] | LedgerEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutAccountInput | LedgerEntryCreateOrConnectWithoutAccountInput[]
    createMany?: LedgerEntryCreateManyAccountInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ZakatAssetBreakdownCreateWithoutAccountInput, ZakatAssetBreakdownUncheckedCreateWithoutAccountInput> | ZakatAssetBreakdownCreateWithoutAccountInput[] | ZakatAssetBreakdownUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ZakatAssetBreakdownCreateOrConnectWithoutAccountInput | ZakatAssetBreakdownCreateOrConnectWithoutAccountInput[]
    createMany?: ZakatAssetBreakdownCreateManyAccountInputEnvelope
    connect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
  }

  export type ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<ShariaCompliantAccountCreateWithoutAccountInput, ShariaCompliantAccountUncheckedCreateWithoutAccountInput>
    connectOrCreate?: ShariaCompliantAccountCreateOrConnectWithoutAccountInput
    connect?: ShariaCompliantAccountWhereUniqueInput
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type HouseholdUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<HouseholdCreateWithoutAccountsInput, HouseholdUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutAccountsInput
    upsert?: HouseholdUpsertWithoutAccountsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutAccountsInput, HouseholdUpdateWithoutAccountsInput>, HouseholdUncheckedUpdateWithoutAccountsInput>
  }

  export type InstitutionUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<InstitutionCreateWithoutAccountsInput, InstitutionUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutAccountsInput
    upsert?: InstitutionUpsertWithoutAccountsInput
    disconnect?: InstitutionWhereInput | boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutAccountsInput, InstitutionUpdateWithoutAccountsInput>, InstitutionUncheckedUpdateWithoutAccountsInput>
  }

  export type TransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutTransferAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutTransferAccountInput, TransactionUncheckedCreateWithoutTransferAccountInput> | TransactionCreateWithoutTransferAccountInput[] | TransactionUncheckedCreateWithoutTransferAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTransferAccountInput | TransactionCreateOrConnectWithoutTransferAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTransferAccountInput | TransactionUpsertWithWhereUniqueWithoutTransferAccountInput[]
    createMany?: TransactionCreateManyTransferAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTransferAccountInput | TransactionUpdateWithWhereUniqueWithoutTransferAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTransferAccountInput | TransactionUpdateManyWithWhereWithoutTransferAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type RecurringTransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutAccountInput, RecurringTransactionUncheckedCreateWithoutAccountInput> | RecurringTransactionCreateWithoutAccountInput[] | RecurringTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutAccountInput | RecurringTransactionCreateOrConnectWithoutAccountInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutAccountInput | RecurringTransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RecurringTransactionCreateManyAccountInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutAccountInput | RecurringTransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutAccountInput | RecurringTransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type RecurringTransactionUpdateManyWithoutTransferAccountNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutTransferAccountInput, RecurringTransactionUncheckedCreateWithoutTransferAccountInput> | RecurringTransactionCreateWithoutTransferAccountInput[] | RecurringTransactionUncheckedCreateWithoutTransferAccountInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutTransferAccountInput | RecurringTransactionCreateOrConnectWithoutTransferAccountInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutTransferAccountInput | RecurringTransactionUpsertWithWhereUniqueWithoutTransferAccountInput[]
    createMany?: RecurringTransactionCreateManyTransferAccountInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutTransferAccountInput | RecurringTransactionUpdateWithWhereUniqueWithoutTransferAccountInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutTransferAccountInput | RecurringTransactionUpdateManyWithWhereWithoutTransferAccountInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput> | LedgerEntryCreateWithoutAccountInput[] | LedgerEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutAccountInput | LedgerEntryCreateOrConnectWithoutAccountInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutAccountInput | LedgerEntryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: LedgerEntryCreateManyAccountInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutAccountInput | LedgerEntryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutAccountInput | LedgerEntryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ZakatAssetBreakdownCreateWithoutAccountInput, ZakatAssetBreakdownUncheckedCreateWithoutAccountInput> | ZakatAssetBreakdownCreateWithoutAccountInput[] | ZakatAssetBreakdownUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ZakatAssetBreakdownCreateOrConnectWithoutAccountInput | ZakatAssetBreakdownCreateOrConnectWithoutAccountInput[]
    upsert?: ZakatAssetBreakdownUpsertWithWhereUniqueWithoutAccountInput | ZakatAssetBreakdownUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ZakatAssetBreakdownCreateManyAccountInputEnvelope
    set?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    disconnect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    delete?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    connect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    update?: ZakatAssetBreakdownUpdateWithWhereUniqueWithoutAccountInput | ZakatAssetBreakdownUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ZakatAssetBreakdownUpdateManyWithWhereWithoutAccountInput | ZakatAssetBreakdownUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ZakatAssetBreakdownScalarWhereInput | ZakatAssetBreakdownScalarWhereInput[]
  }

  export type ShariaCompliantAccountUpdateOneWithoutAccountNestedInput = {
    create?: XOR<ShariaCompliantAccountCreateWithoutAccountInput, ShariaCompliantAccountUncheckedCreateWithoutAccountInput>
    connectOrCreate?: ShariaCompliantAccountCreateOrConnectWithoutAccountInput
    upsert?: ShariaCompliantAccountUpsertWithoutAccountInput
    disconnect?: ShariaCompliantAccountWhereInput | boolean
    delete?: ShariaCompliantAccountWhereInput | boolean
    connect?: ShariaCompliantAccountWhereUniqueInput
    update?: XOR<XOR<ShariaCompliantAccountUpdateToOneWithWhereWithoutAccountInput, ShariaCompliantAccountUpdateWithoutAccountInput>, ShariaCompliantAccountUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutTransferAccountInput, TransactionUncheckedCreateWithoutTransferAccountInput> | TransactionCreateWithoutTransferAccountInput[] | TransactionUncheckedCreateWithoutTransferAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTransferAccountInput | TransactionCreateOrConnectWithoutTransferAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTransferAccountInput | TransactionUpsertWithWhereUniqueWithoutTransferAccountInput[]
    createMany?: TransactionCreateManyTransferAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTransferAccountInput | TransactionUpdateWithWhereUniqueWithoutTransferAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTransferAccountInput | TransactionUpdateManyWithWhereWithoutTransferAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutAccountInput, RecurringTransactionUncheckedCreateWithoutAccountInput> | RecurringTransactionCreateWithoutAccountInput[] | RecurringTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutAccountInput | RecurringTransactionCreateOrConnectWithoutAccountInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutAccountInput | RecurringTransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RecurringTransactionCreateManyAccountInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutAccountInput | RecurringTransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutAccountInput | RecurringTransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutTransferAccountInput, RecurringTransactionUncheckedCreateWithoutTransferAccountInput> | RecurringTransactionCreateWithoutTransferAccountInput[] | RecurringTransactionUncheckedCreateWithoutTransferAccountInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutTransferAccountInput | RecurringTransactionCreateOrConnectWithoutTransferAccountInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutTransferAccountInput | RecurringTransactionUpsertWithWhereUniqueWithoutTransferAccountInput[]
    createMany?: RecurringTransactionCreateManyTransferAccountInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutTransferAccountInput | RecurringTransactionUpdateWithWhereUniqueWithoutTransferAccountInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutTransferAccountInput | RecurringTransactionUpdateManyWithWhereWithoutTransferAccountInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput> | LedgerEntryCreateWithoutAccountInput[] | LedgerEntryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutAccountInput | LedgerEntryCreateOrConnectWithoutAccountInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutAccountInput | LedgerEntryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: LedgerEntryCreateManyAccountInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutAccountInput | LedgerEntryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutAccountInput | LedgerEntryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ZakatAssetBreakdownCreateWithoutAccountInput, ZakatAssetBreakdownUncheckedCreateWithoutAccountInput> | ZakatAssetBreakdownCreateWithoutAccountInput[] | ZakatAssetBreakdownUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ZakatAssetBreakdownCreateOrConnectWithoutAccountInput | ZakatAssetBreakdownCreateOrConnectWithoutAccountInput[]
    upsert?: ZakatAssetBreakdownUpsertWithWhereUniqueWithoutAccountInput | ZakatAssetBreakdownUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ZakatAssetBreakdownCreateManyAccountInputEnvelope
    set?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    disconnect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    delete?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    connect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    update?: ZakatAssetBreakdownUpdateWithWhereUniqueWithoutAccountInput | ZakatAssetBreakdownUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ZakatAssetBreakdownUpdateManyWithWhereWithoutAccountInput | ZakatAssetBreakdownUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ZakatAssetBreakdownScalarWhereInput | ZakatAssetBreakdownScalarWhereInput[]
  }

  export type ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<ShariaCompliantAccountCreateWithoutAccountInput, ShariaCompliantAccountUncheckedCreateWithoutAccountInput>
    connectOrCreate?: ShariaCompliantAccountCreateOrConnectWithoutAccountInput
    upsert?: ShariaCompliantAccountUpsertWithoutAccountInput
    disconnect?: ShariaCompliantAccountWhereInput | boolean
    delete?: ShariaCompliantAccountWhereInput | boolean
    connect?: ShariaCompliantAccountWhereUniqueInput
    update?: XOR<XOR<ShariaCompliantAccountUpdateToOneWithWhereWithoutAccountInput, ShariaCompliantAccountUpdateWithoutAccountInput>, ShariaCompliantAccountUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionCreateNestedManyWithoutMerchantDataInput = {
    create?: XOR<TransactionCreateWithoutMerchantDataInput, TransactionUncheckedCreateWithoutMerchantDataInput> | TransactionCreateWithoutMerchantDataInput[] | TransactionUncheckedCreateWithoutMerchantDataInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutMerchantDataInput | TransactionCreateOrConnectWithoutMerchantDataInput[]
    createMany?: TransactionCreateManyMerchantDataInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutMerchantDataInput = {
    create?: XOR<TransactionCreateWithoutMerchantDataInput, TransactionUncheckedCreateWithoutMerchantDataInput> | TransactionCreateWithoutMerchantDataInput[] | TransactionUncheckedCreateWithoutMerchantDataInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutMerchantDataInput | TransactionCreateOrConnectWithoutMerchantDataInput[]
    createMany?: TransactionCreateManyMerchantDataInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutMerchantDataNestedInput = {
    create?: XOR<TransactionCreateWithoutMerchantDataInput, TransactionUncheckedCreateWithoutMerchantDataInput> | TransactionCreateWithoutMerchantDataInput[] | TransactionUncheckedCreateWithoutMerchantDataInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutMerchantDataInput | TransactionCreateOrConnectWithoutMerchantDataInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutMerchantDataInput | TransactionUpsertWithWhereUniqueWithoutMerchantDataInput[]
    createMany?: TransactionCreateManyMerchantDataInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutMerchantDataInput | TransactionUpdateWithWhereUniqueWithoutMerchantDataInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutMerchantDataInput | TransactionUpdateManyWithWhereWithoutMerchantDataInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutMerchantDataNestedInput = {
    create?: XOR<TransactionCreateWithoutMerchantDataInput, TransactionUncheckedCreateWithoutMerchantDataInput> | TransactionCreateWithoutMerchantDataInput[] | TransactionUncheckedCreateWithoutMerchantDataInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutMerchantDataInput | TransactionCreateOrConnectWithoutMerchantDataInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutMerchantDataInput | TransactionUpsertWithWhereUniqueWithoutMerchantDataInput[]
    createMany?: TransactionCreateManyMerchantDataInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutMerchantDataInput | TransactionUpdateWithWhereUniqueWithoutMerchantDataInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutMerchantDataInput | TransactionUpdateManyWithWhereWithoutMerchantDataInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type HouseholdCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<HouseholdCreateWithoutCategoriesInput, HouseholdUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutCategoriesInput
    connect?: HouseholdWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionSplitCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionSplitCreateWithoutCategoryInput, TransactionSplitUncheckedCreateWithoutCategoryInput> | TransactionSplitCreateWithoutCategoryInput[] | TransactionSplitUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionSplitCreateOrConnectWithoutCategoryInput | TransactionSplitCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionSplitCreateManyCategoryInputEnvelope
    connect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
  }

  export type BudgetCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput> | BudgetCategoryCreateWithoutCategoryInput[] | BudgetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutCategoryInput | BudgetCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: BudgetCategoryCreateManyCategoryInputEnvelope
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
  }

  export type RecurringTransactionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RecurringTransactionCreateWithoutCategoryInput, RecurringTransactionUncheckedCreateWithoutCategoryInput> | RecurringTransactionCreateWithoutCategoryInput[] | RecurringTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutCategoryInput | RecurringTransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: RecurringTransactionCreateManyCategoryInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type GratitudeEntryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GratitudeEntryCreateWithoutCategoryInput, GratitudeEntryUncheckedCreateWithoutCategoryInput> | GratitudeEntryCreateWithoutCategoryInput[] | GratitudeEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutCategoryInput | GratitudeEntryCreateOrConnectWithoutCategoryInput[]
    createMany?: GratitudeEntryCreateManyCategoryInputEnvelope
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
  }

  export type TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput = {
    create?: XOR<TransactionSuggestionCreateWithoutSuggestedCategoryInput, TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput> | TransactionSuggestionCreateWithoutSuggestedCategoryInput[] | TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput | TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput[]
    createMany?: TransactionSuggestionCreateManySuggestedCategoryInputEnvelope
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionSplitCreateWithoutCategoryInput, TransactionSplitUncheckedCreateWithoutCategoryInput> | TransactionSplitCreateWithoutCategoryInput[] | TransactionSplitUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionSplitCreateOrConnectWithoutCategoryInput | TransactionSplitCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionSplitCreateManyCategoryInputEnvelope
    connect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
  }

  export type BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput> | BudgetCategoryCreateWithoutCategoryInput[] | BudgetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutCategoryInput | BudgetCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: BudgetCategoryCreateManyCategoryInputEnvelope
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
  }

  export type RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RecurringTransactionCreateWithoutCategoryInput, RecurringTransactionUncheckedCreateWithoutCategoryInput> | RecurringTransactionCreateWithoutCategoryInput[] | RecurringTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutCategoryInput | RecurringTransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: RecurringTransactionCreateManyCategoryInputEnvelope
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
  }

  export type GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GratitudeEntryCreateWithoutCategoryInput, GratitudeEntryUncheckedCreateWithoutCategoryInput> | GratitudeEntryCreateWithoutCategoryInput[] | GratitudeEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutCategoryInput | GratitudeEntryCreateOrConnectWithoutCategoryInput[]
    createMany?: GratitudeEntryCreateManyCategoryInputEnvelope
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
  }

  export type TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput = {
    create?: XOR<TransactionSuggestionCreateWithoutSuggestedCategoryInput, TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput> | TransactionSuggestionCreateWithoutSuggestedCategoryInput[] | TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput | TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput[]
    createMany?: TransactionSuggestionCreateManySuggestedCategoryInputEnvelope
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
  }

  export type EnumCategoryTypeFieldUpdateOperationsInput = {
    set?: $Enums.CategoryType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HouseholdUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<HouseholdCreateWithoutCategoriesInput, HouseholdUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutCategoriesInput
    upsert?: HouseholdUpsertWithoutCategoriesInput
    disconnect?: HouseholdWhereInput | boolean
    delete?: HouseholdWhereInput | boolean
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutCategoriesInput, HouseholdUpdateWithoutCategoriesInput>, HouseholdUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCategoryInput | TransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCategoryInput | TransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCategoryInput | TransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionSplitUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionSplitCreateWithoutCategoryInput, TransactionSplitUncheckedCreateWithoutCategoryInput> | TransactionSplitCreateWithoutCategoryInput[] | TransactionSplitUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionSplitCreateOrConnectWithoutCategoryInput | TransactionSplitCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionSplitUpsertWithWhereUniqueWithoutCategoryInput | TransactionSplitUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionSplitCreateManyCategoryInputEnvelope
    set?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    disconnect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    delete?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    connect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    update?: TransactionSplitUpdateWithWhereUniqueWithoutCategoryInput | TransactionSplitUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionSplitUpdateManyWithWhereWithoutCategoryInput | TransactionSplitUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionSplitScalarWhereInput | TransactionSplitScalarWhereInput[]
  }

  export type BudgetCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput> | BudgetCategoryCreateWithoutCategoryInput[] | BudgetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutCategoryInput | BudgetCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput | BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BudgetCategoryCreateManyCategoryInputEnvelope
    set?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    disconnect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    delete?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    update?: BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput | BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BudgetCategoryUpdateManyWithWhereWithoutCategoryInput | BudgetCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
  }

  export type RecurringTransactionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutCategoryInput, RecurringTransactionUncheckedCreateWithoutCategoryInput> | RecurringTransactionCreateWithoutCategoryInput[] | RecurringTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutCategoryInput | RecurringTransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutCategoryInput | RecurringTransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RecurringTransactionCreateManyCategoryInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutCategoryInput | RecurringTransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutCategoryInput | RecurringTransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type GratitudeEntryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GratitudeEntryCreateWithoutCategoryInput, GratitudeEntryUncheckedCreateWithoutCategoryInput> | GratitudeEntryCreateWithoutCategoryInput[] | GratitudeEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutCategoryInput | GratitudeEntryCreateOrConnectWithoutCategoryInput[]
    upsert?: GratitudeEntryUpsertWithWhereUniqueWithoutCategoryInput | GratitudeEntryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GratitudeEntryCreateManyCategoryInputEnvelope
    set?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    disconnect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    delete?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    update?: GratitudeEntryUpdateWithWhereUniqueWithoutCategoryInput | GratitudeEntryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GratitudeEntryUpdateManyWithWhereWithoutCategoryInput | GratitudeEntryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
  }

  export type TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput = {
    create?: XOR<TransactionSuggestionCreateWithoutSuggestedCategoryInput, TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput> | TransactionSuggestionCreateWithoutSuggestedCategoryInput[] | TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput | TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput[]
    upsert?: TransactionSuggestionUpsertWithWhereUniqueWithoutSuggestedCategoryInput | TransactionSuggestionUpsertWithWhereUniqueWithoutSuggestedCategoryInput[]
    createMany?: TransactionSuggestionCreateManySuggestedCategoryInputEnvelope
    set?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    disconnect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    delete?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    update?: TransactionSuggestionUpdateWithWhereUniqueWithoutSuggestedCategoryInput | TransactionSuggestionUpdateWithWhereUniqueWithoutSuggestedCategoryInput[]
    updateMany?: TransactionSuggestionUpdateManyWithWhereWithoutSuggestedCategoryInput | TransactionSuggestionUpdateManyWithWhereWithoutSuggestedCategoryInput[]
    deleteMany?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCategoryInput | TransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCategoryInput | TransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCategoryInput | TransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionSplitCreateWithoutCategoryInput, TransactionSplitUncheckedCreateWithoutCategoryInput> | TransactionSplitCreateWithoutCategoryInput[] | TransactionSplitUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionSplitCreateOrConnectWithoutCategoryInput | TransactionSplitCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionSplitUpsertWithWhereUniqueWithoutCategoryInput | TransactionSplitUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionSplitCreateManyCategoryInputEnvelope
    set?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    disconnect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    delete?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    connect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    update?: TransactionSplitUpdateWithWhereUniqueWithoutCategoryInput | TransactionSplitUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionSplitUpdateManyWithWhereWithoutCategoryInput | TransactionSplitUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionSplitScalarWhereInput | TransactionSplitScalarWhereInput[]
  }

  export type BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput> | BudgetCategoryCreateWithoutCategoryInput[] | BudgetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutCategoryInput | BudgetCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput | BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BudgetCategoryCreateManyCategoryInputEnvelope
    set?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    disconnect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    delete?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    update?: BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput | BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BudgetCategoryUpdateManyWithWhereWithoutCategoryInput | BudgetCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutCategoryInput, RecurringTransactionUncheckedCreateWithoutCategoryInput> | RecurringTransactionCreateWithoutCategoryInput[] | RecurringTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutCategoryInput | RecurringTransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: RecurringTransactionUpsertWithWhereUniqueWithoutCategoryInput | RecurringTransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RecurringTransactionCreateManyCategoryInputEnvelope
    set?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    disconnect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    delete?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    connect?: RecurringTransactionWhereUniqueInput | RecurringTransactionWhereUniqueInput[]
    update?: RecurringTransactionUpdateWithWhereUniqueWithoutCategoryInput | RecurringTransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RecurringTransactionUpdateManyWithWhereWithoutCategoryInput | RecurringTransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
  }

  export type GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GratitudeEntryCreateWithoutCategoryInput, GratitudeEntryUncheckedCreateWithoutCategoryInput> | GratitudeEntryCreateWithoutCategoryInput[] | GratitudeEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutCategoryInput | GratitudeEntryCreateOrConnectWithoutCategoryInput[]
    upsert?: GratitudeEntryUpsertWithWhereUniqueWithoutCategoryInput | GratitudeEntryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GratitudeEntryCreateManyCategoryInputEnvelope
    set?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    disconnect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    delete?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    update?: GratitudeEntryUpdateWithWhereUniqueWithoutCategoryInput | GratitudeEntryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GratitudeEntryUpdateManyWithWhereWithoutCategoryInput | GratitudeEntryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
  }

  export type TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput = {
    create?: XOR<TransactionSuggestionCreateWithoutSuggestedCategoryInput, TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput> | TransactionSuggestionCreateWithoutSuggestedCategoryInput[] | TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput | TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput[]
    upsert?: TransactionSuggestionUpsertWithWhereUniqueWithoutSuggestedCategoryInput | TransactionSuggestionUpsertWithWhereUniqueWithoutSuggestedCategoryInput[]
    createMany?: TransactionSuggestionCreateManySuggestedCategoryInputEnvelope
    set?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    disconnect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    delete?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    update?: TransactionSuggestionUpdateWithWhereUniqueWithoutSuggestedCategoryInput | TransactionSuggestionUpdateWithWhereUniqueWithoutSuggestedCategoryInput[]
    updateMany?: TransactionSuggestionUpdateManyWithWhereWithoutSuggestedCategoryInput | TransactionSuggestionUpdateManyWithWhereWithoutSuggestedCategoryInput[]
    deleteMany?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
  }

  export type HouseholdCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<HouseholdCreateWithoutTransactionsInput, HouseholdUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutTransactionsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutTransferTransactionsInput = {
    create?: XOR<AccountCreateWithoutTransferTransactionsInput, AccountUncheckedCreateWithoutTransferTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransferTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<MerchantCreateWithoutTransactionsInput, MerchantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutTransactionsInput
    connect?: MerchantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTransactionsInput = {
    create?: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionTagCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput> | TransactionTagCreateWithoutTransactionInput[] | TransactionTagUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTransactionInput | TransactionTagCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionTagCreateManyTransactionInputEnvelope
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
  }

  export type TransactionSplitCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionSplitCreateWithoutTransactionInput, TransactionSplitUncheckedCreateWithoutTransactionInput> | TransactionSplitCreateWithoutTransactionInput[] | TransactionSplitUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionSplitCreateOrConnectWithoutTransactionInput | TransactionSplitCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionSplitCreateManyTransactionInputEnvelope
    connect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutTransactionInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput = {
    create?: XOR<RecurringTransactionExecutionCreateWithoutTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput> | RecurringTransactionExecutionCreateWithoutTransactionInput[] | RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput | RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput[]
    createMany?: RecurringTransactionExecutionCreateManyTransactionInputEnvelope
    connect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
  }

  export type GratitudeEntryCreateNestedManyWithoutTransactionInput = {
    create?: XOR<GratitudeEntryCreateWithoutTransactionInput, GratitudeEntryUncheckedCreateWithoutTransactionInput> | GratitudeEntryCreateWithoutTransactionInput[] | GratitudeEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutTransactionInput | GratitudeEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: GratitudeEntryCreateManyTransactionInputEnvelope
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
  }

  export type TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput = {
    create?: XOR<TransactionSuggestionCreateWithoutCreatedTransactionInput, TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput> | TransactionSuggestionCreateWithoutCreatedTransactionInput[] | TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput | TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput[]
    createMany?: TransactionSuggestionCreateManyCreatedTransactionInputEnvelope
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
  }

  export type ZakatPaymentCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ZakatPaymentCreateWithoutTransactionInput, ZakatPaymentUncheckedCreateWithoutTransactionInput> | ZakatPaymentCreateWithoutTransactionInput[] | ZakatPaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutTransactionInput | ZakatPaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: ZakatPaymentCreateManyTransactionInputEnvelope
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
  }

  export type TransactionTagUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput> | TransactionTagCreateWithoutTransactionInput[] | TransactionTagUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTransactionInput | TransactionTagCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionTagCreateManyTransactionInputEnvelope
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
  }

  export type TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionSplitCreateWithoutTransactionInput, TransactionSplitUncheckedCreateWithoutTransactionInput> | TransactionSplitCreateWithoutTransactionInput[] | TransactionSplitUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionSplitCreateOrConnectWithoutTransactionInput | TransactionSplitCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionSplitCreateManyTransactionInputEnvelope
    connect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<RecurringTransactionExecutionCreateWithoutTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput> | RecurringTransactionExecutionCreateWithoutTransactionInput[] | RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput | RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput[]
    createMany?: RecurringTransactionExecutionCreateManyTransactionInputEnvelope
    connect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
  }

  export type GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<GratitudeEntryCreateWithoutTransactionInput, GratitudeEntryUncheckedCreateWithoutTransactionInput> | GratitudeEntryCreateWithoutTransactionInput[] | GratitudeEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutTransactionInput | GratitudeEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: GratitudeEntryCreateManyTransactionInputEnvelope
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
  }

  export type TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput = {
    create?: XOR<TransactionSuggestionCreateWithoutCreatedTransactionInput, TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput> | TransactionSuggestionCreateWithoutCreatedTransactionInput[] | TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput | TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput[]
    createMany?: TransactionSuggestionCreateManyCreatedTransactionInputEnvelope
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
  }

  export type ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ZakatPaymentCreateWithoutTransactionInput, ZakatPaymentUncheckedCreateWithoutTransactionInput> | ZakatPaymentCreateWithoutTransactionInput[] | ZakatPaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutTransactionInput | ZakatPaymentCreateOrConnectWithoutTransactionInput[]
    createMany?: ZakatPaymentCreateManyTransactionInputEnvelope
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type HouseholdUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<HouseholdCreateWithoutTransactionsInput, HouseholdUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutTransactionsInput
    upsert?: HouseholdUpsertWithoutTransactionsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutTransactionsInput, HouseholdUpdateWithoutTransactionsInput>, HouseholdUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    upsert?: AccountUpsertWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTransactionsInput, AccountUpdateWithoutTransactionsInput>, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateOneWithoutTransferTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutTransferTransactionsInput, AccountUncheckedCreateWithoutTransferTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransferTransactionsInput
    upsert?: AccountUpsertWithoutTransferTransactionsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTransferTransactionsInput, AccountUpdateWithoutTransferTransactionsInput>, AccountUncheckedUpdateWithoutTransferTransactionsInput>
  }

  export type CategoryUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionsInput
    upsert?: CategoryUpsertWithoutTransactionsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTransactionsInput, CategoryUpdateWithoutTransactionsInput>, CategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type MerchantUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<MerchantCreateWithoutTransactionsInput, MerchantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutTransactionsInput
    upsert?: MerchantUpsertWithoutTransactionsInput
    disconnect?: MerchantWhereInput | boolean
    delete?: MerchantWhereInput | boolean
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutTransactionsInput, MerchantUpdateWithoutTransactionsInput>, MerchantUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTransactionsInput
    upsert?: UserUpsertWithoutCreatedTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTransactionsInput, UserUpdateWithoutCreatedTransactionsInput>, UserUncheckedUpdateWithoutCreatedTransactionsInput>
  }

  export type TransactionTagUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput> | TransactionTagCreateWithoutTransactionInput[] | TransactionTagUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTransactionInput | TransactionTagCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionTagUpsertWithWhereUniqueWithoutTransactionInput | TransactionTagUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionTagCreateManyTransactionInputEnvelope
    set?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    disconnect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    delete?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    update?: TransactionTagUpdateWithWhereUniqueWithoutTransactionInput | TransactionTagUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionTagUpdateManyWithWhereWithoutTransactionInput | TransactionTagUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
  }

  export type TransactionSplitUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionSplitCreateWithoutTransactionInput, TransactionSplitUncheckedCreateWithoutTransactionInput> | TransactionSplitCreateWithoutTransactionInput[] | TransactionSplitUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionSplitCreateOrConnectWithoutTransactionInput | TransactionSplitCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionSplitUpsertWithWhereUniqueWithoutTransactionInput | TransactionSplitUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionSplitCreateManyTransactionInputEnvelope
    set?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    disconnect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    delete?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    connect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    update?: TransactionSplitUpdateWithWhereUniqueWithoutTransactionInput | TransactionSplitUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionSplitUpdateManyWithWhereWithoutTransactionInput | TransactionSplitUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionSplitScalarWhereInput | TransactionSplitScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput | LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput | LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutTransactionInput | LedgerEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<RecurringTransactionExecutionCreateWithoutTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput> | RecurringTransactionExecutionCreateWithoutTransactionInput[] | RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput | RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput[]
    upsert?: RecurringTransactionExecutionUpsertWithWhereUniqueWithoutTransactionInput | RecurringTransactionExecutionUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: RecurringTransactionExecutionCreateManyTransactionInputEnvelope
    set?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    disconnect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    delete?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    connect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    update?: RecurringTransactionExecutionUpdateWithWhereUniqueWithoutTransactionInput | RecurringTransactionExecutionUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: RecurringTransactionExecutionUpdateManyWithWhereWithoutTransactionInput | RecurringTransactionExecutionUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: RecurringTransactionExecutionScalarWhereInput | RecurringTransactionExecutionScalarWhereInput[]
  }

  export type GratitudeEntryUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<GratitudeEntryCreateWithoutTransactionInput, GratitudeEntryUncheckedCreateWithoutTransactionInput> | GratitudeEntryCreateWithoutTransactionInput[] | GratitudeEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutTransactionInput | GratitudeEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: GratitudeEntryUpsertWithWhereUniqueWithoutTransactionInput | GratitudeEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: GratitudeEntryCreateManyTransactionInputEnvelope
    set?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    disconnect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    delete?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    update?: GratitudeEntryUpdateWithWhereUniqueWithoutTransactionInput | GratitudeEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: GratitudeEntryUpdateManyWithWhereWithoutTransactionInput | GratitudeEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
  }

  export type TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput = {
    create?: XOR<TransactionSuggestionCreateWithoutCreatedTransactionInput, TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput> | TransactionSuggestionCreateWithoutCreatedTransactionInput[] | TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput | TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput[]
    upsert?: TransactionSuggestionUpsertWithWhereUniqueWithoutCreatedTransactionInput | TransactionSuggestionUpsertWithWhereUniqueWithoutCreatedTransactionInput[]
    createMany?: TransactionSuggestionCreateManyCreatedTransactionInputEnvelope
    set?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    disconnect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    delete?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    update?: TransactionSuggestionUpdateWithWhereUniqueWithoutCreatedTransactionInput | TransactionSuggestionUpdateWithWhereUniqueWithoutCreatedTransactionInput[]
    updateMany?: TransactionSuggestionUpdateManyWithWhereWithoutCreatedTransactionInput | TransactionSuggestionUpdateManyWithWhereWithoutCreatedTransactionInput[]
    deleteMany?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
  }

  export type ZakatPaymentUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ZakatPaymentCreateWithoutTransactionInput, ZakatPaymentUncheckedCreateWithoutTransactionInput> | ZakatPaymentCreateWithoutTransactionInput[] | ZakatPaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutTransactionInput | ZakatPaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: ZakatPaymentUpsertWithWhereUniqueWithoutTransactionInput | ZakatPaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ZakatPaymentCreateManyTransactionInputEnvelope
    set?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    disconnect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    delete?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    update?: ZakatPaymentUpdateWithWhereUniqueWithoutTransactionInput | ZakatPaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ZakatPaymentUpdateManyWithWhereWithoutTransactionInput | ZakatPaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ZakatPaymentScalarWhereInput | ZakatPaymentScalarWhereInput[]
  }

  export type TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput> | TransactionTagCreateWithoutTransactionInput[] | TransactionTagUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionTagCreateOrConnectWithoutTransactionInput | TransactionTagCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionTagUpsertWithWhereUniqueWithoutTransactionInput | TransactionTagUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionTagCreateManyTransactionInputEnvelope
    set?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    disconnect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    delete?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    connect?: TransactionTagWhereUniqueInput | TransactionTagWhereUniqueInput[]
    update?: TransactionTagUpdateWithWhereUniqueWithoutTransactionInput | TransactionTagUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionTagUpdateManyWithWhereWithoutTransactionInput | TransactionTagUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
  }

  export type TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionSplitCreateWithoutTransactionInput, TransactionSplitUncheckedCreateWithoutTransactionInput> | TransactionSplitCreateWithoutTransactionInput[] | TransactionSplitUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionSplitCreateOrConnectWithoutTransactionInput | TransactionSplitCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionSplitUpsertWithWhereUniqueWithoutTransactionInput | TransactionSplitUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionSplitCreateManyTransactionInputEnvelope
    set?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    disconnect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    delete?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    connect?: TransactionSplitWhereUniqueInput | TransactionSplitWhereUniqueInput[]
    update?: TransactionSplitUpdateWithWhereUniqueWithoutTransactionInput | TransactionSplitUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionSplitUpdateManyWithWhereWithoutTransactionInput | TransactionSplitUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionSplitScalarWhereInput | TransactionSplitScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput | LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput | LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutTransactionInput | LedgerEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<RecurringTransactionExecutionCreateWithoutTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput> | RecurringTransactionExecutionCreateWithoutTransactionInput[] | RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput | RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput[]
    upsert?: RecurringTransactionExecutionUpsertWithWhereUniqueWithoutTransactionInput | RecurringTransactionExecutionUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: RecurringTransactionExecutionCreateManyTransactionInputEnvelope
    set?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    disconnect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    delete?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    connect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    update?: RecurringTransactionExecutionUpdateWithWhereUniqueWithoutTransactionInput | RecurringTransactionExecutionUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: RecurringTransactionExecutionUpdateManyWithWhereWithoutTransactionInput | RecurringTransactionExecutionUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: RecurringTransactionExecutionScalarWhereInput | RecurringTransactionExecutionScalarWhereInput[]
  }

  export type GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<GratitudeEntryCreateWithoutTransactionInput, GratitudeEntryUncheckedCreateWithoutTransactionInput> | GratitudeEntryCreateWithoutTransactionInput[] | GratitudeEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: GratitudeEntryCreateOrConnectWithoutTransactionInput | GratitudeEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: GratitudeEntryUpsertWithWhereUniqueWithoutTransactionInput | GratitudeEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: GratitudeEntryCreateManyTransactionInputEnvelope
    set?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    disconnect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    delete?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    connect?: GratitudeEntryWhereUniqueInput | GratitudeEntryWhereUniqueInput[]
    update?: GratitudeEntryUpdateWithWhereUniqueWithoutTransactionInput | GratitudeEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: GratitudeEntryUpdateManyWithWhereWithoutTransactionInput | GratitudeEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
  }

  export type TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput = {
    create?: XOR<TransactionSuggestionCreateWithoutCreatedTransactionInput, TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput> | TransactionSuggestionCreateWithoutCreatedTransactionInput[] | TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput | TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput[]
    upsert?: TransactionSuggestionUpsertWithWhereUniqueWithoutCreatedTransactionInput | TransactionSuggestionUpsertWithWhereUniqueWithoutCreatedTransactionInput[]
    createMany?: TransactionSuggestionCreateManyCreatedTransactionInputEnvelope
    set?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    disconnect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    delete?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    update?: TransactionSuggestionUpdateWithWhereUniqueWithoutCreatedTransactionInput | TransactionSuggestionUpdateWithWhereUniqueWithoutCreatedTransactionInput[]
    updateMany?: TransactionSuggestionUpdateManyWithWhereWithoutCreatedTransactionInput | TransactionSuggestionUpdateManyWithWhereWithoutCreatedTransactionInput[]
    deleteMany?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
  }

  export type ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ZakatPaymentCreateWithoutTransactionInput, ZakatPaymentUncheckedCreateWithoutTransactionInput> | ZakatPaymentCreateWithoutTransactionInput[] | ZakatPaymentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutTransactionInput | ZakatPaymentCreateOrConnectWithoutTransactionInput[]
    upsert?: ZakatPaymentUpsertWithWhereUniqueWithoutTransactionInput | ZakatPaymentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ZakatPaymentCreateManyTransactionInputEnvelope
    set?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    disconnect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    delete?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    update?: ZakatPaymentUpdateWithWhereUniqueWithoutTransactionInput | ZakatPaymentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ZakatPaymentUpdateManyWithWhereWithoutTransactionInput | ZakatPaymentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ZakatPaymentScalarWhereInput | ZakatPaymentScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutTagsInput = {
    create?: XOR<TransactionCreateWithoutTagsInput, TransactionUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutTagsInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<TransactionCreateWithoutTagsInput, TransactionUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutTagsInput
    upsert?: TransactionUpsertWithoutTagsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutTagsInput, TransactionUpdateWithoutTagsInput>, TransactionUncheckedUpdateWithoutTagsInput>
  }

  export type TransactionCreateNestedOneWithoutSplitsInput = {
    create?: XOR<TransactionCreateWithoutSplitsInput, TransactionUncheckedCreateWithoutSplitsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutSplitsInput
    connect?: TransactionWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutTransactionSplitsInput = {
    create?: XOR<CategoryCreateWithoutTransactionSplitsInput, CategoryUncheckedCreateWithoutTransactionSplitsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionSplitsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutSplitsNestedInput = {
    create?: XOR<TransactionCreateWithoutSplitsInput, TransactionUncheckedCreateWithoutSplitsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutSplitsInput
    upsert?: TransactionUpsertWithoutSplitsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutSplitsInput, TransactionUpdateWithoutSplitsInput>, TransactionUncheckedUpdateWithoutSplitsInput>
  }

  export type CategoryUpdateOneRequiredWithoutTransactionSplitsNestedInput = {
    create?: XOR<CategoryCreateWithoutTransactionSplitsInput, CategoryUncheckedCreateWithoutTransactionSplitsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionSplitsInput
    upsert?: CategoryUpsertWithoutTransactionSplitsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTransactionSplitsInput, CategoryUpdateWithoutTransactionSplitsInput>, CategoryUncheckedUpdateWithoutTransactionSplitsInput>
  }

  export type TransactionCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutLedgerEntriesInput
    connect?: TransactionWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<AccountCreateWithoutLedgerEntriesInput, AccountUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutLedgerEntriesInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumLedgerTypeFieldUpdateOperationsInput = {
    set?: $Enums.LedgerType
  }

  export type TransactionUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutLedgerEntriesInput
    upsert?: TransactionUpsertWithoutLedgerEntriesInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutLedgerEntriesInput, TransactionUpdateWithoutLedgerEntriesInput>, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type AccountUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<AccountCreateWithoutLedgerEntriesInput, AccountUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutLedgerEntriesInput
    upsert?: AccountUpsertWithoutLedgerEntriesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutLedgerEntriesInput, AccountUpdateWithoutLedgerEntriesInput>, AccountUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type HouseholdCreateNestedOneWithoutDebtsInput = {
    create?: XOR<HouseholdCreateWithoutDebtsInput, HouseholdUncheckedCreateWithoutDebtsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutDebtsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type DebtPaymentCreateNestedManyWithoutDebtInput = {
    create?: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput> | DebtPaymentCreateWithoutDebtInput[] | DebtPaymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutDebtInput | DebtPaymentCreateOrConnectWithoutDebtInput[]
    createMany?: DebtPaymentCreateManyDebtInputEnvelope
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
  }

  export type DebtPaymentUncheckedCreateNestedManyWithoutDebtInput = {
    create?: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput> | DebtPaymentCreateWithoutDebtInput[] | DebtPaymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutDebtInput | DebtPaymentCreateOrConnectWithoutDebtInput[]
    createMany?: DebtPaymentCreateManyDebtInputEnvelope
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
  }

  export type EnumDebtTypeFieldUpdateOperationsInput = {
    set?: $Enums.DebtType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type HouseholdUpdateOneRequiredWithoutDebtsNestedInput = {
    create?: XOR<HouseholdCreateWithoutDebtsInput, HouseholdUncheckedCreateWithoutDebtsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutDebtsInput
    upsert?: HouseholdUpsertWithoutDebtsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutDebtsInput, HouseholdUpdateWithoutDebtsInput>, HouseholdUncheckedUpdateWithoutDebtsInput>
  }

  export type DebtPaymentUpdateManyWithoutDebtNestedInput = {
    create?: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput> | DebtPaymentCreateWithoutDebtInput[] | DebtPaymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutDebtInput | DebtPaymentCreateOrConnectWithoutDebtInput[]
    upsert?: DebtPaymentUpsertWithWhereUniqueWithoutDebtInput | DebtPaymentUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: DebtPaymentCreateManyDebtInputEnvelope
    set?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    disconnect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    delete?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    update?: DebtPaymentUpdateWithWhereUniqueWithoutDebtInput | DebtPaymentUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: DebtPaymentUpdateManyWithWhereWithoutDebtInput | DebtPaymentUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
  }

  export type DebtPaymentUncheckedUpdateManyWithoutDebtNestedInput = {
    create?: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput> | DebtPaymentCreateWithoutDebtInput[] | DebtPaymentUncheckedCreateWithoutDebtInput[]
    connectOrCreate?: DebtPaymentCreateOrConnectWithoutDebtInput | DebtPaymentCreateOrConnectWithoutDebtInput[]
    upsert?: DebtPaymentUpsertWithWhereUniqueWithoutDebtInput | DebtPaymentUpsertWithWhereUniqueWithoutDebtInput[]
    createMany?: DebtPaymentCreateManyDebtInputEnvelope
    set?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    disconnect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    delete?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    connect?: DebtPaymentWhereUniqueInput | DebtPaymentWhereUniqueInput[]
    update?: DebtPaymentUpdateWithWhereUniqueWithoutDebtInput | DebtPaymentUpdateWithWhereUniqueWithoutDebtInput[]
    updateMany?: DebtPaymentUpdateManyWithWhereWithoutDebtInput | DebtPaymentUpdateManyWithWhereWithoutDebtInput[]
    deleteMany?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
  }

  export type DebtCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<DebtCreateWithoutPaymentsInput, DebtUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutPaymentsInput
    connect?: DebtWhereUniqueInput
  }

  export type DebtUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<DebtCreateWithoutPaymentsInput, DebtUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: DebtCreateOrConnectWithoutPaymentsInput
    upsert?: DebtUpsertWithoutPaymentsInput
    connect?: DebtWhereUniqueInput
    update?: XOR<XOR<DebtUpdateToOneWithWhereWithoutPaymentsInput, DebtUpdateWithoutPaymentsInput>, DebtUncheckedUpdateWithoutPaymentsInput>
  }

  export type HouseholdCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<HouseholdCreateWithoutBudgetsInput, HouseholdUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutBudgetsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type BudgetCategoryCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput> | BudgetCategoryCreateWithoutBudgetInput[] | BudgetCategoryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutBudgetInput | BudgetCategoryCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetCategoryCreateManyBudgetInputEnvelope
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
  }

  export type BudgetCategoryUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput> | BudgetCategoryCreateWithoutBudgetInput[] | BudgetCategoryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutBudgetInput | BudgetCategoryCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetCategoryCreateManyBudgetInputEnvelope
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
  }

  export type EnumBudgetPeriodFieldUpdateOperationsInput = {
    set?: $Enums.BudgetPeriod
  }

  export type HouseholdUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<HouseholdCreateWithoutBudgetsInput, HouseholdUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutBudgetsInput
    upsert?: HouseholdUpsertWithoutBudgetsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutBudgetsInput, HouseholdUpdateWithoutBudgetsInput>, HouseholdUncheckedUpdateWithoutBudgetsInput>
  }

  export type BudgetCategoryUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput> | BudgetCategoryCreateWithoutBudgetInput[] | BudgetCategoryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutBudgetInput | BudgetCategoryCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput | BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetCategoryCreateManyBudgetInputEnvelope
    set?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    disconnect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    delete?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    update?: BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput | BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetCategoryUpdateManyWithWhereWithoutBudgetInput | BudgetCategoryUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
  }

  export type BudgetCategoryUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput> | BudgetCategoryCreateWithoutBudgetInput[] | BudgetCategoryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutBudgetInput | BudgetCategoryCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput | BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetCategoryCreateManyBudgetInputEnvelope
    set?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    disconnect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    delete?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    update?: BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput | BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetCategoryUpdateManyWithWhereWithoutBudgetInput | BudgetCategoryUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
  }

  export type BudgetCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<BudgetCreateWithoutCategoriesInput, BudgetUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutCategoriesInput
    connect?: BudgetWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutBudgetCategoriesInput = {
    create?: XOR<CategoryCreateWithoutBudgetCategoriesInput, CategoryUncheckedCreateWithoutBudgetCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBudgetCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type BudgetUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<BudgetCreateWithoutCategoriesInput, BudgetUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutCategoriesInput
    upsert?: BudgetUpsertWithoutCategoriesInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutCategoriesInput, BudgetUpdateWithoutCategoriesInput>, BudgetUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutBudgetCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutBudgetCategoriesInput, CategoryUncheckedCreateWithoutBudgetCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBudgetCategoriesInput
    upsert?: CategoryUpsertWithoutBudgetCategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutBudgetCategoriesInput, CategoryUpdateWithoutBudgetCategoriesInput>, CategoryUncheckedUpdateWithoutBudgetCategoriesInput>
  }

  export type HouseholdCreateNestedOneWithoutWishlistItemsInput = {
    create?: XOR<HouseholdCreateWithoutWishlistItemsInput, HouseholdUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutWishlistItemsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedWishlistItemsInput = {
    create?: XOR<UserCreateWithoutCreatedWishlistItemsInput, UserUncheckedCreateWithoutCreatedWishlistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWishlistItemsInput
    connect?: UserWhereUniqueInput
  }

  export type PriceHistoryCreateNestedManyWithoutWishlistItemInput = {
    create?: XOR<PriceHistoryCreateWithoutWishlistItemInput, PriceHistoryUncheckedCreateWithoutWishlistItemInput> | PriceHistoryCreateWithoutWishlistItemInput[] | PriceHistoryUncheckedCreateWithoutWishlistItemInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutWishlistItemInput | PriceHistoryCreateOrConnectWithoutWishlistItemInput[]
    createMany?: PriceHistoryCreateManyWishlistItemInputEnvelope
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type PriceHistoryUncheckedCreateNestedManyWithoutWishlistItemInput = {
    create?: XOR<PriceHistoryCreateWithoutWishlistItemInput, PriceHistoryUncheckedCreateWithoutWishlistItemInput> | PriceHistoryCreateWithoutWishlistItemInput[] | PriceHistoryUncheckedCreateWithoutWishlistItemInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutWishlistItemInput | PriceHistoryCreateOrConnectWithoutWishlistItemInput[]
    createMany?: PriceHistoryCreateManyWishlistItemInputEnvelope
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type HouseholdUpdateOneRequiredWithoutWishlistItemsNestedInput = {
    create?: XOR<HouseholdCreateWithoutWishlistItemsInput, HouseholdUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutWishlistItemsInput
    upsert?: HouseholdUpsertWithoutWishlistItemsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutWishlistItemsInput, HouseholdUpdateWithoutWishlistItemsInput>, HouseholdUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedWishlistItemsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedWishlistItemsInput, UserUncheckedCreateWithoutCreatedWishlistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWishlistItemsInput
    upsert?: UserUpsertWithoutCreatedWishlistItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedWishlistItemsInput, UserUpdateWithoutCreatedWishlistItemsInput>, UserUncheckedUpdateWithoutCreatedWishlistItemsInput>
  }

  export type PriceHistoryUpdateManyWithoutWishlistItemNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutWishlistItemInput, PriceHistoryUncheckedCreateWithoutWishlistItemInput> | PriceHistoryCreateWithoutWishlistItemInput[] | PriceHistoryUncheckedCreateWithoutWishlistItemInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutWishlistItemInput | PriceHistoryCreateOrConnectWithoutWishlistItemInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutWishlistItemInput | PriceHistoryUpsertWithWhereUniqueWithoutWishlistItemInput[]
    createMany?: PriceHistoryCreateManyWishlistItemInputEnvelope
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutWishlistItemInput | PriceHistoryUpdateWithWhereUniqueWithoutWishlistItemInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutWishlistItemInput | PriceHistoryUpdateManyWithWhereWithoutWishlistItemInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type PriceHistoryUncheckedUpdateManyWithoutWishlistItemNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutWishlistItemInput, PriceHistoryUncheckedCreateWithoutWishlistItemInput> | PriceHistoryCreateWithoutWishlistItemInput[] | PriceHistoryUncheckedCreateWithoutWishlistItemInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutWishlistItemInput | PriceHistoryCreateOrConnectWithoutWishlistItemInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutWishlistItemInput | PriceHistoryUpsertWithWhereUniqueWithoutWishlistItemInput[]
    createMany?: PriceHistoryCreateManyWishlistItemInputEnvelope
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutWishlistItemInput | PriceHistoryUpdateWithWhereUniqueWithoutWishlistItemInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutWishlistItemInput | PriceHistoryUpdateManyWithWhereWithoutWishlistItemInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type WishlistItemCreateNestedOneWithoutPriceHistoryInput = {
    create?: XOR<WishlistItemCreateWithoutPriceHistoryInput, WishlistItemUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: WishlistItemCreateOrConnectWithoutPriceHistoryInput
    connect?: WishlistItemWhereUniqueInput
  }

  export type WishlistItemUpdateOneRequiredWithoutPriceHistoryNestedInput = {
    create?: XOR<WishlistItemCreateWithoutPriceHistoryInput, WishlistItemUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: WishlistItemCreateOrConnectWithoutPriceHistoryInput
    upsert?: WishlistItemUpsertWithoutPriceHistoryInput
    connect?: WishlistItemWhereUniqueInput
    update?: XOR<XOR<WishlistItemUpdateToOneWithWhereWithoutPriceHistoryInput, WishlistItemUpdateWithoutPriceHistoryInput>, WishlistItemUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type HouseholdCreateNestedOneWithoutGratitudeEntriesInput = {
    create?: XOR<HouseholdCreateWithoutGratitudeEntriesInput, HouseholdUncheckedCreateWithoutGratitudeEntriesInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutGratitudeEntriesInput
    connect?: HouseholdWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutGratitudeEntriesInput = {
    create?: XOR<CategoryCreateWithoutGratitudeEntriesInput, CategoryUncheckedCreateWithoutGratitudeEntriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutGratitudeEntriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutGratitudeEntriesInput = {
    create?: XOR<TransactionCreateWithoutGratitudeEntriesInput, TransactionUncheckedCreateWithoutGratitudeEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutGratitudeEntriesInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedGratitudeEntriesInput = {
    create?: XOR<UserCreateWithoutCreatedGratitudeEntriesInput, UserUncheckedCreateWithoutCreatedGratitudeEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGratitudeEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGratitudeTypeFieldUpdateOperationsInput = {
    set?: $Enums.GratitudeType
  }

  export type HouseholdUpdateOneRequiredWithoutGratitudeEntriesNestedInput = {
    create?: XOR<HouseholdCreateWithoutGratitudeEntriesInput, HouseholdUncheckedCreateWithoutGratitudeEntriesInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutGratitudeEntriesInput
    upsert?: HouseholdUpsertWithoutGratitudeEntriesInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutGratitudeEntriesInput, HouseholdUpdateWithoutGratitudeEntriesInput>, HouseholdUncheckedUpdateWithoutGratitudeEntriesInput>
  }

  export type CategoryUpdateOneWithoutGratitudeEntriesNestedInput = {
    create?: XOR<CategoryCreateWithoutGratitudeEntriesInput, CategoryUncheckedCreateWithoutGratitudeEntriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutGratitudeEntriesInput
    upsert?: CategoryUpsertWithoutGratitudeEntriesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutGratitudeEntriesInput, CategoryUpdateWithoutGratitudeEntriesInput>, CategoryUncheckedUpdateWithoutGratitudeEntriesInput>
  }

  export type TransactionUpdateOneWithoutGratitudeEntriesNestedInput = {
    create?: XOR<TransactionCreateWithoutGratitudeEntriesInput, TransactionUncheckedCreateWithoutGratitudeEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutGratitudeEntriesInput
    upsert?: TransactionUpsertWithoutGratitudeEntriesInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutGratitudeEntriesInput, TransactionUpdateWithoutGratitudeEntriesInput>, TransactionUncheckedUpdateWithoutGratitudeEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedGratitudeEntriesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGratitudeEntriesInput, UserUncheckedCreateWithoutCreatedGratitudeEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGratitudeEntriesInput
    upsert?: UserUpsertWithoutCreatedGratitudeEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedGratitudeEntriesInput, UserUpdateWithoutCreatedGratitudeEntriesInput>, UserUncheckedUpdateWithoutCreatedGratitudeEntriesInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PasskeyCreatetransportsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutPasskeysInput = {
    create?: XOR<UserCreateWithoutPasskeysInput, UserUncheckedCreateWithoutPasskeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasskeysInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PasskeyUpdatetransportsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutPasskeysNestedInput = {
    create?: XOR<UserCreateWithoutPasskeysInput, UserUncheckedCreateWithoutPasskeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasskeysInput
    upsert?: UserUpsertWithoutPasskeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasskeysInput, UserUpdateWithoutPasskeysInput>, UserUncheckedUpdateWithoutPasskeysInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutUserEventsInput = {
    create?: XOR<UserCreateWithoutUserEventsInput, UserUncheckedCreateWithoutUserEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserEventsInput
    connect?: UserWhereUniqueInput
  }

  export type HouseholdCreateNestedOneWithoutUserEventsInput = {
    create?: XOR<HouseholdCreateWithoutUserEventsInput, HouseholdUncheckedCreateWithoutUserEventsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutUserEventsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserEventsNestedInput = {
    create?: XOR<UserCreateWithoutUserEventsInput, UserUncheckedCreateWithoutUserEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserEventsInput
    upsert?: UserUpsertWithoutUserEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserEventsInput, UserUpdateWithoutUserEventsInput>, UserUncheckedUpdateWithoutUserEventsInput>
  }

  export type HouseholdUpdateOneRequiredWithoutUserEventsNestedInput = {
    create?: XOR<HouseholdCreateWithoutUserEventsInput, HouseholdUncheckedCreateWithoutUserEventsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutUserEventsInput
    upsert?: HouseholdUpsertWithoutUserEventsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutUserEventsInput, HouseholdUpdateWithoutUserEventsInput>, HouseholdUncheckedUpdateWithoutUserEventsInput>
  }

  export type HouseholdCreateNestedOneWithoutSpendingPatternsInput = {
    create?: XOR<HouseholdCreateWithoutSpendingPatternsInput, HouseholdUncheckedCreateWithoutSpendingPatternsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutSpendingPatternsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type HouseholdUpdateOneRequiredWithoutSpendingPatternsNestedInput = {
    create?: XOR<HouseholdCreateWithoutSpendingPatternsInput, HouseholdUncheckedCreateWithoutSpendingPatternsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutSpendingPatternsInput
    upsert?: HouseholdUpsertWithoutSpendingPatternsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutSpendingPatternsInput, HouseholdUpdateWithoutSpendingPatternsInput>, HouseholdUncheckedUpdateWithoutSpendingPatternsInput>
  }

  export type HouseholdCreateNestedOneWithoutFinancialInsightsInput = {
    create?: XOR<HouseholdCreateWithoutFinancialInsightsInput, HouseholdUncheckedCreateWithoutFinancialInsightsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutFinancialInsightsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type EnumInsightPriorityFieldUpdateOperationsInput = {
    set?: $Enums.InsightPriority
  }

  export type HouseholdUpdateOneRequiredWithoutFinancialInsightsNestedInput = {
    create?: XOR<HouseholdCreateWithoutFinancialInsightsInput, HouseholdUncheckedCreateWithoutFinancialInsightsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutFinancialInsightsInput
    upsert?: HouseholdUpsertWithoutFinancialInsightsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutFinancialInsightsInput, HouseholdUpdateWithoutFinancialInsightsInput>, HouseholdUncheckedUpdateWithoutFinancialInsightsInput>
  }

  export type HouseholdCreateNestedOneWithoutRecurringTransactionsInput = {
    create?: XOR<HouseholdCreateWithoutRecurringTransactionsInput, HouseholdUncheckedCreateWithoutRecurringTransactionsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutRecurringTransactionsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutRecurringTransactionsInput = {
    create?: XOR<AccountCreateWithoutRecurringTransactionsInput, AccountUncheckedCreateWithoutRecurringTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRecurringTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutRecurringTransferTransactionsInput = {
    create?: XOR<AccountCreateWithoutRecurringTransferTransactionsInput, AccountUncheckedCreateWithoutRecurringTransferTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRecurringTransferTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutRecurringTransactionsInput = {
    create?: XOR<CategoryCreateWithoutRecurringTransactionsInput, CategoryUncheckedCreateWithoutRecurringTransactionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutRecurringTransactionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedRecurringTransactionsInput = {
    create?: XOR<UserCreateWithoutCreatedRecurringTransactionsInput, UserUncheckedCreateWithoutCreatedRecurringTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRecurringTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type RecurringTransactionExecutionCreateNestedManyWithoutRecurringTransactionInput = {
    create?: XOR<RecurringTransactionExecutionCreateWithoutRecurringTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput> | RecurringTransactionExecutionCreateWithoutRecurringTransactionInput[] | RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput[]
    connectOrCreate?: RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput | RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput[]
    createMany?: RecurringTransactionExecutionCreateManyRecurringTransactionInputEnvelope
    connect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
  }

  export type RecurringTransactionExecutionUncheckedCreateNestedManyWithoutRecurringTransactionInput = {
    create?: XOR<RecurringTransactionExecutionCreateWithoutRecurringTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput> | RecurringTransactionExecutionCreateWithoutRecurringTransactionInput[] | RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput[]
    connectOrCreate?: RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput | RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput[]
    createMany?: RecurringTransactionExecutionCreateManyRecurringTransactionInputEnvelope
    connect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
  }

  export type EnumRecurrenceFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.RecurrenceFrequency
  }

  export type EnumRecurringTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecurringTransactionStatus
  }

  export type HouseholdUpdateOneRequiredWithoutRecurringTransactionsNestedInput = {
    create?: XOR<HouseholdCreateWithoutRecurringTransactionsInput, HouseholdUncheckedCreateWithoutRecurringTransactionsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutRecurringTransactionsInput
    upsert?: HouseholdUpsertWithoutRecurringTransactionsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutRecurringTransactionsInput, HouseholdUpdateWithoutRecurringTransactionsInput>, HouseholdUncheckedUpdateWithoutRecurringTransactionsInput>
  }

  export type AccountUpdateOneRequiredWithoutRecurringTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutRecurringTransactionsInput, AccountUncheckedCreateWithoutRecurringTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRecurringTransactionsInput
    upsert?: AccountUpsertWithoutRecurringTransactionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutRecurringTransactionsInput, AccountUpdateWithoutRecurringTransactionsInput>, AccountUncheckedUpdateWithoutRecurringTransactionsInput>
  }

  export type AccountUpdateOneWithoutRecurringTransferTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutRecurringTransferTransactionsInput, AccountUncheckedCreateWithoutRecurringTransferTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRecurringTransferTransactionsInput
    upsert?: AccountUpsertWithoutRecurringTransferTransactionsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutRecurringTransferTransactionsInput, AccountUpdateWithoutRecurringTransferTransactionsInput>, AccountUncheckedUpdateWithoutRecurringTransferTransactionsInput>
  }

  export type CategoryUpdateOneWithoutRecurringTransactionsNestedInput = {
    create?: XOR<CategoryCreateWithoutRecurringTransactionsInput, CategoryUncheckedCreateWithoutRecurringTransactionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutRecurringTransactionsInput
    upsert?: CategoryUpsertWithoutRecurringTransactionsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutRecurringTransactionsInput, CategoryUpdateWithoutRecurringTransactionsInput>, CategoryUncheckedUpdateWithoutRecurringTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedRecurringTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRecurringTransactionsInput, UserUncheckedCreateWithoutCreatedRecurringTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRecurringTransactionsInput
    upsert?: UserUpsertWithoutCreatedRecurringTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRecurringTransactionsInput, UserUpdateWithoutCreatedRecurringTransactionsInput>, UserUncheckedUpdateWithoutCreatedRecurringTransactionsInput>
  }

  export type RecurringTransactionExecutionUpdateManyWithoutRecurringTransactionNestedInput = {
    create?: XOR<RecurringTransactionExecutionCreateWithoutRecurringTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput> | RecurringTransactionExecutionCreateWithoutRecurringTransactionInput[] | RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput[]
    connectOrCreate?: RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput | RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput[]
    upsert?: RecurringTransactionExecutionUpsertWithWhereUniqueWithoutRecurringTransactionInput | RecurringTransactionExecutionUpsertWithWhereUniqueWithoutRecurringTransactionInput[]
    createMany?: RecurringTransactionExecutionCreateManyRecurringTransactionInputEnvelope
    set?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    disconnect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    delete?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    connect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    update?: RecurringTransactionExecutionUpdateWithWhereUniqueWithoutRecurringTransactionInput | RecurringTransactionExecutionUpdateWithWhereUniqueWithoutRecurringTransactionInput[]
    updateMany?: RecurringTransactionExecutionUpdateManyWithWhereWithoutRecurringTransactionInput | RecurringTransactionExecutionUpdateManyWithWhereWithoutRecurringTransactionInput[]
    deleteMany?: RecurringTransactionExecutionScalarWhereInput | RecurringTransactionExecutionScalarWhereInput[]
  }

  export type RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionNestedInput = {
    create?: XOR<RecurringTransactionExecutionCreateWithoutRecurringTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput> | RecurringTransactionExecutionCreateWithoutRecurringTransactionInput[] | RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput[]
    connectOrCreate?: RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput | RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput[]
    upsert?: RecurringTransactionExecutionUpsertWithWhereUniqueWithoutRecurringTransactionInput | RecurringTransactionExecutionUpsertWithWhereUniqueWithoutRecurringTransactionInput[]
    createMany?: RecurringTransactionExecutionCreateManyRecurringTransactionInputEnvelope
    set?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    disconnect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    delete?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    connect?: RecurringTransactionExecutionWhereUniqueInput | RecurringTransactionExecutionWhereUniqueInput[]
    update?: RecurringTransactionExecutionUpdateWithWhereUniqueWithoutRecurringTransactionInput | RecurringTransactionExecutionUpdateWithWhereUniqueWithoutRecurringTransactionInput[]
    updateMany?: RecurringTransactionExecutionUpdateManyWithWhereWithoutRecurringTransactionInput | RecurringTransactionExecutionUpdateManyWithWhereWithoutRecurringTransactionInput[]
    deleteMany?: RecurringTransactionExecutionScalarWhereInput | RecurringTransactionExecutionScalarWhereInput[]
  }

  export type RecurringTransactionCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<RecurringTransactionCreateWithoutExecutionsInput, RecurringTransactionUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutExecutionsInput
    connect?: RecurringTransactionWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutRecurringTransactionExecutionsInput = {
    create?: XOR<TransactionCreateWithoutRecurringTransactionExecutionsInput, TransactionUncheckedCreateWithoutRecurringTransactionExecutionsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutRecurringTransactionExecutionsInput
    connect?: TransactionWhereUniqueInput
  }

  export type RecurringTransactionUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<RecurringTransactionCreateWithoutExecutionsInput, RecurringTransactionUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: RecurringTransactionCreateOrConnectWithoutExecutionsInput
    upsert?: RecurringTransactionUpsertWithoutExecutionsInput
    connect?: RecurringTransactionWhereUniqueInput
    update?: XOR<XOR<RecurringTransactionUpdateToOneWithWhereWithoutExecutionsInput, RecurringTransactionUpdateWithoutExecutionsInput>, RecurringTransactionUncheckedUpdateWithoutExecutionsInput>
  }

  export type TransactionUpdateOneWithoutRecurringTransactionExecutionsNestedInput = {
    create?: XOR<TransactionCreateWithoutRecurringTransactionExecutionsInput, TransactionUncheckedCreateWithoutRecurringTransactionExecutionsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutRecurringTransactionExecutionsInput
    upsert?: TransactionUpsertWithoutRecurringTransactionExecutionsInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutRecurringTransactionExecutionsInput, TransactionUpdateWithoutRecurringTransactionExecutionsInput>, TransactionUncheckedUpdateWithoutRecurringTransactionExecutionsInput>
  }

  export type HouseholdCreateNestedOneWithoutDocumentUploadsInput = {
    create?: XOR<HouseholdCreateWithoutDocumentUploadsInput, HouseholdUncheckedCreateWithoutDocumentUploadsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutDocumentUploadsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type OcrResultCreateNestedManyWithoutDocumentInput = {
    create?: XOR<OcrResultCreateWithoutDocumentInput, OcrResultUncheckedCreateWithoutDocumentInput> | OcrResultCreateWithoutDocumentInput[] | OcrResultUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: OcrResultCreateOrConnectWithoutDocumentInput | OcrResultCreateOrConnectWithoutDocumentInput[]
    createMany?: OcrResultCreateManyDocumentInputEnvelope
    connect?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
  }

  export type TransactionSuggestionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<TransactionSuggestionCreateWithoutDocumentInput, TransactionSuggestionUncheckedCreateWithoutDocumentInput> | TransactionSuggestionCreateWithoutDocumentInput[] | TransactionSuggestionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutDocumentInput | TransactionSuggestionCreateOrConnectWithoutDocumentInput[]
    createMany?: TransactionSuggestionCreateManyDocumentInputEnvelope
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
  }

  export type OcrResultUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<OcrResultCreateWithoutDocumentInput, OcrResultUncheckedCreateWithoutDocumentInput> | OcrResultCreateWithoutDocumentInput[] | OcrResultUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: OcrResultCreateOrConnectWithoutDocumentInput | OcrResultCreateOrConnectWithoutDocumentInput[]
    createMany?: OcrResultCreateManyDocumentInputEnvelope
    connect?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
  }

  export type TransactionSuggestionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<TransactionSuggestionCreateWithoutDocumentInput, TransactionSuggestionUncheckedCreateWithoutDocumentInput> | TransactionSuggestionCreateWithoutDocumentInput[] | TransactionSuggestionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutDocumentInput | TransactionSuggestionCreateOrConnectWithoutDocumentInput[]
    createMany?: TransactionSuggestionCreateManyDocumentInputEnvelope
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumProcessingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessingStatus
  }

  export type HouseholdUpdateOneRequiredWithoutDocumentUploadsNestedInput = {
    create?: XOR<HouseholdCreateWithoutDocumentUploadsInput, HouseholdUncheckedCreateWithoutDocumentUploadsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutDocumentUploadsInput
    upsert?: HouseholdUpsertWithoutDocumentUploadsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutDocumentUploadsInput, HouseholdUpdateWithoutDocumentUploadsInput>, HouseholdUncheckedUpdateWithoutDocumentUploadsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    upsert?: UserUpsertWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDocumentsInput, UserUpdateWithoutUploadedDocumentsInput>, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type OcrResultUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<OcrResultCreateWithoutDocumentInput, OcrResultUncheckedCreateWithoutDocumentInput> | OcrResultCreateWithoutDocumentInput[] | OcrResultUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: OcrResultCreateOrConnectWithoutDocumentInput | OcrResultCreateOrConnectWithoutDocumentInput[]
    upsert?: OcrResultUpsertWithWhereUniqueWithoutDocumentInput | OcrResultUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: OcrResultCreateManyDocumentInputEnvelope
    set?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
    disconnect?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
    delete?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
    connect?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
    update?: OcrResultUpdateWithWhereUniqueWithoutDocumentInput | OcrResultUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: OcrResultUpdateManyWithWhereWithoutDocumentInput | OcrResultUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: OcrResultScalarWhereInput | OcrResultScalarWhereInput[]
  }

  export type TransactionSuggestionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<TransactionSuggestionCreateWithoutDocumentInput, TransactionSuggestionUncheckedCreateWithoutDocumentInput> | TransactionSuggestionCreateWithoutDocumentInput[] | TransactionSuggestionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutDocumentInput | TransactionSuggestionCreateOrConnectWithoutDocumentInput[]
    upsert?: TransactionSuggestionUpsertWithWhereUniqueWithoutDocumentInput | TransactionSuggestionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: TransactionSuggestionCreateManyDocumentInputEnvelope
    set?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    disconnect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    delete?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    update?: TransactionSuggestionUpdateWithWhereUniqueWithoutDocumentInput | TransactionSuggestionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: TransactionSuggestionUpdateManyWithWhereWithoutDocumentInput | TransactionSuggestionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
  }

  export type OcrResultUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<OcrResultCreateWithoutDocumentInput, OcrResultUncheckedCreateWithoutDocumentInput> | OcrResultCreateWithoutDocumentInput[] | OcrResultUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: OcrResultCreateOrConnectWithoutDocumentInput | OcrResultCreateOrConnectWithoutDocumentInput[]
    upsert?: OcrResultUpsertWithWhereUniqueWithoutDocumentInput | OcrResultUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: OcrResultCreateManyDocumentInputEnvelope
    set?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
    disconnect?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
    delete?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
    connect?: OcrResultWhereUniqueInput | OcrResultWhereUniqueInput[]
    update?: OcrResultUpdateWithWhereUniqueWithoutDocumentInput | OcrResultUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: OcrResultUpdateManyWithWhereWithoutDocumentInput | OcrResultUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: OcrResultScalarWhereInput | OcrResultScalarWhereInput[]
  }

  export type TransactionSuggestionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<TransactionSuggestionCreateWithoutDocumentInput, TransactionSuggestionUncheckedCreateWithoutDocumentInput> | TransactionSuggestionCreateWithoutDocumentInput[] | TransactionSuggestionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutDocumentInput | TransactionSuggestionCreateOrConnectWithoutDocumentInput[]
    upsert?: TransactionSuggestionUpsertWithWhereUniqueWithoutDocumentInput | TransactionSuggestionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: TransactionSuggestionCreateManyDocumentInputEnvelope
    set?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    disconnect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    delete?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    update?: TransactionSuggestionUpdateWithWhereUniqueWithoutDocumentInput | TransactionSuggestionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: TransactionSuggestionUpdateManyWithWhereWithoutDocumentInput | TransactionSuggestionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
  }

  export type DocumentUploadCreateNestedOneWithoutOcrResultsInput = {
    create?: XOR<DocumentUploadCreateWithoutOcrResultsInput, DocumentUploadUncheckedCreateWithoutOcrResultsInput>
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutOcrResultsInput
    connect?: DocumentUploadWhereUniqueInput
  }

  export type TransactionSuggestionCreateNestedManyWithoutOcrResultInput = {
    create?: XOR<TransactionSuggestionCreateWithoutOcrResultInput, TransactionSuggestionUncheckedCreateWithoutOcrResultInput> | TransactionSuggestionCreateWithoutOcrResultInput[] | TransactionSuggestionUncheckedCreateWithoutOcrResultInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutOcrResultInput | TransactionSuggestionCreateOrConnectWithoutOcrResultInput[]
    createMany?: TransactionSuggestionCreateManyOcrResultInputEnvelope
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
  }

  export type TransactionSuggestionUncheckedCreateNestedManyWithoutOcrResultInput = {
    create?: XOR<TransactionSuggestionCreateWithoutOcrResultInput, TransactionSuggestionUncheckedCreateWithoutOcrResultInput> | TransactionSuggestionCreateWithoutOcrResultInput[] | TransactionSuggestionUncheckedCreateWithoutOcrResultInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutOcrResultInput | TransactionSuggestionCreateOrConnectWithoutOcrResultInput[]
    createMany?: TransactionSuggestionCreateManyOcrResultInputEnvelope
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
  }

  export type DocumentUploadUpdateOneRequiredWithoutOcrResultsNestedInput = {
    create?: XOR<DocumentUploadCreateWithoutOcrResultsInput, DocumentUploadUncheckedCreateWithoutOcrResultsInput>
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutOcrResultsInput
    upsert?: DocumentUploadUpsertWithoutOcrResultsInput
    connect?: DocumentUploadWhereUniqueInput
    update?: XOR<XOR<DocumentUploadUpdateToOneWithWhereWithoutOcrResultsInput, DocumentUploadUpdateWithoutOcrResultsInput>, DocumentUploadUncheckedUpdateWithoutOcrResultsInput>
  }

  export type TransactionSuggestionUpdateManyWithoutOcrResultNestedInput = {
    create?: XOR<TransactionSuggestionCreateWithoutOcrResultInput, TransactionSuggestionUncheckedCreateWithoutOcrResultInput> | TransactionSuggestionCreateWithoutOcrResultInput[] | TransactionSuggestionUncheckedCreateWithoutOcrResultInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutOcrResultInput | TransactionSuggestionCreateOrConnectWithoutOcrResultInput[]
    upsert?: TransactionSuggestionUpsertWithWhereUniqueWithoutOcrResultInput | TransactionSuggestionUpsertWithWhereUniqueWithoutOcrResultInput[]
    createMany?: TransactionSuggestionCreateManyOcrResultInputEnvelope
    set?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    disconnect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    delete?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    update?: TransactionSuggestionUpdateWithWhereUniqueWithoutOcrResultInput | TransactionSuggestionUpdateWithWhereUniqueWithoutOcrResultInput[]
    updateMany?: TransactionSuggestionUpdateManyWithWhereWithoutOcrResultInput | TransactionSuggestionUpdateManyWithWhereWithoutOcrResultInput[]
    deleteMany?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
  }

  export type TransactionSuggestionUncheckedUpdateManyWithoutOcrResultNestedInput = {
    create?: XOR<TransactionSuggestionCreateWithoutOcrResultInput, TransactionSuggestionUncheckedCreateWithoutOcrResultInput> | TransactionSuggestionCreateWithoutOcrResultInput[] | TransactionSuggestionUncheckedCreateWithoutOcrResultInput[]
    connectOrCreate?: TransactionSuggestionCreateOrConnectWithoutOcrResultInput | TransactionSuggestionCreateOrConnectWithoutOcrResultInput[]
    upsert?: TransactionSuggestionUpsertWithWhereUniqueWithoutOcrResultInput | TransactionSuggestionUpsertWithWhereUniqueWithoutOcrResultInput[]
    createMany?: TransactionSuggestionCreateManyOcrResultInputEnvelope
    set?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    disconnect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    delete?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    connect?: TransactionSuggestionWhereUniqueInput | TransactionSuggestionWhereUniqueInput[]
    update?: TransactionSuggestionUpdateWithWhereUniqueWithoutOcrResultInput | TransactionSuggestionUpdateWithWhereUniqueWithoutOcrResultInput[]
    updateMany?: TransactionSuggestionUpdateManyWithWhereWithoutOcrResultInput | TransactionSuggestionUpdateManyWithWhereWithoutOcrResultInput[]
    deleteMany?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
  }

  export type DocumentUploadCreateNestedOneWithoutTransactionSuggestionsInput = {
    create?: XOR<DocumentUploadCreateWithoutTransactionSuggestionsInput, DocumentUploadUncheckedCreateWithoutTransactionSuggestionsInput>
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutTransactionSuggestionsInput
    connect?: DocumentUploadWhereUniqueInput
  }

  export type OcrResultCreateNestedOneWithoutTransactionSuggestionsInput = {
    create?: XOR<OcrResultCreateWithoutTransactionSuggestionsInput, OcrResultUncheckedCreateWithoutTransactionSuggestionsInput>
    connectOrCreate?: OcrResultCreateOrConnectWithoutTransactionSuggestionsInput
    connect?: OcrResultWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutTransactionSuggestionsInput = {
    create?: XOR<CategoryCreateWithoutTransactionSuggestionsInput, CategoryUncheckedCreateWithoutTransactionSuggestionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionSuggestionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutCreatedFromSuggestionInput = {
    create?: XOR<TransactionCreateWithoutCreatedFromSuggestionInput, TransactionUncheckedCreateWithoutCreatedFromSuggestionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatedFromSuggestionInput
    connect?: TransactionWhereUniqueInput
  }

  export type DocumentUploadUpdateOneRequiredWithoutTransactionSuggestionsNestedInput = {
    create?: XOR<DocumentUploadCreateWithoutTransactionSuggestionsInput, DocumentUploadUncheckedCreateWithoutTransactionSuggestionsInput>
    connectOrCreate?: DocumentUploadCreateOrConnectWithoutTransactionSuggestionsInput
    upsert?: DocumentUploadUpsertWithoutTransactionSuggestionsInput
    connect?: DocumentUploadWhereUniqueInput
    update?: XOR<XOR<DocumentUploadUpdateToOneWithWhereWithoutTransactionSuggestionsInput, DocumentUploadUpdateWithoutTransactionSuggestionsInput>, DocumentUploadUncheckedUpdateWithoutTransactionSuggestionsInput>
  }

  export type OcrResultUpdateOneWithoutTransactionSuggestionsNestedInput = {
    create?: XOR<OcrResultCreateWithoutTransactionSuggestionsInput, OcrResultUncheckedCreateWithoutTransactionSuggestionsInput>
    connectOrCreate?: OcrResultCreateOrConnectWithoutTransactionSuggestionsInput
    upsert?: OcrResultUpsertWithoutTransactionSuggestionsInput
    disconnect?: OcrResultWhereInput | boolean
    delete?: OcrResultWhereInput | boolean
    connect?: OcrResultWhereUniqueInput
    update?: XOR<XOR<OcrResultUpdateToOneWithWhereWithoutTransactionSuggestionsInput, OcrResultUpdateWithoutTransactionSuggestionsInput>, OcrResultUncheckedUpdateWithoutTransactionSuggestionsInput>
  }

  export type CategoryUpdateOneWithoutTransactionSuggestionsNestedInput = {
    create?: XOR<CategoryCreateWithoutTransactionSuggestionsInput, CategoryUncheckedCreateWithoutTransactionSuggestionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionSuggestionsInput
    upsert?: CategoryUpsertWithoutTransactionSuggestionsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTransactionSuggestionsInput, CategoryUpdateWithoutTransactionSuggestionsInput>, CategoryUncheckedUpdateWithoutTransactionSuggestionsInput>
  }

  export type TransactionUpdateOneWithoutCreatedFromSuggestionNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatedFromSuggestionInput, TransactionUncheckedCreateWithoutCreatedFromSuggestionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatedFromSuggestionInput
    upsert?: TransactionUpsertWithoutCreatedFromSuggestionInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutCreatedFromSuggestionInput, TransactionUpdateWithoutCreatedFromSuggestionInput>, TransactionUncheckedUpdateWithoutCreatedFromSuggestionInput>
  }

  export type HouseholdCreateNestedOneWithoutZakatCalculationsInput = {
    create?: XOR<HouseholdCreateWithoutZakatCalculationsInput, HouseholdUncheckedCreateWithoutZakatCalculationsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutZakatCalculationsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type ZakatAssetBreakdownCreateNestedManyWithoutZakatCalculationInput = {
    create?: XOR<ZakatAssetBreakdownCreateWithoutZakatCalculationInput, ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput> | ZakatAssetBreakdownCreateWithoutZakatCalculationInput[] | ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput[]
    connectOrCreate?: ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput | ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput[]
    createMany?: ZakatAssetBreakdownCreateManyZakatCalculationInputEnvelope
    connect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
  }

  export type ZakatPaymentCreateNestedManyWithoutZakatCalculationInput = {
    create?: XOR<ZakatPaymentCreateWithoutZakatCalculationInput, ZakatPaymentUncheckedCreateWithoutZakatCalculationInput> | ZakatPaymentCreateWithoutZakatCalculationInput[] | ZakatPaymentUncheckedCreateWithoutZakatCalculationInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutZakatCalculationInput | ZakatPaymentCreateOrConnectWithoutZakatCalculationInput[]
    createMany?: ZakatPaymentCreateManyZakatCalculationInputEnvelope
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
  }

  export type ZakatAssetBreakdownUncheckedCreateNestedManyWithoutZakatCalculationInput = {
    create?: XOR<ZakatAssetBreakdownCreateWithoutZakatCalculationInput, ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput> | ZakatAssetBreakdownCreateWithoutZakatCalculationInput[] | ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput[]
    connectOrCreate?: ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput | ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput[]
    createMany?: ZakatAssetBreakdownCreateManyZakatCalculationInputEnvelope
    connect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
  }

  export type ZakatPaymentUncheckedCreateNestedManyWithoutZakatCalculationInput = {
    create?: XOR<ZakatPaymentCreateWithoutZakatCalculationInput, ZakatPaymentUncheckedCreateWithoutZakatCalculationInput> | ZakatPaymentCreateWithoutZakatCalculationInput[] | ZakatPaymentUncheckedCreateWithoutZakatCalculationInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutZakatCalculationInput | ZakatPaymentCreateOrConnectWithoutZakatCalculationInput[]
    createMany?: ZakatPaymentCreateManyZakatCalculationInputEnvelope
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
  }

  export type HouseholdUpdateOneRequiredWithoutZakatCalculationsNestedInput = {
    create?: XOR<HouseholdCreateWithoutZakatCalculationsInput, HouseholdUncheckedCreateWithoutZakatCalculationsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutZakatCalculationsInput
    upsert?: HouseholdUpsertWithoutZakatCalculationsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutZakatCalculationsInput, HouseholdUpdateWithoutZakatCalculationsInput>, HouseholdUncheckedUpdateWithoutZakatCalculationsInput>
  }

  export type ZakatAssetBreakdownUpdateManyWithoutZakatCalculationNestedInput = {
    create?: XOR<ZakatAssetBreakdownCreateWithoutZakatCalculationInput, ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput> | ZakatAssetBreakdownCreateWithoutZakatCalculationInput[] | ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput[]
    connectOrCreate?: ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput | ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput[]
    upsert?: ZakatAssetBreakdownUpsertWithWhereUniqueWithoutZakatCalculationInput | ZakatAssetBreakdownUpsertWithWhereUniqueWithoutZakatCalculationInput[]
    createMany?: ZakatAssetBreakdownCreateManyZakatCalculationInputEnvelope
    set?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    disconnect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    delete?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    connect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    update?: ZakatAssetBreakdownUpdateWithWhereUniqueWithoutZakatCalculationInput | ZakatAssetBreakdownUpdateWithWhereUniqueWithoutZakatCalculationInput[]
    updateMany?: ZakatAssetBreakdownUpdateManyWithWhereWithoutZakatCalculationInput | ZakatAssetBreakdownUpdateManyWithWhereWithoutZakatCalculationInput[]
    deleteMany?: ZakatAssetBreakdownScalarWhereInput | ZakatAssetBreakdownScalarWhereInput[]
  }

  export type ZakatPaymentUpdateManyWithoutZakatCalculationNestedInput = {
    create?: XOR<ZakatPaymentCreateWithoutZakatCalculationInput, ZakatPaymentUncheckedCreateWithoutZakatCalculationInput> | ZakatPaymentCreateWithoutZakatCalculationInput[] | ZakatPaymentUncheckedCreateWithoutZakatCalculationInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutZakatCalculationInput | ZakatPaymentCreateOrConnectWithoutZakatCalculationInput[]
    upsert?: ZakatPaymentUpsertWithWhereUniqueWithoutZakatCalculationInput | ZakatPaymentUpsertWithWhereUniqueWithoutZakatCalculationInput[]
    createMany?: ZakatPaymentCreateManyZakatCalculationInputEnvelope
    set?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    disconnect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    delete?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    update?: ZakatPaymentUpdateWithWhereUniqueWithoutZakatCalculationInput | ZakatPaymentUpdateWithWhereUniqueWithoutZakatCalculationInput[]
    updateMany?: ZakatPaymentUpdateManyWithWhereWithoutZakatCalculationInput | ZakatPaymentUpdateManyWithWhereWithoutZakatCalculationInput[]
    deleteMany?: ZakatPaymentScalarWhereInput | ZakatPaymentScalarWhereInput[]
  }

  export type ZakatAssetBreakdownUncheckedUpdateManyWithoutZakatCalculationNestedInput = {
    create?: XOR<ZakatAssetBreakdownCreateWithoutZakatCalculationInput, ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput> | ZakatAssetBreakdownCreateWithoutZakatCalculationInput[] | ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput[]
    connectOrCreate?: ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput | ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput[]
    upsert?: ZakatAssetBreakdownUpsertWithWhereUniqueWithoutZakatCalculationInput | ZakatAssetBreakdownUpsertWithWhereUniqueWithoutZakatCalculationInput[]
    createMany?: ZakatAssetBreakdownCreateManyZakatCalculationInputEnvelope
    set?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    disconnect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    delete?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    connect?: ZakatAssetBreakdownWhereUniqueInput | ZakatAssetBreakdownWhereUniqueInput[]
    update?: ZakatAssetBreakdownUpdateWithWhereUniqueWithoutZakatCalculationInput | ZakatAssetBreakdownUpdateWithWhereUniqueWithoutZakatCalculationInput[]
    updateMany?: ZakatAssetBreakdownUpdateManyWithWhereWithoutZakatCalculationInput | ZakatAssetBreakdownUpdateManyWithWhereWithoutZakatCalculationInput[]
    deleteMany?: ZakatAssetBreakdownScalarWhereInput | ZakatAssetBreakdownScalarWhereInput[]
  }

  export type ZakatPaymentUncheckedUpdateManyWithoutZakatCalculationNestedInput = {
    create?: XOR<ZakatPaymentCreateWithoutZakatCalculationInput, ZakatPaymentUncheckedCreateWithoutZakatCalculationInput> | ZakatPaymentCreateWithoutZakatCalculationInput[] | ZakatPaymentUncheckedCreateWithoutZakatCalculationInput[]
    connectOrCreate?: ZakatPaymentCreateOrConnectWithoutZakatCalculationInput | ZakatPaymentCreateOrConnectWithoutZakatCalculationInput[]
    upsert?: ZakatPaymentUpsertWithWhereUniqueWithoutZakatCalculationInput | ZakatPaymentUpsertWithWhereUniqueWithoutZakatCalculationInput[]
    createMany?: ZakatPaymentCreateManyZakatCalculationInputEnvelope
    set?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    disconnect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    delete?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    connect?: ZakatPaymentWhereUniqueInput | ZakatPaymentWhereUniqueInput[]
    update?: ZakatPaymentUpdateWithWhereUniqueWithoutZakatCalculationInput | ZakatPaymentUpdateWithWhereUniqueWithoutZakatCalculationInput[]
    updateMany?: ZakatPaymentUpdateManyWithWhereWithoutZakatCalculationInput | ZakatPaymentUpdateManyWithWhereWithoutZakatCalculationInput[]
    deleteMany?: ZakatPaymentScalarWhereInput | ZakatPaymentScalarWhereInput[]
  }

  export type ZakatCalculationCreateNestedOneWithoutAssetBreakdownInput = {
    create?: XOR<ZakatCalculationCreateWithoutAssetBreakdownInput, ZakatCalculationUncheckedCreateWithoutAssetBreakdownInput>
    connectOrCreate?: ZakatCalculationCreateOrConnectWithoutAssetBreakdownInput
    connect?: ZakatCalculationWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutZakatAssetBreakdownInput = {
    create?: XOR<AccountCreateWithoutZakatAssetBreakdownInput, AccountUncheckedCreateWithoutZakatAssetBreakdownInput>
    connectOrCreate?: AccountCreateOrConnectWithoutZakatAssetBreakdownInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumZakatAssetTypeFieldUpdateOperationsInput = {
    set?: $Enums.ZakatAssetType
  }

  export type ZakatCalculationUpdateOneRequiredWithoutAssetBreakdownNestedInput = {
    create?: XOR<ZakatCalculationCreateWithoutAssetBreakdownInput, ZakatCalculationUncheckedCreateWithoutAssetBreakdownInput>
    connectOrCreate?: ZakatCalculationCreateOrConnectWithoutAssetBreakdownInput
    upsert?: ZakatCalculationUpsertWithoutAssetBreakdownInput
    connect?: ZakatCalculationWhereUniqueInput
    update?: XOR<XOR<ZakatCalculationUpdateToOneWithWhereWithoutAssetBreakdownInput, ZakatCalculationUpdateWithoutAssetBreakdownInput>, ZakatCalculationUncheckedUpdateWithoutAssetBreakdownInput>
  }

  export type AccountUpdateOneWithoutZakatAssetBreakdownNestedInput = {
    create?: XOR<AccountCreateWithoutZakatAssetBreakdownInput, AccountUncheckedCreateWithoutZakatAssetBreakdownInput>
    connectOrCreate?: AccountCreateOrConnectWithoutZakatAssetBreakdownInput
    upsert?: AccountUpsertWithoutZakatAssetBreakdownInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutZakatAssetBreakdownInput, AccountUpdateWithoutZakatAssetBreakdownInput>, AccountUncheckedUpdateWithoutZakatAssetBreakdownInput>
  }

  export type HouseholdCreateNestedOneWithoutZakatRemindersInput = {
    create?: XOR<HouseholdCreateWithoutZakatRemindersInput, HouseholdUncheckedCreateWithoutZakatRemindersInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutZakatRemindersInput
    connect?: HouseholdWhereUniqueInput
  }

  export type EnumZakatReminderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ZakatReminderType
  }

  export type HouseholdUpdateOneRequiredWithoutZakatRemindersNestedInput = {
    create?: XOR<HouseholdCreateWithoutZakatRemindersInput, HouseholdUncheckedCreateWithoutZakatRemindersInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutZakatRemindersInput
    upsert?: HouseholdUpsertWithoutZakatRemindersInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutZakatRemindersInput, HouseholdUpdateWithoutZakatRemindersInput>, HouseholdUncheckedUpdateWithoutZakatRemindersInput>
  }

  export type ZakatCalculationCreateNestedOneWithoutZakatPaymentsInput = {
    create?: XOR<ZakatCalculationCreateWithoutZakatPaymentsInput, ZakatCalculationUncheckedCreateWithoutZakatPaymentsInput>
    connectOrCreate?: ZakatCalculationCreateOrConnectWithoutZakatPaymentsInput
    connect?: ZakatCalculationWhereUniqueInput
  }

  export type HouseholdCreateNestedOneWithoutZakatPaymentsInput = {
    create?: XOR<HouseholdCreateWithoutZakatPaymentsInput, HouseholdUncheckedCreateWithoutZakatPaymentsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutZakatPaymentsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutZakatPaymentsInput = {
    create?: XOR<TransactionCreateWithoutZakatPaymentsInput, TransactionUncheckedCreateWithoutZakatPaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutZakatPaymentsInput
    connect?: TransactionWhereUniqueInput
  }

  export type ZakatCalculationUpdateOneWithoutZakatPaymentsNestedInput = {
    create?: XOR<ZakatCalculationCreateWithoutZakatPaymentsInput, ZakatCalculationUncheckedCreateWithoutZakatPaymentsInput>
    connectOrCreate?: ZakatCalculationCreateOrConnectWithoutZakatPaymentsInput
    upsert?: ZakatCalculationUpsertWithoutZakatPaymentsInput
    disconnect?: ZakatCalculationWhereInput | boolean
    delete?: ZakatCalculationWhereInput | boolean
    connect?: ZakatCalculationWhereUniqueInput
    update?: XOR<XOR<ZakatCalculationUpdateToOneWithWhereWithoutZakatPaymentsInput, ZakatCalculationUpdateWithoutZakatPaymentsInput>, ZakatCalculationUncheckedUpdateWithoutZakatPaymentsInput>
  }

  export type HouseholdUpdateOneRequiredWithoutZakatPaymentsNestedInput = {
    create?: XOR<HouseholdCreateWithoutZakatPaymentsInput, HouseholdUncheckedCreateWithoutZakatPaymentsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutZakatPaymentsInput
    upsert?: HouseholdUpsertWithoutZakatPaymentsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutZakatPaymentsInput, HouseholdUpdateWithoutZakatPaymentsInput>, HouseholdUncheckedUpdateWithoutZakatPaymentsInput>
  }

  export type TransactionUpdateOneWithoutZakatPaymentsNestedInput = {
    create?: XOR<TransactionCreateWithoutZakatPaymentsInput, TransactionUncheckedCreateWithoutZakatPaymentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutZakatPaymentsInput
    upsert?: TransactionUpsertWithoutZakatPaymentsInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutZakatPaymentsInput, TransactionUpdateWithoutZakatPaymentsInput>, TransactionUncheckedUpdateWithoutZakatPaymentsInput>
  }

  export type AccountCreateNestedOneWithoutShariaComplianceInput = {
    create?: XOR<AccountCreateWithoutShariaComplianceInput, AccountUncheckedCreateWithoutShariaComplianceInput>
    connectOrCreate?: AccountCreateOrConnectWithoutShariaComplianceInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutShariaReviewsInput = {
    create?: XOR<UserCreateWithoutShariaReviewsInput, UserUncheckedCreateWithoutShariaReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShariaReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumShariaComplianceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShariaComplianceStatus
  }

  export type AccountUpdateOneRequiredWithoutShariaComplianceNestedInput = {
    create?: XOR<AccountCreateWithoutShariaComplianceInput, AccountUncheckedCreateWithoutShariaComplianceInput>
    connectOrCreate?: AccountCreateOrConnectWithoutShariaComplianceInput
    upsert?: AccountUpsertWithoutShariaComplianceInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutShariaComplianceInput, AccountUpdateWithoutShariaComplianceInput>, AccountUncheckedUpdateWithoutShariaComplianceInput>
  }

  export type UserUpdateOneWithoutShariaReviewsNestedInput = {
    create?: XOR<UserCreateWithoutShariaReviewsInput, UserUncheckedCreateWithoutShariaReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShariaReviewsInput
    upsert?: UserUpsertWithoutShariaReviewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShariaReviewsInput, UserUpdateWithoutShariaReviewsInput>, UserUncheckedUpdateWithoutShariaReviewsInput>
  }

  export type HouseholdCreateNestedOneWithoutIslamicFinanceReportsInput = {
    create?: XOR<HouseholdCreateWithoutIslamicFinanceReportsInput, HouseholdUncheckedCreateWithoutIslamicFinanceReportsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutIslamicFinanceReportsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGeneratedIslamicReportsInput = {
    create?: XOR<UserCreateWithoutGeneratedIslamicReportsInput, UserUncheckedCreateWithoutGeneratedIslamicReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedIslamicReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumIslamicReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.IslamicReportType
  }

  export type HouseholdUpdateOneRequiredWithoutIslamicFinanceReportsNestedInput = {
    create?: XOR<HouseholdCreateWithoutIslamicFinanceReportsInput, HouseholdUncheckedCreateWithoutIslamicFinanceReportsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutIslamicFinanceReportsInput
    upsert?: HouseholdUpsertWithoutIslamicFinanceReportsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutIslamicFinanceReportsInput, HouseholdUpdateWithoutIslamicFinanceReportsInput>, HouseholdUncheckedUpdateWithoutIslamicFinanceReportsInput>
  }

  export type UserUpdateOneWithoutGeneratedIslamicReportsNestedInput = {
    create?: XOR<UserCreateWithoutGeneratedIslamicReportsInput, UserUncheckedCreateWithoutGeneratedIslamicReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedIslamicReportsInput
    upsert?: UserUpsertWithoutGeneratedIslamicReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeneratedIslamicReportsInput, UserUpdateWithoutGeneratedIslamicReportsInput>, UserUncheckedUpdateWithoutGeneratedIslamicReportsInput>
  }

  export type NotificationCreatechannelsInput = {
    set: $Enums.NotificationChannel[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type HouseholdCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<HouseholdCreateWithoutNotificationsInput, HouseholdUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutNotificationsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type NotificationDeliveryCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationDeliveryCreateWithoutNotificationInput, NotificationDeliveryUncheckedCreateWithoutNotificationInput> | NotificationDeliveryCreateWithoutNotificationInput[] | NotificationDeliveryUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationDeliveryCreateOrConnectWithoutNotificationInput | NotificationDeliveryCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationDeliveryCreateManyNotificationInputEnvelope
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
  }

  export type NotificationDeliveryUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationDeliveryCreateWithoutNotificationInput, NotificationDeliveryUncheckedCreateWithoutNotificationInput> | NotificationDeliveryCreateWithoutNotificationInput[] | NotificationDeliveryUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationDeliveryCreateOrConnectWithoutNotificationInput | NotificationDeliveryCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationDeliveryCreateManyNotificationInputEnvelope
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type NotificationUpdatechannelsInput = {
    set?: $Enums.NotificationChannel[]
    push?: $Enums.NotificationChannel | $Enums.NotificationChannel[]
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type HouseholdUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<HouseholdCreateWithoutNotificationsInput, HouseholdUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutNotificationsInput
    upsert?: HouseholdUpsertWithoutNotificationsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutNotificationsInput, HouseholdUpdateWithoutNotificationsInput>, HouseholdUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationDeliveryUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationDeliveryCreateWithoutNotificationInput, NotificationDeliveryUncheckedCreateWithoutNotificationInput> | NotificationDeliveryCreateWithoutNotificationInput[] | NotificationDeliveryUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationDeliveryCreateOrConnectWithoutNotificationInput | NotificationDeliveryCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput | NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationDeliveryCreateManyNotificationInputEnvelope
    set?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
    disconnect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
    delete?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
    update?: NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput | NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput | NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[]
  }

  export type NotificationDeliveryUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationDeliveryCreateWithoutNotificationInput, NotificationDeliveryUncheckedCreateWithoutNotificationInput> | NotificationDeliveryCreateWithoutNotificationInput[] | NotificationDeliveryUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationDeliveryCreateOrConnectWithoutNotificationInput | NotificationDeliveryCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput | NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationDeliveryCreateManyNotificationInputEnvelope
    set?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
    disconnect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
    delete?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
    connect?: NotificationDeliveryWhereUniqueInput | NotificationDeliveryWhereUniqueInput[]
    update?: NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput | NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput | NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[]
  }

  export type NotificationCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<NotificationCreateWithoutDeliveriesInput, NotificationUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutDeliveriesInput
    connect?: NotificationWhereUniqueInput
  }

  export type EnumNotificationChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannel
  }

  export type NotificationUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<NotificationCreateWithoutDeliveriesInput, NotificationUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutDeliveriesInput
    upsert?: NotificationUpsertWithoutDeliveriesInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutDeliveriesInput, NotificationUpdateWithoutDeliveriesInput>, NotificationUncheckedUpdateWithoutDeliveriesInput>
  }

  export type UserCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: UserUpsertWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferencesInput, UserUpdateWithoutNotificationPreferencesInput>, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type UserCreateNestedOneWithoutPushSubscriptionsInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    upsert?: UserUpsertWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushSubscriptionsInput, UserUpdateWithoutPushSubscriptionsInput>, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumHouseholdRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRole | EnumHouseholdRoleFieldRefInput<$PrismaModel>
    in?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumHouseholdRoleFilter<$PrismaModel> | $Enums.HouseholdRole
  }

  export type NestedEnumHouseholdRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRole | EnumHouseholdRoleFieldRefInput<$PrismaModel>
    in?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumHouseholdRoleWithAggregatesFilter<$PrismaModel> | $Enums.HouseholdRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHouseholdRoleFilter<$PrismaModel>
    _max?: NestedEnumHouseholdRoleFilter<$PrismaModel>
  }

  export type NestedEnumInstitutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeFilter<$PrismaModel> | $Enums.InstitutionType
  }

  export type NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionTypeFilter<$PrismaModel>
    _max?: NestedEnumInstitutionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCategoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeFilter<$PrismaModel> | $Enums.CategoryType
  }

  export type NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.CategoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryTypeFilter<$PrismaModel>
    _max?: NestedEnumCategoryTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTypeFilter<$PrismaModel> | $Enums.LedgerType
  }

  export type NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerType | EnumLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerType[] | ListEnumLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerTypeFilter<$PrismaModel>
  }

  export type NestedEnumDebtTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DebtType | EnumDebtTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DebtType[] | ListEnumDebtTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebtType[] | ListEnumDebtTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDebtTypeFilter<$PrismaModel> | $Enums.DebtType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumDebtTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DebtType | EnumDebtTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DebtType[] | ListEnumDebtTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebtType[] | ListEnumDebtTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDebtTypeWithAggregatesFilter<$PrismaModel> | $Enums.DebtType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDebtTypeFilter<$PrismaModel>
    _max?: NestedEnumDebtTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBudgetPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodFilter<$PrismaModel> | $Enums.BudgetPeriod
  }

  export type NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel> | $Enums.BudgetPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetPeriodFilter<$PrismaModel>
    _max?: NestedEnumBudgetPeriodFilter<$PrismaModel>
  }

  export type NestedEnumGratitudeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GratitudeType | EnumGratitudeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GratitudeType[] | ListEnumGratitudeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GratitudeType[] | ListEnumGratitudeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGratitudeTypeFilter<$PrismaModel> | $Enums.GratitudeType
  }

  export type NestedEnumGratitudeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GratitudeType | EnumGratitudeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GratitudeType[] | ListEnumGratitudeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GratitudeType[] | ListEnumGratitudeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGratitudeTypeWithAggregatesFilter<$PrismaModel> | $Enums.GratitudeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGratitudeTypeFilter<$PrismaModel>
    _max?: NestedEnumGratitudeTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumInsightPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightPriority | EnumInsightPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightPriorityFilter<$PrismaModel> | $Enums.InsightPriority
  }

  export type NestedEnumInsightPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightPriority | EnumInsightPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightPriority[] | ListEnumInsightPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightPriorityWithAggregatesFilter<$PrismaModel> | $Enums.InsightPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightPriorityFilter<$PrismaModel>
    _max?: NestedEnumInsightPriorityFilter<$PrismaModel>
  }

  export type NestedEnumRecurrenceFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFrequency | EnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel> | $Enums.RecurrenceFrequency
  }

  export type NestedEnumRecurringTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringTransactionStatus | EnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringTransactionStatus[] | ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringTransactionStatus[] | ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringTransactionStatusFilter<$PrismaModel> | $Enums.RecurringTransactionStatus
  }

  export type NestedEnumRecurrenceFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFrequency | EnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.RecurrenceFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumRecurringTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringTransactionStatus | EnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringTransactionStatus[] | ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringTransactionStatus[] | ListEnumRecurringTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecurringTransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurringTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumRecurringTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type NestedEnumZakatAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZakatAssetType | EnumZakatAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZakatAssetType[] | ListEnumZakatAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZakatAssetType[] | ListEnumZakatAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZakatAssetTypeFilter<$PrismaModel> | $Enums.ZakatAssetType
  }

  export type NestedEnumZakatAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZakatAssetType | EnumZakatAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZakatAssetType[] | ListEnumZakatAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZakatAssetType[] | ListEnumZakatAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZakatAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZakatAssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZakatAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumZakatAssetTypeFilter<$PrismaModel>
  }

  export type NestedEnumZakatReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZakatReminderType | EnumZakatReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZakatReminderType[] | ListEnumZakatReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZakatReminderType[] | ListEnumZakatReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZakatReminderTypeFilter<$PrismaModel> | $Enums.ZakatReminderType
  }

  export type NestedEnumZakatReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZakatReminderType | EnumZakatReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZakatReminderType[] | ListEnumZakatReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZakatReminderType[] | ListEnumZakatReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZakatReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZakatReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZakatReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumZakatReminderTypeFilter<$PrismaModel>
  }

  export type NestedEnumShariaComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShariaComplianceStatus | EnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShariaComplianceStatus[] | ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShariaComplianceStatus[] | ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShariaComplianceStatusFilter<$PrismaModel> | $Enums.ShariaComplianceStatus
  }

  export type NestedEnumShariaComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShariaComplianceStatus | EnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShariaComplianceStatus[] | ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShariaComplianceStatus[] | ListEnumShariaComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShariaComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShariaComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShariaComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumShariaComplianceStatusFilter<$PrismaModel>
  }

  export type NestedEnumIslamicReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IslamicReportType | EnumIslamicReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IslamicReportType[] | ListEnumIslamicReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IslamicReportType[] | ListEnumIslamicReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIslamicReportTypeFilter<$PrismaModel> | $Enums.IslamicReportType
  }

  export type NestedEnumIslamicReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IslamicReportType | EnumIslamicReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IslamicReportType[] | ListEnumIslamicReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IslamicReportType[] | ListEnumIslamicReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIslamicReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.IslamicReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIslamicReportTypeFilter<$PrismaModel>
    _max?: NestedEnumIslamicReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type HouseholdMemberCreateWithoutUserInput = {
    id?: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutMembersInput
  }

  export type HouseholdMemberUncheckedCreateWithoutUserInput = {
    id?: string
    householdId: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
  }

  export type HouseholdMemberCreateOrConnectWithoutUserInput = {
    where: HouseholdMemberWhereUniqueInput
    create: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput>
  }

  export type HouseholdMemberCreateManyUserInputEnvelope = {
    data: HouseholdMemberCreateManyUserInput | HouseholdMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasskeyCreateWithoutUserInput = {
    id?: string
    name: string
    credentialId: string
    publicKey: string
    counter?: number
    transports?: PasskeyCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type PasskeyUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    credentialId: string
    publicKey: string
    counter?: number
    transports?: PasskeyCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type PasskeyCreateOrConnectWithoutUserInput = {
    where: PasskeyWhereUniqueInput
    create: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput>
  }

  export type PasskeyCreateManyUserInputEnvelope = {
    data: PasskeyCreateManyUserInput | PasskeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCreatorInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCreatorInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput>
  }

  export type TransactionCreateManyCreatorInputEnvelope = {
    data: TransactionCreateManyCreatorInput | TransactionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutCreatorInput = {
    id?: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutWishlistItemsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateWithoutCreatorInput = {
    id?: string
    householdId: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutWishlistItemInput
  }

  export type WishlistItemCreateOrConnectWithoutCreatorInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutCreatorInput, WishlistItemUncheckedCreateWithoutCreatorInput>
  }

  export type WishlistItemCreateManyCreatorInputEnvelope = {
    data: WishlistItemCreateManyCreatorInput | WishlistItemCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type GratitudeEntryCreateWithoutCreatorInput = {
    id?: string
    giver: string
    type: $Enums.GratitudeType
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdAt?: Date | string
    household: HouseholdCreateNestedOneWithoutGratitudeEntriesInput
    category?: CategoryCreateNestedOneWithoutGratitudeEntriesInput
    transaction?: TransactionCreateNestedOneWithoutGratitudeEntriesInput
  }

  export type GratitudeEntryUncheckedCreateWithoutCreatorInput = {
    id?: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    categoryId?: string | null
    transactionId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdAt?: Date | string
  }

  export type GratitudeEntryCreateOrConnectWithoutCreatorInput = {
    where: GratitudeEntryWhereUniqueInput
    create: XOR<GratitudeEntryCreateWithoutCreatorInput, GratitudeEntryUncheckedCreateWithoutCreatorInput>
  }

  export type GratitudeEntryCreateManyCreatorInputEnvelope = {
    data: GratitudeEntryCreateManyCreatorInput | GratitudeEntryCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type RecurringTransactionCreateWithoutCreatorInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutRecurringTransactionsInput
    account: AccountCreateNestedOneWithoutRecurringTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutRecurringTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutRecurringTransactionsInput
    executions?: RecurringTransactionExecutionCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionUncheckedCreateWithoutCreatorInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionCreateOrConnectWithoutCreatorInput = {
    where: RecurringTransactionWhereUniqueInput
    create: XOR<RecurringTransactionCreateWithoutCreatorInput, RecurringTransactionUncheckedCreateWithoutCreatorInput>
  }

  export type RecurringTransactionCreateManyCreatorInputEnvelope = {
    data: RecurringTransactionCreateManyCreatorInput | RecurringTransactionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUploadCreateWithoutUploaderInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutDocumentUploadsInput
    ocrResults?: OcrResultCreateNestedManyWithoutDocumentInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadUncheckedCreateWithoutUploaderInput = {
    id?: string
    householdId: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ocrResults?: OcrResultUncheckedCreateNestedManyWithoutDocumentInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadCreateOrConnectWithoutUploaderInput = {
    where: DocumentUploadWhereUniqueInput
    create: XOR<DocumentUploadCreateWithoutUploaderInput, DocumentUploadUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentUploadCreateManyUploaderInputEnvelope = {
    data: DocumentUploadCreateManyUploaderInput | DocumentUploadCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type UserEventCreateWithoutUserInput = {
    id?: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    household: HouseholdCreateNestedOneWithoutUserEventsInput
  }

  export type UserEventUncheckedCreateWithoutUserInput = {
    id?: string
    householdId: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type UserEventCreateOrConnectWithoutUserInput = {
    where: UserEventWhereUniqueInput
    create: XOR<UserEventCreateWithoutUserInput, UserEventUncheckedCreateWithoutUserInput>
  }

  export type UserEventCreateManyUserInputEnvelope = {
    data: UserEventCreateManyUserInput | UserEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShariaCompliantAccountCreateWithoutReviewerInput = {
    id?: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes?: string | null
    lastReviewDate: Date | string
    nextReviewDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutShariaComplianceInput
  }

  export type ShariaCompliantAccountUncheckedCreateWithoutReviewerInput = {
    id?: string
    accountId: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes?: string | null
    lastReviewDate: Date | string
    nextReviewDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShariaCompliantAccountCreateOrConnectWithoutReviewerInput = {
    where: ShariaCompliantAccountWhereUniqueInput
    create: XOR<ShariaCompliantAccountCreateWithoutReviewerInput, ShariaCompliantAccountUncheckedCreateWithoutReviewerInput>
  }

  export type ShariaCompliantAccountCreateManyReviewerInputEnvelope = {
    data: ShariaCompliantAccountCreateManyReviewerInput | ShariaCompliantAccountCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type IslamicFinanceReportCreateWithoutGeneratorInput = {
    id?: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    household: HouseholdCreateNestedOneWithoutIslamicFinanceReportsInput
  }

  export type IslamicFinanceReportUncheckedCreateWithoutGeneratorInput = {
    id?: string
    householdId: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IslamicFinanceReportCreateOrConnectWithoutGeneratorInput = {
    where: IslamicFinanceReportWhereUniqueInput
    create: XOR<IslamicFinanceReportCreateWithoutGeneratorInput, IslamicFinanceReportUncheckedCreateWithoutGeneratorInput>
  }

  export type IslamicFinanceReportCreateManyGeneratorInputEnvelope = {
    data: IslamicFinanceReportCreateManyGeneratorInput | IslamicFinanceReportCreateManyGeneratorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutNotificationsInput
    deliveries?: NotificationDeliveryCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    householdId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data: PushSubscriptionCreateManyUserInput | PushSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: HouseholdMemberWhereUniqueInput
    update: XOR<HouseholdMemberUpdateWithoutUserInput, HouseholdMemberUncheckedUpdateWithoutUserInput>
    create: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput>
  }

  export type HouseholdMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: HouseholdMemberWhereUniqueInput
    data: XOR<HouseholdMemberUpdateWithoutUserInput, HouseholdMemberUncheckedUpdateWithoutUserInput>
  }

  export type HouseholdMemberUpdateManyWithWhereWithoutUserInput = {
    where: HouseholdMemberScalarWhereInput
    data: XOR<HouseholdMemberUpdateManyMutationInput, HouseholdMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type HouseholdMemberScalarWhereInput = {
    AND?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
    OR?: HouseholdMemberScalarWhereInput[]
    NOT?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
    id?: UuidFilter<"HouseholdMember"> | string
    userId?: UuidFilter<"HouseholdMember"> | string
    householdId?: UuidFilter<"HouseholdMember"> | string
    role?: EnumHouseholdRoleFilter<"HouseholdMember"> | $Enums.HouseholdRole
    permissions?: JsonFilter<"HouseholdMember">
    joinedAt?: DateTimeFilter<"HouseholdMember"> | Date | string
  }

  export type PasskeyUpsertWithWhereUniqueWithoutUserInput = {
    where: PasskeyWhereUniqueInput
    update: XOR<PasskeyUpdateWithoutUserInput, PasskeyUncheckedUpdateWithoutUserInput>
    create: XOR<PasskeyCreateWithoutUserInput, PasskeyUncheckedCreateWithoutUserInput>
  }

  export type PasskeyUpdateWithWhereUniqueWithoutUserInput = {
    where: PasskeyWhereUniqueInput
    data: XOR<PasskeyUpdateWithoutUserInput, PasskeyUncheckedUpdateWithoutUserInput>
  }

  export type PasskeyUpdateManyWithWhereWithoutUserInput = {
    where: PasskeyScalarWhereInput
    data: XOR<PasskeyUpdateManyMutationInput, PasskeyUncheckedUpdateManyWithoutUserInput>
  }

  export type PasskeyScalarWhereInput = {
    AND?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
    OR?: PasskeyScalarWhereInput[]
    NOT?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
    id?: UuidFilter<"Passkey"> | string
    userId?: UuidFilter<"Passkey"> | string
    name?: StringFilter<"Passkey"> | string
    credentialId?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    transports?: StringNullableListFilter<"Passkey">
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"Passkey"> | Date | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: UuidFilter<"Session"> | string
    userId?: UuidFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCreatorInput, TransactionUncheckedUpdateWithoutCreatorInput>
    create: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCreatorInput, TransactionUncheckedUpdateWithoutCreatorInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCreatorInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: UuidFilter<"Transaction"> | string
    householdId?: UuidFilter<"Transaction"> | string
    amountCents?: BigIntFilter<"Transaction"> | bigint | number
    currency?: StringFilter<"Transaction"> | string
    originalAmountCents?: BigIntNullableFilter<"Transaction"> | bigint | number | null
    originalCurrency?: StringNullableFilter<"Transaction"> | string | null
    exchangeRate?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    description?: StringFilter<"Transaction"> | string
    categoryId?: UuidNullableFilter<"Transaction"> | string | null
    merchant?: StringNullableFilter<"Transaction"> | string | null
    merchantId?: UuidNullableFilter<"Transaction"> | string | null
    merchantName?: StringNullableFilter<"Transaction"> | string | null
    merchantLogoUrl?: StringNullableFilter<"Transaction"> | string | null
    merchantColor?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    accountId?: UuidFilter<"Transaction"> | string
    transferAccountId?: UuidNullableFilter<"Transaction"> | string | null
    receiptUrl?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonFilter<"Transaction">
    createdBy?: UuidFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutCreatorInput, WishlistItemUncheckedUpdateWithoutCreatorInput>
    create: XOR<WishlistItemCreateWithoutCreatorInput, WishlistItemUncheckedCreateWithoutCreatorInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutCreatorInput, WishlistItemUncheckedUpdateWithoutCreatorInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutCreatorInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutCreatorInput>
  }

  export type WishlistItemScalarWhereInput = {
    AND?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    OR?: WishlistItemScalarWhereInput[]
    NOT?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    id?: UuidFilter<"WishlistItem"> | string
    householdId?: UuidFilter<"WishlistItem"> | string
    name?: StringFilter<"WishlistItem"> | string
    url?: StringFilter<"WishlistItem"> | string
    currentPriceCents?: BigIntFilter<"WishlistItem"> | bigint | number
    targetPriceCents?: BigIntNullableFilter<"WishlistItem"> | bigint | number | null
    currency?: StringFilter<"WishlistItem"> | string
    imageUrl?: StringNullableFilter<"WishlistItem"> | string | null
    merchant?: StringFilter<"WishlistItem"> | string
    linkedGoalId?: UuidNullableFilter<"WishlistItem"> | string | null
    isPurchased?: BoolFilter<"WishlistItem"> | boolean
    createdBy?: UuidFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    updatedAt?: DateTimeFilter<"WishlistItem"> | Date | string
  }

  export type GratitudeEntryUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GratitudeEntryWhereUniqueInput
    update: XOR<GratitudeEntryUpdateWithoutCreatorInput, GratitudeEntryUncheckedUpdateWithoutCreatorInput>
    create: XOR<GratitudeEntryCreateWithoutCreatorInput, GratitudeEntryUncheckedCreateWithoutCreatorInput>
  }

  export type GratitudeEntryUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GratitudeEntryWhereUniqueInput
    data: XOR<GratitudeEntryUpdateWithoutCreatorInput, GratitudeEntryUncheckedUpdateWithoutCreatorInput>
  }

  export type GratitudeEntryUpdateManyWithWhereWithoutCreatorInput = {
    where: GratitudeEntryScalarWhereInput
    data: XOR<GratitudeEntryUpdateManyMutationInput, GratitudeEntryUncheckedUpdateManyWithoutCreatorInput>
  }

  export type GratitudeEntryScalarWhereInput = {
    AND?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
    OR?: GratitudeEntryScalarWhereInput[]
    NOT?: GratitudeEntryScalarWhereInput | GratitudeEntryScalarWhereInput[]
    id?: UuidFilter<"GratitudeEntry"> | string
    householdId?: UuidFilter<"GratitudeEntry"> | string
    giver?: StringFilter<"GratitudeEntry"> | string
    type?: EnumGratitudeTypeFilter<"GratitudeEntry"> | $Enums.GratitudeType
    categoryId?: UuidNullableFilter<"GratitudeEntry"> | string | null
    transactionId?: UuidNullableFilter<"GratitudeEntry"> | string | null
    estimatedValueCents?: BigIntNullableFilter<"GratitudeEntry"> | bigint | number | null
    currency?: StringNullableFilter<"GratitudeEntry"> | string | null
    description?: StringFilter<"GratitudeEntry"> | string
    date?: DateTimeFilter<"GratitudeEntry"> | Date | string
    createdBy?: UuidFilter<"GratitudeEntry"> | string
    createdAt?: DateTimeFilter<"GratitudeEntry"> | Date | string
  }

  export type RecurringTransactionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RecurringTransactionWhereUniqueInput
    update: XOR<RecurringTransactionUpdateWithoutCreatorInput, RecurringTransactionUncheckedUpdateWithoutCreatorInput>
    create: XOR<RecurringTransactionCreateWithoutCreatorInput, RecurringTransactionUncheckedCreateWithoutCreatorInput>
  }

  export type RecurringTransactionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RecurringTransactionWhereUniqueInput
    data: XOR<RecurringTransactionUpdateWithoutCreatorInput, RecurringTransactionUncheckedUpdateWithoutCreatorInput>
  }

  export type RecurringTransactionUpdateManyWithWhereWithoutCreatorInput = {
    where: RecurringTransactionScalarWhereInput
    data: XOR<RecurringTransactionUpdateManyMutationInput, RecurringTransactionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type RecurringTransactionScalarWhereInput = {
    AND?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
    OR?: RecurringTransactionScalarWhereInput[]
    NOT?: RecurringTransactionScalarWhereInput | RecurringTransactionScalarWhereInput[]
    id?: UuidFilter<"RecurringTransaction"> | string
    householdId?: UuidFilter<"RecurringTransaction"> | string
    name?: StringFilter<"RecurringTransaction"> | string
    description?: StringFilter<"RecurringTransaction"> | string
    amountCents?: BigIntFilter<"RecurringTransaction"> | bigint | number
    currency?: StringFilter<"RecurringTransaction"> | string
    accountId?: UuidFilter<"RecurringTransaction"> | string
    transferAccountId?: UuidNullableFilter<"RecurringTransaction"> | string | null
    categoryId?: UuidNullableFilter<"RecurringTransaction"> | string | null
    merchant?: StringNullableFilter<"RecurringTransaction"> | string | null
    frequency?: EnumRecurrenceFrequencyFilter<"RecurringTransaction"> | $Enums.RecurrenceFrequency
    intervalValue?: IntFilter<"RecurringTransaction"> | number
    startDate?: DateTimeFilter<"RecurringTransaction"> | Date | string
    endDate?: DateTimeNullableFilter<"RecurringTransaction"> | Date | string | null
    nextExecutionDate?: DateTimeFilter<"RecurringTransaction"> | Date | string
    lastExecutionDate?: DateTimeNullableFilter<"RecurringTransaction"> | Date | string | null
    executionCount?: IntFilter<"RecurringTransaction"> | number
    maxExecutions?: IntNullableFilter<"RecurringTransaction"> | number | null
    status?: EnumRecurringTransactionStatusFilter<"RecurringTransaction"> | $Enums.RecurringTransactionStatus
    metadata?: JsonFilter<"RecurringTransaction">
    createdBy?: UuidFilter<"RecurringTransaction"> | string
    createdAt?: DateTimeFilter<"RecurringTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringTransaction"> | Date | string
  }

  export type DocumentUploadUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DocumentUploadWhereUniqueInput
    update: XOR<DocumentUploadUpdateWithoutUploaderInput, DocumentUploadUncheckedUpdateWithoutUploaderInput>
    create: XOR<DocumentUploadCreateWithoutUploaderInput, DocumentUploadUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentUploadUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DocumentUploadWhereUniqueInput
    data: XOR<DocumentUploadUpdateWithoutUploaderInput, DocumentUploadUncheckedUpdateWithoutUploaderInput>
  }

  export type DocumentUploadUpdateManyWithWhereWithoutUploaderInput = {
    where: DocumentUploadScalarWhereInput
    data: XOR<DocumentUploadUpdateManyMutationInput, DocumentUploadUncheckedUpdateManyWithoutUploaderInput>
  }

  export type DocumentUploadScalarWhereInput = {
    AND?: DocumentUploadScalarWhereInput | DocumentUploadScalarWhereInput[]
    OR?: DocumentUploadScalarWhereInput[]
    NOT?: DocumentUploadScalarWhereInput | DocumentUploadScalarWhereInput[]
    id?: UuidFilter<"DocumentUpload"> | string
    householdId?: UuidFilter<"DocumentUpload"> | string
    fileName?: StringFilter<"DocumentUpload"> | string
    fileSize?: IntFilter<"DocumentUpload"> | number
    mimeType?: StringFilter<"DocumentUpload"> | string
    documentType?: EnumDocumentTypeFilter<"DocumentUpload"> | $Enums.DocumentType
    status?: EnumProcessingStatusFilter<"DocumentUpload"> | $Enums.ProcessingStatus
    uploadedBy?: UuidFilter<"DocumentUpload"> | string
    uploadedAt?: DateTimeFilter<"DocumentUpload"> | Date | string
    processedAt?: DateTimeNullableFilter<"DocumentUpload"> | Date | string | null
    storageUrl?: StringFilter<"DocumentUpload"> | string
    description?: StringNullableFilter<"DocumentUpload"> | string | null
    metadata?: JsonFilter<"DocumentUpload">
    createdAt?: DateTimeFilter<"DocumentUpload"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentUpload"> | Date | string
  }

  export type UserEventUpsertWithWhereUniqueWithoutUserInput = {
    where: UserEventWhereUniqueInput
    update: XOR<UserEventUpdateWithoutUserInput, UserEventUncheckedUpdateWithoutUserInput>
    create: XOR<UserEventCreateWithoutUserInput, UserEventUncheckedCreateWithoutUserInput>
  }

  export type UserEventUpdateWithWhereUniqueWithoutUserInput = {
    where: UserEventWhereUniqueInput
    data: XOR<UserEventUpdateWithoutUserInput, UserEventUncheckedUpdateWithoutUserInput>
  }

  export type UserEventUpdateManyWithWhereWithoutUserInput = {
    where: UserEventScalarWhereInput
    data: XOR<UserEventUpdateManyMutationInput, UserEventUncheckedUpdateManyWithoutUserInput>
  }

  export type UserEventScalarWhereInput = {
    AND?: UserEventScalarWhereInput | UserEventScalarWhereInput[]
    OR?: UserEventScalarWhereInput[]
    NOT?: UserEventScalarWhereInput | UserEventScalarWhereInput[]
    id?: UuidFilter<"UserEvent"> | string
    userId?: UuidFilter<"UserEvent"> | string
    householdId?: UuidFilter<"UserEvent"> | string
    eventType?: StringFilter<"UserEvent"> | string
    eventData?: JsonFilter<"UserEvent">
    resourceType?: StringNullableFilter<"UserEvent"> | string | null
    resourceId?: UuidNullableFilter<"UserEvent"> | string | null
    sessionId?: StringNullableFilter<"UserEvent"> | string | null
    ipAddress?: StringNullableFilter<"UserEvent"> | string | null
    userAgent?: StringNullableFilter<"UserEvent"> | string | null
    timestamp?: DateTimeFilter<"UserEvent"> | Date | string
  }

  export type ShariaCompliantAccountUpsertWithWhereUniqueWithoutReviewerInput = {
    where: ShariaCompliantAccountWhereUniqueInput
    update: XOR<ShariaCompliantAccountUpdateWithoutReviewerInput, ShariaCompliantAccountUncheckedUpdateWithoutReviewerInput>
    create: XOR<ShariaCompliantAccountCreateWithoutReviewerInput, ShariaCompliantAccountUncheckedCreateWithoutReviewerInput>
  }

  export type ShariaCompliantAccountUpdateWithWhereUniqueWithoutReviewerInput = {
    where: ShariaCompliantAccountWhereUniqueInput
    data: XOR<ShariaCompliantAccountUpdateWithoutReviewerInput, ShariaCompliantAccountUncheckedUpdateWithoutReviewerInput>
  }

  export type ShariaCompliantAccountUpdateManyWithWhereWithoutReviewerInput = {
    where: ShariaCompliantAccountScalarWhereInput
    data: XOR<ShariaCompliantAccountUpdateManyMutationInput, ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerInput>
  }

  export type ShariaCompliantAccountScalarWhereInput = {
    AND?: ShariaCompliantAccountScalarWhereInput | ShariaCompliantAccountScalarWhereInput[]
    OR?: ShariaCompliantAccountScalarWhereInput[]
    NOT?: ShariaCompliantAccountScalarWhereInput | ShariaCompliantAccountScalarWhereInput[]
    id?: UuidFilter<"ShariaCompliantAccount"> | string
    accountId?: UuidFilter<"ShariaCompliantAccount"> | string
    complianceStatus?: EnumShariaComplianceStatusFilter<"ShariaCompliantAccount"> | $Enums.ShariaComplianceStatus
    complianceNotes?: StringNullableFilter<"ShariaCompliantAccount"> | string | null
    lastReviewDate?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    nextReviewDate?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    reviewedBy?: UuidNullableFilter<"ShariaCompliantAccount"> | string | null
    metadata?: JsonFilter<"ShariaCompliantAccount">
    createdAt?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ShariaCompliantAccount"> | Date | string
  }

  export type IslamicFinanceReportUpsertWithWhereUniqueWithoutGeneratorInput = {
    where: IslamicFinanceReportWhereUniqueInput
    update: XOR<IslamicFinanceReportUpdateWithoutGeneratorInput, IslamicFinanceReportUncheckedUpdateWithoutGeneratorInput>
    create: XOR<IslamicFinanceReportCreateWithoutGeneratorInput, IslamicFinanceReportUncheckedCreateWithoutGeneratorInput>
  }

  export type IslamicFinanceReportUpdateWithWhereUniqueWithoutGeneratorInput = {
    where: IslamicFinanceReportWhereUniqueInput
    data: XOR<IslamicFinanceReportUpdateWithoutGeneratorInput, IslamicFinanceReportUncheckedUpdateWithoutGeneratorInput>
  }

  export type IslamicFinanceReportUpdateManyWithWhereWithoutGeneratorInput = {
    where: IslamicFinanceReportScalarWhereInput
    data: XOR<IslamicFinanceReportUpdateManyMutationInput, IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorInput>
  }

  export type IslamicFinanceReportScalarWhereInput = {
    AND?: IslamicFinanceReportScalarWhereInput | IslamicFinanceReportScalarWhereInput[]
    OR?: IslamicFinanceReportScalarWhereInput[]
    NOT?: IslamicFinanceReportScalarWhereInput | IslamicFinanceReportScalarWhereInput[]
    id?: UuidFilter<"IslamicFinanceReport"> | string
    householdId?: UuidFilter<"IslamicFinanceReport"> | string
    reportType?: EnumIslamicReportTypeFilter<"IslamicFinanceReport"> | $Enums.IslamicReportType
    periodStartDate?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    periodEndDate?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    periodType?: StringFilter<"IslamicFinanceReport"> | string
    reportData?: JsonFilter<"IslamicFinanceReport">
    generatedAt?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
    generatedBy?: UuidNullableFilter<"IslamicFinanceReport"> | string | null
    metadata?: JsonFilter<"IslamicFinanceReport">
    createdAt?: DateTimeFilter<"IslamicFinanceReport"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    householdId?: UuidFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionText?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonFilter<"Notification">
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    channels?: EnumNotificationChannelNullableListFilter<"Notification">
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAlerts?: JsonNullValueInput | InputJsonValue
    debtReminders?: JsonNullValueInput | InputJsonValue
    zakatReminders?: JsonNullValueInput | InputJsonValue
    priceAlerts?: JsonNullValueInput | InputJsonValue
    transactionAlerts?: JsonNullValueInput | InputJsonValue
    monthlyReports?: JsonNullValueInput | InputJsonValue
    securityAlerts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    OR?: PushSubscriptionScalarWhereInput[]
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    id?: UuidFilter<"PushSubscription"> | string
    userId?: UuidFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    isActive?: BoolFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type HouseholdMemberCreateWithoutHouseholdInput = {
    id?: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutHouseholdMembersInput
  }

  export type HouseholdMemberUncheckedCreateWithoutHouseholdInput = {
    id?: string
    userId: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
  }

  export type HouseholdMemberCreateOrConnectWithoutHouseholdInput = {
    where: HouseholdMemberWhereUniqueInput
    create: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput>
  }

  export type HouseholdMemberCreateManyHouseholdInputEnvelope = {
    data: HouseholdMemberCreateManyHouseholdInput | HouseholdMemberCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutHouseholdInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutHouseholdInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutHouseholdInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutHouseholdInput, AccountUncheckedCreateWithoutHouseholdInput>
  }

  export type AccountCreateManyHouseholdInputEnvelope = {
    data: AccountCreateManyHouseholdInput | AccountCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutHouseholdInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutHouseholdInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutHouseholdInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutHouseholdInput, TransactionUncheckedCreateWithoutHouseholdInput>
  }

  export type TransactionCreateManyHouseholdInputEnvelope = {
    data: TransactionCreateManyHouseholdInput | TransactionCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type DebtCreateWithoutHouseholdInput = {
    id?: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint | number
    currentBalanceCents: bigint | number
    currency?: string
    interestRate?: Decimal | DecimalJsLike | number | string | null
    marginRate?: Decimal | DecimalJsLike | number | string | null
    startDate: Date | string
    maturityDate?: Date | string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: DebtPaymentCreateNestedManyWithoutDebtInput
  }

  export type DebtUncheckedCreateWithoutHouseholdInput = {
    id?: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint | number
    currentBalanceCents: bigint | number
    currency?: string
    interestRate?: Decimal | DecimalJsLike | number | string | null
    marginRate?: Decimal | DecimalJsLike | number | string | null
    startDate: Date | string
    maturityDate?: Date | string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: DebtPaymentUncheckedCreateNestedManyWithoutDebtInput
  }

  export type DebtCreateOrConnectWithoutHouseholdInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutHouseholdInput, DebtUncheckedCreateWithoutHouseholdInput>
  }

  export type DebtCreateManyHouseholdInputEnvelope = {
    data: DebtCreateManyHouseholdInput | DebtCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type BudgetCreateWithoutHouseholdInput = {
    id?: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint | number
    currency?: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: BudgetCategoryCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutHouseholdInput = {
    id?: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint | number
    currency?: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: BudgetCategoryUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutHouseholdInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutHouseholdInput, BudgetUncheckedCreateWithoutHouseholdInput>
  }

  export type BudgetCreateManyHouseholdInputEnvelope = {
    data: BudgetCreateManyHouseholdInput | BudgetCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutHouseholdInput = {
    id?: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedWishlistItemsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateWithoutHouseholdInput = {
    id?: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutWishlistItemInput
  }

  export type WishlistItemCreateOrConnectWithoutHouseholdInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutHouseholdInput, WishlistItemUncheckedCreateWithoutHouseholdInput>
  }

  export type WishlistItemCreateManyHouseholdInputEnvelope = {
    data: WishlistItemCreateManyHouseholdInput | WishlistItemCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type GratitudeEntryCreateWithoutHouseholdInput = {
    id?: string
    giver: string
    type: $Enums.GratitudeType
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdAt?: Date | string
    category?: CategoryCreateNestedOneWithoutGratitudeEntriesInput
    transaction?: TransactionCreateNestedOneWithoutGratitudeEntriesInput
    creator: UserCreateNestedOneWithoutCreatedGratitudeEntriesInput
  }

  export type GratitudeEntryUncheckedCreateWithoutHouseholdInput = {
    id?: string
    giver: string
    type: $Enums.GratitudeType
    categoryId?: string | null
    transactionId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdBy: string
    createdAt?: Date | string
  }

  export type GratitudeEntryCreateOrConnectWithoutHouseholdInput = {
    where: GratitudeEntryWhereUniqueInput
    create: XOR<GratitudeEntryCreateWithoutHouseholdInput, GratitudeEntryUncheckedCreateWithoutHouseholdInput>
  }

  export type GratitudeEntryCreateManyHouseholdInputEnvelope = {
    data: GratitudeEntryCreateManyHouseholdInput | GratitudeEntryCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutHouseholdInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateWithoutHouseholdInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryCreateOrConnectWithoutHouseholdInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutHouseholdInput, CategoryUncheckedCreateWithoutHouseholdInput>
  }

  export type CategoryCreateManyHouseholdInputEnvelope = {
    data: CategoryCreateManyHouseholdInput | CategoryCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type RecurringTransactionCreateWithoutHouseholdInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutRecurringTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutRecurringTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutRecurringTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedRecurringTransactionsInput
    executions?: RecurringTransactionExecutionCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionUncheckedCreateWithoutHouseholdInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionCreateOrConnectWithoutHouseholdInput = {
    where: RecurringTransactionWhereUniqueInput
    create: XOR<RecurringTransactionCreateWithoutHouseholdInput, RecurringTransactionUncheckedCreateWithoutHouseholdInput>
  }

  export type RecurringTransactionCreateManyHouseholdInputEnvelope = {
    data: RecurringTransactionCreateManyHouseholdInput | RecurringTransactionCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUploadCreateWithoutHouseholdInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
    ocrResults?: OcrResultCreateNestedManyWithoutDocumentInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadUncheckedCreateWithoutHouseholdInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedBy: string
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ocrResults?: OcrResultUncheckedCreateNestedManyWithoutDocumentInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadCreateOrConnectWithoutHouseholdInput = {
    where: DocumentUploadWhereUniqueInput
    create: XOR<DocumentUploadCreateWithoutHouseholdInput, DocumentUploadUncheckedCreateWithoutHouseholdInput>
  }

  export type DocumentUploadCreateManyHouseholdInputEnvelope = {
    data: DocumentUploadCreateManyHouseholdInput | DocumentUploadCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type UserEventCreateWithoutHouseholdInput = {
    id?: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutUserEventsInput
  }

  export type UserEventUncheckedCreateWithoutHouseholdInput = {
    id?: string
    userId: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type UserEventCreateOrConnectWithoutHouseholdInput = {
    where: UserEventWhereUniqueInput
    create: XOR<UserEventCreateWithoutHouseholdInput, UserEventUncheckedCreateWithoutHouseholdInput>
  }

  export type UserEventCreateManyHouseholdInputEnvelope = {
    data: UserEventCreateManyHouseholdInput | UserEventCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type SpendingPatternCreateWithoutHouseholdInput = {
    id?: string
    userId?: string | null
    patternType: string
    categoryId?: string | null
    merchant?: string | null
    dayOfWeek?: number | null
    hourOfDay?: number | null
    month?: number | null
    averageAmountCents: bigint | number
    frequency: number
    confidenceScore?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
  }

  export type SpendingPatternUncheckedCreateWithoutHouseholdInput = {
    id?: string
    userId?: string | null
    patternType: string
    categoryId?: string | null
    merchant?: string | null
    dayOfWeek?: number | null
    hourOfDay?: number | null
    month?: number | null
    averageAmountCents: bigint | number
    frequency: number
    confidenceScore?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
  }

  export type SpendingPatternCreateOrConnectWithoutHouseholdInput = {
    where: SpendingPatternWhereUniqueInput
    create: XOR<SpendingPatternCreateWithoutHouseholdInput, SpendingPatternUncheckedCreateWithoutHouseholdInput>
  }

  export type SpendingPatternCreateManyHouseholdInputEnvelope = {
    data: SpendingPatternCreateManyHouseholdInput | SpendingPatternCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type FinancialInsightCreateWithoutHouseholdInput = {
    id?: string
    insightType: string
    title: string
    description: string
    data?: JsonNullValueInput | InputJsonValue
    priority: $Enums.InsightPriority
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialInsightUncheckedCreateWithoutHouseholdInput = {
    id?: string
    insightType: string
    title: string
    description: string
    data?: JsonNullValueInput | InputJsonValue
    priority: $Enums.InsightPriority
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialInsightCreateOrConnectWithoutHouseholdInput = {
    where: FinancialInsightWhereUniqueInput
    create: XOR<FinancialInsightCreateWithoutHouseholdInput, FinancialInsightUncheckedCreateWithoutHouseholdInput>
  }

  export type FinancialInsightCreateManyHouseholdInputEnvelope = {
    data: FinancialInsightCreateManyHouseholdInput | FinancialInsightCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type ZakatCalculationCreateWithoutHouseholdInput = {
    id?: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutZakatCalculationInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutZakatCalculationInput
  }

  export type ZakatCalculationUncheckedCreateWithoutHouseholdInput = {
    id?: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutZakatCalculationInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutZakatCalculationInput
  }

  export type ZakatCalculationCreateOrConnectWithoutHouseholdInput = {
    where: ZakatCalculationWhereUniqueInput
    create: XOR<ZakatCalculationCreateWithoutHouseholdInput, ZakatCalculationUncheckedCreateWithoutHouseholdInput>
  }

  export type ZakatCalculationCreateManyHouseholdInputEnvelope = {
    data: ZakatCalculationCreateManyHouseholdInput | ZakatCalculationCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type ZakatReminderCreateWithoutHouseholdInput = {
    id?: string
    reminderType: $Enums.ZakatReminderType
    scheduledDate: Date | string
    hijriDate: string
    zakatAmountCents?: bigint | number | null
    currency?: string | null
    message: string
    isActive?: boolean
    isSent?: boolean
    sentAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatReminderUncheckedCreateWithoutHouseholdInput = {
    id?: string
    reminderType: $Enums.ZakatReminderType
    scheduledDate: Date | string
    hijriDate: string
    zakatAmountCents?: bigint | number | null
    currency?: string | null
    message: string
    isActive?: boolean
    isSent?: boolean
    sentAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatReminderCreateOrConnectWithoutHouseholdInput = {
    where: ZakatReminderWhereUniqueInput
    create: XOR<ZakatReminderCreateWithoutHouseholdInput, ZakatReminderUncheckedCreateWithoutHouseholdInput>
  }

  export type ZakatReminderCreateManyHouseholdInputEnvelope = {
    data: ZakatReminderCreateManyHouseholdInput | ZakatReminderCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type ZakatPaymentCreateWithoutHouseholdInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    zakatCalculation?: ZakatCalculationCreateNestedOneWithoutZakatPaymentsInput
    transaction?: TransactionCreateNestedOneWithoutZakatPaymentsInput
  }

  export type ZakatPaymentUncheckedCreateWithoutHouseholdInput = {
    id?: string
    zakatCalculationId?: string | null
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    transactionId?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatPaymentCreateOrConnectWithoutHouseholdInput = {
    where: ZakatPaymentWhereUniqueInput
    create: XOR<ZakatPaymentCreateWithoutHouseholdInput, ZakatPaymentUncheckedCreateWithoutHouseholdInput>
  }

  export type ZakatPaymentCreateManyHouseholdInputEnvelope = {
    data: ZakatPaymentCreateManyHouseholdInput | ZakatPaymentCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type IslamicFinanceReportCreateWithoutHouseholdInput = {
    id?: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    generator?: UserCreateNestedOneWithoutGeneratedIslamicReportsInput
  }

  export type IslamicFinanceReportUncheckedCreateWithoutHouseholdInput = {
    id?: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IslamicFinanceReportCreateOrConnectWithoutHouseholdInput = {
    where: IslamicFinanceReportWhereUniqueInput
    create: XOR<IslamicFinanceReportCreateWithoutHouseholdInput, IslamicFinanceReportUncheckedCreateWithoutHouseholdInput>
  }

  export type IslamicFinanceReportCreateManyHouseholdInputEnvelope = {
    data: IslamicFinanceReportCreateManyHouseholdInput | IslamicFinanceReportCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutHouseholdInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    deliveries?: NotificationDeliveryCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutHouseholdInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: NotificationDeliveryUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutHouseholdInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutHouseholdInput, NotificationUncheckedCreateWithoutHouseholdInput>
  }

  export type NotificationCreateManyHouseholdInputEnvelope = {
    data: NotificationCreateManyHouseholdInput | NotificationCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: HouseholdMemberWhereUniqueInput
    update: XOR<HouseholdMemberUpdateWithoutHouseholdInput, HouseholdMemberUncheckedUpdateWithoutHouseholdInput>
    create: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput>
  }

  export type HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: HouseholdMemberWhereUniqueInput
    data: XOR<HouseholdMemberUpdateWithoutHouseholdInput, HouseholdMemberUncheckedUpdateWithoutHouseholdInput>
  }

  export type HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput = {
    where: HouseholdMemberScalarWhereInput
    data: XOR<HouseholdMemberUpdateManyMutationInput, HouseholdMemberUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutHouseholdInput, AccountUncheckedUpdateWithoutHouseholdInput>
    create: XOR<AccountCreateWithoutHouseholdInput, AccountUncheckedCreateWithoutHouseholdInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutHouseholdInput, AccountUncheckedUpdateWithoutHouseholdInput>
  }

  export type AccountUpdateManyWithWhereWithoutHouseholdInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: UuidFilter<"Account"> | string
    householdId?: UuidFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    subtype?: StringFilter<"Account"> | string
    currency?: StringFilter<"Account"> | string
    institutionId?: UuidNullableFilter<"Account"> | string | null
    accountNumber?: StringNullableFilter<"Account"> | string | null
    balanceCents?: BigIntFilter<"Account"> | bigint | number
    isActive?: BoolFilter<"Account"> | boolean
    ownerId?: UuidNullableFilter<"Account"> | string | null
    metadata?: JsonFilter<"Account">
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutHouseholdInput, TransactionUncheckedUpdateWithoutHouseholdInput>
    create: XOR<TransactionCreateWithoutHouseholdInput, TransactionUncheckedCreateWithoutHouseholdInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutHouseholdInput, TransactionUncheckedUpdateWithoutHouseholdInput>
  }

  export type TransactionUpdateManyWithWhereWithoutHouseholdInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type DebtUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: DebtWhereUniqueInput
    update: XOR<DebtUpdateWithoutHouseholdInput, DebtUncheckedUpdateWithoutHouseholdInput>
    create: XOR<DebtCreateWithoutHouseholdInput, DebtUncheckedCreateWithoutHouseholdInput>
  }

  export type DebtUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: DebtWhereUniqueInput
    data: XOR<DebtUpdateWithoutHouseholdInput, DebtUncheckedUpdateWithoutHouseholdInput>
  }

  export type DebtUpdateManyWithWhereWithoutHouseholdInput = {
    where: DebtScalarWhereInput
    data: XOR<DebtUpdateManyMutationInput, DebtUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type DebtScalarWhereInput = {
    AND?: DebtScalarWhereInput | DebtScalarWhereInput[]
    OR?: DebtScalarWhereInput[]
    NOT?: DebtScalarWhereInput | DebtScalarWhereInput[]
    id?: UuidFilter<"Debt"> | string
    householdId?: UuidFilter<"Debt"> | string
    type?: EnumDebtTypeFilter<"Debt"> | $Enums.DebtType
    name?: StringFilter<"Debt"> | string
    creditor?: StringFilter<"Debt"> | string
    principalAmountCents?: BigIntFilter<"Debt"> | bigint | number
    currentBalanceCents?: BigIntFilter<"Debt"> | bigint | number
    currency?: StringFilter<"Debt"> | string
    interestRate?: DecimalNullableFilter<"Debt"> | Decimal | DecimalJsLike | number | string | null
    marginRate?: DecimalNullableFilter<"Debt"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFilter<"Debt"> | Date | string
    maturityDate?: DateTimeNullableFilter<"Debt"> | Date | string | null
    isActive?: BoolFilter<"Debt"> | boolean
    metadata?: JsonFilter<"Debt">
    createdAt?: DateTimeFilter<"Debt"> | Date | string
    updatedAt?: DateTimeFilter<"Debt"> | Date | string
  }

  export type BudgetUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutHouseholdInput, BudgetUncheckedUpdateWithoutHouseholdInput>
    create: XOR<BudgetCreateWithoutHouseholdInput, BudgetUncheckedCreateWithoutHouseholdInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutHouseholdInput, BudgetUncheckedUpdateWithoutHouseholdInput>
  }

  export type BudgetUpdateManyWithWhereWithoutHouseholdInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: UuidFilter<"Budget"> | string
    householdId?: UuidFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFilter<"Budget"> | bigint | number
    currency?: StringFilter<"Budget"> | string
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeFilter<"Budget"> | Date | string
    isActive?: BoolFilter<"Budget"> | boolean
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutHouseholdInput, WishlistItemUncheckedUpdateWithoutHouseholdInput>
    create: XOR<WishlistItemCreateWithoutHouseholdInput, WishlistItemUncheckedCreateWithoutHouseholdInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutHouseholdInput, WishlistItemUncheckedUpdateWithoutHouseholdInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutHouseholdInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type GratitudeEntryUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: GratitudeEntryWhereUniqueInput
    update: XOR<GratitudeEntryUpdateWithoutHouseholdInput, GratitudeEntryUncheckedUpdateWithoutHouseholdInput>
    create: XOR<GratitudeEntryCreateWithoutHouseholdInput, GratitudeEntryUncheckedCreateWithoutHouseholdInput>
  }

  export type GratitudeEntryUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: GratitudeEntryWhereUniqueInput
    data: XOR<GratitudeEntryUpdateWithoutHouseholdInput, GratitudeEntryUncheckedUpdateWithoutHouseholdInput>
  }

  export type GratitudeEntryUpdateManyWithWhereWithoutHouseholdInput = {
    where: GratitudeEntryScalarWhereInput
    data: XOR<GratitudeEntryUpdateManyMutationInput, GratitudeEntryUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type CategoryUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutHouseholdInput, CategoryUncheckedUpdateWithoutHouseholdInput>
    create: XOR<CategoryCreateWithoutHouseholdInput, CategoryUncheckedCreateWithoutHouseholdInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutHouseholdInput, CategoryUncheckedUpdateWithoutHouseholdInput>
  }

  export type CategoryUpdateManyWithWhereWithoutHouseholdInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: UuidFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    parentId?: UuidNullableFilter<"Category"> | string | null
    householdId?: UuidNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    isEditable?: BoolFilter<"Category"> | boolean
    isArchived?: BoolFilter<"Category"> | boolean
    sortOrder?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type RecurringTransactionUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: RecurringTransactionWhereUniqueInput
    update: XOR<RecurringTransactionUpdateWithoutHouseholdInput, RecurringTransactionUncheckedUpdateWithoutHouseholdInput>
    create: XOR<RecurringTransactionCreateWithoutHouseholdInput, RecurringTransactionUncheckedCreateWithoutHouseholdInput>
  }

  export type RecurringTransactionUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: RecurringTransactionWhereUniqueInput
    data: XOR<RecurringTransactionUpdateWithoutHouseholdInput, RecurringTransactionUncheckedUpdateWithoutHouseholdInput>
  }

  export type RecurringTransactionUpdateManyWithWhereWithoutHouseholdInput = {
    where: RecurringTransactionScalarWhereInput
    data: XOR<RecurringTransactionUpdateManyMutationInput, RecurringTransactionUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type DocumentUploadUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: DocumentUploadWhereUniqueInput
    update: XOR<DocumentUploadUpdateWithoutHouseholdInput, DocumentUploadUncheckedUpdateWithoutHouseholdInput>
    create: XOR<DocumentUploadCreateWithoutHouseholdInput, DocumentUploadUncheckedCreateWithoutHouseholdInput>
  }

  export type DocumentUploadUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: DocumentUploadWhereUniqueInput
    data: XOR<DocumentUploadUpdateWithoutHouseholdInput, DocumentUploadUncheckedUpdateWithoutHouseholdInput>
  }

  export type DocumentUploadUpdateManyWithWhereWithoutHouseholdInput = {
    where: DocumentUploadScalarWhereInput
    data: XOR<DocumentUploadUpdateManyMutationInput, DocumentUploadUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type UserEventUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: UserEventWhereUniqueInput
    update: XOR<UserEventUpdateWithoutHouseholdInput, UserEventUncheckedUpdateWithoutHouseholdInput>
    create: XOR<UserEventCreateWithoutHouseholdInput, UserEventUncheckedCreateWithoutHouseholdInput>
  }

  export type UserEventUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: UserEventWhereUniqueInput
    data: XOR<UserEventUpdateWithoutHouseholdInput, UserEventUncheckedUpdateWithoutHouseholdInput>
  }

  export type UserEventUpdateManyWithWhereWithoutHouseholdInput = {
    where: UserEventScalarWhereInput
    data: XOR<UserEventUpdateManyMutationInput, UserEventUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type SpendingPatternUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: SpendingPatternWhereUniqueInput
    update: XOR<SpendingPatternUpdateWithoutHouseholdInput, SpendingPatternUncheckedUpdateWithoutHouseholdInput>
    create: XOR<SpendingPatternCreateWithoutHouseholdInput, SpendingPatternUncheckedCreateWithoutHouseholdInput>
  }

  export type SpendingPatternUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: SpendingPatternWhereUniqueInput
    data: XOR<SpendingPatternUpdateWithoutHouseholdInput, SpendingPatternUncheckedUpdateWithoutHouseholdInput>
  }

  export type SpendingPatternUpdateManyWithWhereWithoutHouseholdInput = {
    where: SpendingPatternScalarWhereInput
    data: XOR<SpendingPatternUpdateManyMutationInput, SpendingPatternUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type SpendingPatternScalarWhereInput = {
    AND?: SpendingPatternScalarWhereInput | SpendingPatternScalarWhereInput[]
    OR?: SpendingPatternScalarWhereInput[]
    NOT?: SpendingPatternScalarWhereInput | SpendingPatternScalarWhereInput[]
    id?: UuidFilter<"SpendingPattern"> | string
    householdId?: UuidFilter<"SpendingPattern"> | string
    userId?: UuidNullableFilter<"SpendingPattern"> | string | null
    patternType?: StringFilter<"SpendingPattern"> | string
    categoryId?: UuidNullableFilter<"SpendingPattern"> | string | null
    merchant?: StringNullableFilter<"SpendingPattern"> | string | null
    dayOfWeek?: IntNullableFilter<"SpendingPattern"> | number | null
    hourOfDay?: IntNullableFilter<"SpendingPattern"> | number | null
    month?: IntNullableFilter<"SpendingPattern"> | number | null
    averageAmountCents?: BigIntFilter<"SpendingPattern"> | bigint | number
    frequency?: IntFilter<"SpendingPattern"> | number
    confidenceScore?: DecimalFilter<"SpendingPattern"> | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFilter<"SpendingPattern"> | Date | string
  }

  export type FinancialInsightUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: FinancialInsightWhereUniqueInput
    update: XOR<FinancialInsightUpdateWithoutHouseholdInput, FinancialInsightUncheckedUpdateWithoutHouseholdInput>
    create: XOR<FinancialInsightCreateWithoutHouseholdInput, FinancialInsightUncheckedCreateWithoutHouseholdInput>
  }

  export type FinancialInsightUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: FinancialInsightWhereUniqueInput
    data: XOR<FinancialInsightUpdateWithoutHouseholdInput, FinancialInsightUncheckedUpdateWithoutHouseholdInput>
  }

  export type FinancialInsightUpdateManyWithWhereWithoutHouseholdInput = {
    where: FinancialInsightScalarWhereInput
    data: XOR<FinancialInsightUpdateManyMutationInput, FinancialInsightUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type FinancialInsightScalarWhereInput = {
    AND?: FinancialInsightScalarWhereInput | FinancialInsightScalarWhereInput[]
    OR?: FinancialInsightScalarWhereInput[]
    NOT?: FinancialInsightScalarWhereInput | FinancialInsightScalarWhereInput[]
    id?: UuidFilter<"FinancialInsight"> | string
    householdId?: UuidFilter<"FinancialInsight"> | string
    insightType?: StringFilter<"FinancialInsight"> | string
    title?: StringFilter<"FinancialInsight"> | string
    description?: StringFilter<"FinancialInsight"> | string
    data?: JsonFilter<"FinancialInsight">
    priority?: EnumInsightPriorityFilter<"FinancialInsight"> | $Enums.InsightPriority
    isActionable?: BoolFilter<"FinancialInsight"> | boolean
    isDismissed?: BoolFilter<"FinancialInsight"> | boolean
    validUntil?: DateTimeNullableFilter<"FinancialInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"FinancialInsight"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialInsight"> | Date | string
  }

  export type ZakatCalculationUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: ZakatCalculationWhereUniqueInput
    update: XOR<ZakatCalculationUpdateWithoutHouseholdInput, ZakatCalculationUncheckedUpdateWithoutHouseholdInput>
    create: XOR<ZakatCalculationCreateWithoutHouseholdInput, ZakatCalculationUncheckedCreateWithoutHouseholdInput>
  }

  export type ZakatCalculationUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: ZakatCalculationWhereUniqueInput
    data: XOR<ZakatCalculationUpdateWithoutHouseholdInput, ZakatCalculationUncheckedUpdateWithoutHouseholdInput>
  }

  export type ZakatCalculationUpdateManyWithWhereWithoutHouseholdInput = {
    where: ZakatCalculationScalarWhereInput
    data: XOR<ZakatCalculationUpdateManyMutationInput, ZakatCalculationUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ZakatCalculationScalarWhereInput = {
    AND?: ZakatCalculationScalarWhereInput | ZakatCalculationScalarWhereInput[]
    OR?: ZakatCalculationScalarWhereInput[]
    NOT?: ZakatCalculationScalarWhereInput | ZakatCalculationScalarWhereInput[]
    id?: UuidFilter<"ZakatCalculation"> | string
    householdId?: UuidFilter<"ZakatCalculation"> | string
    calculationDate?: DateTimeFilter<"ZakatCalculation"> | Date | string
    hijriYear?: IntFilter<"ZakatCalculation"> | number
    nisabThresholdCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    totalZakatableAssetsCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    zakatAmountCents?: BigIntFilter<"ZakatCalculation"> | bigint | number
    currency?: StringFilter<"ZakatCalculation"> | string
    isZakatDue?: BoolFilter<"ZakatCalculation"> | boolean
    nextCalculationDate?: DateTimeFilter<"ZakatCalculation"> | Date | string
    metadata?: JsonFilter<"ZakatCalculation">
    createdAt?: DateTimeFilter<"ZakatCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"ZakatCalculation"> | Date | string
  }

  export type ZakatReminderUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: ZakatReminderWhereUniqueInput
    update: XOR<ZakatReminderUpdateWithoutHouseholdInput, ZakatReminderUncheckedUpdateWithoutHouseholdInput>
    create: XOR<ZakatReminderCreateWithoutHouseholdInput, ZakatReminderUncheckedCreateWithoutHouseholdInput>
  }

  export type ZakatReminderUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: ZakatReminderWhereUniqueInput
    data: XOR<ZakatReminderUpdateWithoutHouseholdInput, ZakatReminderUncheckedUpdateWithoutHouseholdInput>
  }

  export type ZakatReminderUpdateManyWithWhereWithoutHouseholdInput = {
    where: ZakatReminderScalarWhereInput
    data: XOR<ZakatReminderUpdateManyMutationInput, ZakatReminderUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ZakatReminderScalarWhereInput = {
    AND?: ZakatReminderScalarWhereInput | ZakatReminderScalarWhereInput[]
    OR?: ZakatReminderScalarWhereInput[]
    NOT?: ZakatReminderScalarWhereInput | ZakatReminderScalarWhereInput[]
    id?: UuidFilter<"ZakatReminder"> | string
    householdId?: UuidFilter<"ZakatReminder"> | string
    reminderType?: EnumZakatReminderTypeFilter<"ZakatReminder"> | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFilter<"ZakatReminder"> | Date | string
    hijriDate?: StringFilter<"ZakatReminder"> | string
    zakatAmountCents?: BigIntNullableFilter<"ZakatReminder"> | bigint | number | null
    currency?: StringNullableFilter<"ZakatReminder"> | string | null
    message?: StringFilter<"ZakatReminder"> | string
    isActive?: BoolFilter<"ZakatReminder"> | boolean
    isSent?: BoolFilter<"ZakatReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"ZakatReminder"> | Date | string | null
    metadata?: JsonFilter<"ZakatReminder">
    createdAt?: DateTimeFilter<"ZakatReminder"> | Date | string
    updatedAt?: DateTimeFilter<"ZakatReminder"> | Date | string
  }

  export type ZakatPaymentUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: ZakatPaymentWhereUniqueInput
    update: XOR<ZakatPaymentUpdateWithoutHouseholdInput, ZakatPaymentUncheckedUpdateWithoutHouseholdInput>
    create: XOR<ZakatPaymentCreateWithoutHouseholdInput, ZakatPaymentUncheckedCreateWithoutHouseholdInput>
  }

  export type ZakatPaymentUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: ZakatPaymentWhereUniqueInput
    data: XOR<ZakatPaymentUpdateWithoutHouseholdInput, ZakatPaymentUncheckedUpdateWithoutHouseholdInput>
  }

  export type ZakatPaymentUpdateManyWithWhereWithoutHouseholdInput = {
    where: ZakatPaymentScalarWhereInput
    data: XOR<ZakatPaymentUpdateManyMutationInput, ZakatPaymentUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ZakatPaymentScalarWhereInput = {
    AND?: ZakatPaymentScalarWhereInput | ZakatPaymentScalarWhereInput[]
    OR?: ZakatPaymentScalarWhereInput[]
    NOT?: ZakatPaymentScalarWhereInput | ZakatPaymentScalarWhereInput[]
    id?: UuidFilter<"ZakatPayment"> | string
    zakatCalculationId?: UuidNullableFilter<"ZakatPayment"> | string | null
    householdId?: UuidFilter<"ZakatPayment"> | string
    amountCents?: BigIntFilter<"ZakatPayment"> | bigint | number
    currency?: StringFilter<"ZakatPayment"> | string
    paymentDate?: DateTimeFilter<"ZakatPayment"> | Date | string
    hijriDate?: StringFilter<"ZakatPayment"> | string
    transactionId?: UuidNullableFilter<"ZakatPayment"> | string | null
    notes?: StringNullableFilter<"ZakatPayment"> | string | null
    metadata?: JsonFilter<"ZakatPayment">
    createdAt?: DateTimeFilter<"ZakatPayment"> | Date | string
  }

  export type IslamicFinanceReportUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: IslamicFinanceReportWhereUniqueInput
    update: XOR<IslamicFinanceReportUpdateWithoutHouseholdInput, IslamicFinanceReportUncheckedUpdateWithoutHouseholdInput>
    create: XOR<IslamicFinanceReportCreateWithoutHouseholdInput, IslamicFinanceReportUncheckedCreateWithoutHouseholdInput>
  }

  export type IslamicFinanceReportUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: IslamicFinanceReportWhereUniqueInput
    data: XOR<IslamicFinanceReportUpdateWithoutHouseholdInput, IslamicFinanceReportUncheckedUpdateWithoutHouseholdInput>
  }

  export type IslamicFinanceReportUpdateManyWithWhereWithoutHouseholdInput = {
    where: IslamicFinanceReportScalarWhereInput
    data: XOR<IslamicFinanceReportUpdateManyMutationInput, IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutHouseholdInput, NotificationUncheckedUpdateWithoutHouseholdInput>
    create: XOR<NotificationCreateWithoutHouseholdInput, NotificationUncheckedCreateWithoutHouseholdInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutHouseholdInput, NotificationUncheckedUpdateWithoutHouseholdInput>
  }

  export type NotificationUpdateManyWithWhereWithoutHouseholdInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type UserCreateWithoutHouseholdMembersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHouseholdMembersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHouseholdMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHouseholdMembersInput, UserUncheckedCreateWithoutHouseholdMembersInput>
  }

  export type HouseholdCreateWithoutMembersInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutMembersInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutMembersInput, HouseholdUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutHouseholdMembersInput = {
    update: XOR<UserUpdateWithoutHouseholdMembersInput, UserUncheckedUpdateWithoutHouseholdMembersInput>
    create: XOR<UserCreateWithoutHouseholdMembersInput, UserUncheckedCreateWithoutHouseholdMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHouseholdMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHouseholdMembersInput, UserUncheckedUpdateWithoutHouseholdMembersInput>
  }

  export type UserUpdateWithoutHouseholdMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHouseholdMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdUpsertWithoutMembersInput = {
    update: XOR<HouseholdUpdateWithoutMembersInput, HouseholdUncheckedUpdateWithoutMembersInput>
    create: XOR<HouseholdCreateWithoutMembersInput, HouseholdUncheckedCreateWithoutMembersInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutMembersInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutMembersInput, HouseholdUncheckedUpdateWithoutMembersInput>
  }

  export type HouseholdUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type AccountCreateWithoutInstitutionInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutInstitutionInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutInstitutionInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutInstitutionInput, AccountUncheckedCreateWithoutInstitutionInput>
  }

  export type AccountCreateManyInstitutionInputEnvelope = {
    data: AccountCreateManyInstitutionInput | AccountCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutInstitutionInput, AccountUncheckedUpdateWithoutInstitutionInput>
    create: XOR<AccountCreateWithoutInstitutionInput, AccountUncheckedCreateWithoutInstitutionInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutInstitutionInput, AccountUncheckedUpdateWithoutInstitutionInput>
  }

  export type AccountUpdateManyWithWhereWithoutInstitutionInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type HouseholdCreateWithoutAccountsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutAccountsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutAccountsInput, HouseholdUncheckedCreateWithoutAccountsInput>
  }

  export type InstitutionCreateWithoutAccountsInput = {
    id?: string
    name: string
    code?: string | null
    logoUrl?: string | null
    country?: string
    type: $Enums.InstitutionType
    createdAt?: Date | string
  }

  export type InstitutionUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    code?: string | null
    logoUrl?: string | null
    country?: string
    type: $Enums.InstitutionType
    createdAt?: Date | string
  }

  export type InstitutionCreateOrConnectWithoutAccountsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutAccountsInput, InstitutionUncheckedCreateWithoutAccountsInput>
  }

  export type TransactionCreateWithoutAccountInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateManyAccountInputEnvelope = {
    data: TransactionCreateManyAccountInput | TransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutTransferAccountInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutTransferAccountInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutTransferAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTransferAccountInput, TransactionUncheckedCreateWithoutTransferAccountInput>
  }

  export type TransactionCreateManyTransferAccountInputEnvelope = {
    data: TransactionCreateManyTransferAccountInput | TransactionCreateManyTransferAccountInput[]
    skipDuplicates?: boolean
  }

  export type RecurringTransactionCreateWithoutAccountInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutRecurringTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutRecurringTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutRecurringTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedRecurringTransactionsInput
    executions?: RecurringTransactionExecutionCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionCreateOrConnectWithoutAccountInput = {
    where: RecurringTransactionWhereUniqueInput
    create: XOR<RecurringTransactionCreateWithoutAccountInput, RecurringTransactionUncheckedCreateWithoutAccountInput>
  }

  export type RecurringTransactionCreateManyAccountInputEnvelope = {
    data: RecurringTransactionCreateManyAccountInput | RecurringTransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type RecurringTransactionCreateWithoutTransferAccountInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutRecurringTransactionsInput
    account: AccountCreateNestedOneWithoutRecurringTransactionsInput
    category?: CategoryCreateNestedOneWithoutRecurringTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedRecurringTransactionsInput
    executions?: RecurringTransactionExecutionCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionUncheckedCreateWithoutTransferAccountInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionCreateOrConnectWithoutTransferAccountInput = {
    where: RecurringTransactionWhereUniqueInput
    create: XOR<RecurringTransactionCreateWithoutTransferAccountInput, RecurringTransactionUncheckedCreateWithoutTransferAccountInput>
  }

  export type RecurringTransactionCreateManyTransferAccountInputEnvelope = {
    data: RecurringTransactionCreateManyTransferAccountInput | RecurringTransactionCreateManyTransferAccountInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutAccountInput = {
    id?: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutAccountInput = {
    id?: string
    transactionId: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutAccountInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput>
  }

  export type LedgerEntryCreateManyAccountInputEnvelope = {
    data: LedgerEntryCreateManyAccountInput | LedgerEntryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ZakatAssetBreakdownCreateWithoutAccountInput = {
    id?: string
    assetType: $Enums.ZakatAssetType
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    zakatCalculation: ZakatCalculationCreateNestedOneWithoutAssetBreakdownInput
  }

  export type ZakatAssetBreakdownUncheckedCreateWithoutAccountInput = {
    id?: string
    zakatCalculationId: string
    assetType: $Enums.ZakatAssetType
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatAssetBreakdownCreateOrConnectWithoutAccountInput = {
    where: ZakatAssetBreakdownWhereUniqueInput
    create: XOR<ZakatAssetBreakdownCreateWithoutAccountInput, ZakatAssetBreakdownUncheckedCreateWithoutAccountInput>
  }

  export type ZakatAssetBreakdownCreateManyAccountInputEnvelope = {
    data: ZakatAssetBreakdownCreateManyAccountInput | ZakatAssetBreakdownCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ShariaCompliantAccountCreateWithoutAccountInput = {
    id?: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes?: string | null
    lastReviewDate: Date | string
    nextReviewDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer?: UserCreateNestedOneWithoutShariaReviewsInput
  }

  export type ShariaCompliantAccountUncheckedCreateWithoutAccountInput = {
    id?: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes?: string | null
    lastReviewDate: Date | string
    nextReviewDate: Date | string
    reviewedBy?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShariaCompliantAccountCreateOrConnectWithoutAccountInput = {
    where: ShariaCompliantAccountWhereUniqueInput
    create: XOR<ShariaCompliantAccountCreateWithoutAccountInput, ShariaCompliantAccountUncheckedCreateWithoutAccountInput>
  }

  export type HouseholdUpsertWithoutAccountsInput = {
    update: XOR<HouseholdUpdateWithoutAccountsInput, HouseholdUncheckedUpdateWithoutAccountsInput>
    create: XOR<HouseholdCreateWithoutAccountsInput, HouseholdUncheckedCreateWithoutAccountsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutAccountsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutAccountsInput, HouseholdUncheckedUpdateWithoutAccountsInput>
  }

  export type HouseholdUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type InstitutionUpsertWithoutAccountsInput = {
    update: XOR<InstitutionUpdateWithoutAccountsInput, InstitutionUncheckedUpdateWithoutAccountsInput>
    create: XOR<InstitutionCreateWithoutAccountsInput, InstitutionUncheckedCreateWithoutAccountsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutAccountsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutAccountsInput, InstitutionUncheckedUpdateWithoutAccountsInput>
  }

  export type InstitutionUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutTransferAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTransferAccountInput, TransactionUncheckedUpdateWithoutTransferAccountInput>
    create: XOR<TransactionCreateWithoutTransferAccountInput, TransactionUncheckedCreateWithoutTransferAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTransferAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTransferAccountInput, TransactionUncheckedUpdateWithoutTransferAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTransferAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransferAccountInput>
  }

  export type RecurringTransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: RecurringTransactionWhereUniqueInput
    update: XOR<RecurringTransactionUpdateWithoutAccountInput, RecurringTransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<RecurringTransactionCreateWithoutAccountInput, RecurringTransactionUncheckedCreateWithoutAccountInput>
  }

  export type RecurringTransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: RecurringTransactionWhereUniqueInput
    data: XOR<RecurringTransactionUpdateWithoutAccountInput, RecurringTransactionUncheckedUpdateWithoutAccountInput>
  }

  export type RecurringTransactionUpdateManyWithWhereWithoutAccountInput = {
    where: RecurringTransactionScalarWhereInput
    data: XOR<RecurringTransactionUpdateManyMutationInput, RecurringTransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type RecurringTransactionUpsertWithWhereUniqueWithoutTransferAccountInput = {
    where: RecurringTransactionWhereUniqueInput
    update: XOR<RecurringTransactionUpdateWithoutTransferAccountInput, RecurringTransactionUncheckedUpdateWithoutTransferAccountInput>
    create: XOR<RecurringTransactionCreateWithoutTransferAccountInput, RecurringTransactionUncheckedCreateWithoutTransferAccountInput>
  }

  export type RecurringTransactionUpdateWithWhereUniqueWithoutTransferAccountInput = {
    where: RecurringTransactionWhereUniqueInput
    data: XOR<RecurringTransactionUpdateWithoutTransferAccountInput, RecurringTransactionUncheckedUpdateWithoutTransferAccountInput>
  }

  export type RecurringTransactionUpdateManyWithWhereWithoutTransferAccountInput = {
    where: RecurringTransactionScalarWhereInput
    data: XOR<RecurringTransactionUpdateManyMutationInput, RecurringTransactionUncheckedUpdateManyWithoutTransferAccountInput>
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutAccountInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutAccountInput, LedgerEntryUncheckedUpdateWithoutAccountInput>
    create: XOR<LedgerEntryCreateWithoutAccountInput, LedgerEntryUncheckedCreateWithoutAccountInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutAccountInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutAccountInput, LedgerEntryUncheckedUpdateWithoutAccountInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutAccountInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutAccountInput>
  }

  export type LedgerEntryScalarWhereInput = {
    AND?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    OR?: LedgerEntryScalarWhereInput[]
    NOT?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    id?: UuidFilter<"LedgerEntry"> | string
    transactionId?: UuidFilter<"LedgerEntry"> | string
    accountId?: UuidFilter<"LedgerEntry"> | string
    type?: EnumLedgerTypeFilter<"LedgerEntry"> | $Enums.LedgerType
    amountCents?: BigIntFilter<"LedgerEntry"> | bigint | number
    currency?: StringFilter<"LedgerEntry"> | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
  }

  export type ZakatAssetBreakdownUpsertWithWhereUniqueWithoutAccountInput = {
    where: ZakatAssetBreakdownWhereUniqueInput
    update: XOR<ZakatAssetBreakdownUpdateWithoutAccountInput, ZakatAssetBreakdownUncheckedUpdateWithoutAccountInput>
    create: XOR<ZakatAssetBreakdownCreateWithoutAccountInput, ZakatAssetBreakdownUncheckedCreateWithoutAccountInput>
  }

  export type ZakatAssetBreakdownUpdateWithWhereUniqueWithoutAccountInput = {
    where: ZakatAssetBreakdownWhereUniqueInput
    data: XOR<ZakatAssetBreakdownUpdateWithoutAccountInput, ZakatAssetBreakdownUncheckedUpdateWithoutAccountInput>
  }

  export type ZakatAssetBreakdownUpdateManyWithWhereWithoutAccountInput = {
    where: ZakatAssetBreakdownScalarWhereInput
    data: XOR<ZakatAssetBreakdownUpdateManyMutationInput, ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountInput>
  }

  export type ZakatAssetBreakdownScalarWhereInput = {
    AND?: ZakatAssetBreakdownScalarWhereInput | ZakatAssetBreakdownScalarWhereInput[]
    OR?: ZakatAssetBreakdownScalarWhereInput[]
    NOT?: ZakatAssetBreakdownScalarWhereInput | ZakatAssetBreakdownScalarWhereInput[]
    id?: UuidFilter<"ZakatAssetBreakdown"> | string
    zakatCalculationId?: UuidFilter<"ZakatAssetBreakdown"> | string
    assetType?: EnumZakatAssetTypeFilter<"ZakatAssetBreakdown"> | $Enums.ZakatAssetType
    accountId?: UuidNullableFilter<"ZakatAssetBreakdown"> | string | null
    accountName?: StringNullableFilter<"ZakatAssetBreakdown"> | string | null
    amountCents?: BigIntFilter<"ZakatAssetBreakdown"> | bigint | number
    currency?: StringFilter<"ZakatAssetBreakdown"> | string
    zakatRate?: DecimalFilter<"ZakatAssetBreakdown"> | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFilter<"ZakatAssetBreakdown"> | bigint | number
    haulCompleted?: BoolFilter<"ZakatAssetBreakdown"> | boolean
    haulStartDate?: DateTimeNullableFilter<"ZakatAssetBreakdown"> | Date | string | null
    metadata?: JsonFilter<"ZakatAssetBreakdown">
    createdAt?: DateTimeFilter<"ZakatAssetBreakdown"> | Date | string
  }

  export type ShariaCompliantAccountUpsertWithoutAccountInput = {
    update: XOR<ShariaCompliantAccountUpdateWithoutAccountInput, ShariaCompliantAccountUncheckedUpdateWithoutAccountInput>
    create: XOR<ShariaCompliantAccountCreateWithoutAccountInput, ShariaCompliantAccountUncheckedCreateWithoutAccountInput>
    where?: ShariaCompliantAccountWhereInput
  }

  export type ShariaCompliantAccountUpdateToOneWithWhereWithoutAccountInput = {
    where?: ShariaCompliantAccountWhereInput
    data: XOR<ShariaCompliantAccountUpdateWithoutAccountInput, ShariaCompliantAccountUncheckedUpdateWithoutAccountInput>
  }

  export type ShariaCompliantAccountUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneWithoutShariaReviewsNestedInput
  }

  export type ShariaCompliantAccountUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateWithoutMerchantDataInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutMerchantDataInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutMerchantDataInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutMerchantDataInput, TransactionUncheckedCreateWithoutMerchantDataInput>
  }

  export type TransactionCreateManyMerchantDataInputEnvelope = {
    data: TransactionCreateManyMerchantDataInput | TransactionCreateManyMerchantDataInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutMerchantDataInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutMerchantDataInput, TransactionUncheckedUpdateWithoutMerchantDataInput>
    create: XOR<TransactionCreateWithoutMerchantDataInput, TransactionUncheckedCreateWithoutMerchantDataInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutMerchantDataInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutMerchantDataInput, TransactionUncheckedUpdateWithoutMerchantDataInput>
  }

  export type TransactionUpdateManyWithWhereWithoutMerchantDataInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutMerchantDataInput>
  }

  export type HouseholdCreateWithoutCategoriesInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutCategoriesInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutCategoriesInput, HouseholdUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCategoryInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCategoryInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionCreateManyCategoryInputEnvelope = {
    data: TransactionCreateManyCategoryInput | TransactionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type TransactionSplitCreateWithoutCategoryInput = {
    id?: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutSplitsInput
  }

  export type TransactionSplitUncheckedCreateWithoutCategoryInput = {
    id?: string
    transactionId: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionSplitCreateOrConnectWithoutCategoryInput = {
    where: TransactionSplitWhereUniqueInput
    create: XOR<TransactionSplitCreateWithoutCategoryInput, TransactionSplitUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionSplitCreateManyCategoryInputEnvelope = {
    data: TransactionSplitCreateManyCategoryInput | TransactionSplitCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BudgetCategoryCreateWithoutCategoryInput = {
    id?: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    budget: BudgetCreateNestedOneWithoutCategoriesInput
  }

  export type BudgetCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    budgetId: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCategoryCreateOrConnectWithoutCategoryInput = {
    where: BudgetCategoryWhereUniqueInput
    create: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type BudgetCategoryCreateManyCategoryInputEnvelope = {
    data: BudgetCategoryCreateManyCategoryInput | BudgetCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type RecurringTransactionCreateWithoutCategoryInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutRecurringTransactionsInput
    account: AccountCreateNestedOneWithoutRecurringTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutRecurringTransferTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedRecurringTransactionsInput
    executions?: RecurringTransactionExecutionCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionUncheckedCreateWithoutCategoryInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutRecurringTransactionInput
  }

  export type RecurringTransactionCreateOrConnectWithoutCategoryInput = {
    where: RecurringTransactionWhereUniqueInput
    create: XOR<RecurringTransactionCreateWithoutCategoryInput, RecurringTransactionUncheckedCreateWithoutCategoryInput>
  }

  export type RecurringTransactionCreateManyCategoryInputEnvelope = {
    data: RecurringTransactionCreateManyCategoryInput | RecurringTransactionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type GratitudeEntryCreateWithoutCategoryInput = {
    id?: string
    giver: string
    type: $Enums.GratitudeType
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdAt?: Date | string
    household: HouseholdCreateNestedOneWithoutGratitudeEntriesInput
    transaction?: TransactionCreateNestedOneWithoutGratitudeEntriesInput
    creator: UserCreateNestedOneWithoutCreatedGratitudeEntriesInput
  }

  export type GratitudeEntryUncheckedCreateWithoutCategoryInput = {
    id?: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    transactionId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdBy: string
    createdAt?: Date | string
  }

  export type GratitudeEntryCreateOrConnectWithoutCategoryInput = {
    where: GratitudeEntryWhereUniqueInput
    create: XOR<GratitudeEntryCreateWithoutCategoryInput, GratitudeEntryUncheckedCreateWithoutCategoryInput>
  }

  export type GratitudeEntryCreateManyCategoryInputEnvelope = {
    data: GratitudeEntryCreateManyCategoryInput | GratitudeEntryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type TransactionSuggestionCreateWithoutSuggestedCategoryInput = {
    id?: string
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentUploadCreateNestedOneWithoutTransactionSuggestionsInput
    ocrResult?: OcrResultCreateNestedOneWithoutTransactionSuggestionsInput
    createdTransaction?: TransactionCreateNestedOneWithoutCreatedFromSuggestionInput
  }

  export type TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput = {
    id?: string
    documentId: string
    ocrResultId?: string | null
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionSuggestionCreateOrConnectWithoutSuggestedCategoryInput = {
    where: TransactionSuggestionWhereUniqueInput
    create: XOR<TransactionSuggestionCreateWithoutSuggestedCategoryInput, TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput>
  }

  export type TransactionSuggestionCreateManySuggestedCategoryInputEnvelope = {
    data: TransactionSuggestionCreateManySuggestedCategoryInput | TransactionSuggestionCreateManySuggestedCategoryInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutCategoriesInput = {
    update: XOR<HouseholdUpdateWithoutCategoriesInput, HouseholdUncheckedUpdateWithoutCategoriesInput>
    create: XOR<HouseholdCreateWithoutCategoriesInput, HouseholdUncheckedCreateWithoutCategoriesInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutCategoriesInput, HouseholdUncheckedUpdateWithoutCategoriesInput>
  }

  export type HouseholdUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCategoryInput, TransactionUncheckedUpdateWithoutCategoryInput>
    create: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCategoryInput, TransactionUncheckedUpdateWithoutCategoryInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCategoryInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TransactionSplitUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TransactionSplitWhereUniqueInput
    update: XOR<TransactionSplitUpdateWithoutCategoryInput, TransactionSplitUncheckedUpdateWithoutCategoryInput>
    create: XOR<TransactionSplitCreateWithoutCategoryInput, TransactionSplitUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionSplitUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TransactionSplitWhereUniqueInput
    data: XOR<TransactionSplitUpdateWithoutCategoryInput, TransactionSplitUncheckedUpdateWithoutCategoryInput>
  }

  export type TransactionSplitUpdateManyWithWhereWithoutCategoryInput = {
    where: TransactionSplitScalarWhereInput
    data: XOR<TransactionSplitUpdateManyMutationInput, TransactionSplitUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TransactionSplitScalarWhereInput = {
    AND?: TransactionSplitScalarWhereInput | TransactionSplitScalarWhereInput[]
    OR?: TransactionSplitScalarWhereInput[]
    NOT?: TransactionSplitScalarWhereInput | TransactionSplitScalarWhereInput[]
    id?: UuidFilter<"TransactionSplit"> | string
    transactionId?: UuidFilter<"TransactionSplit"> | string
    categoryId?: UuidFilter<"TransactionSplit"> | string
    amountCents?: BigIntFilter<"TransactionSplit"> | bigint | number
    description?: StringNullableFilter<"TransactionSplit"> | string | null
    createdAt?: DateTimeFilter<"TransactionSplit"> | Date | string
  }

  export type BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BudgetCategoryWhereUniqueInput
    update: XOR<BudgetCategoryUpdateWithoutCategoryInput, BudgetCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BudgetCategoryWhereUniqueInput
    data: XOR<BudgetCategoryUpdateWithoutCategoryInput, BudgetCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type BudgetCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: BudgetCategoryScalarWhereInput
    data: XOR<BudgetCategoryUpdateManyMutationInput, BudgetCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BudgetCategoryScalarWhereInput = {
    AND?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
    OR?: BudgetCategoryScalarWhereInput[]
    NOT?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
    id?: UuidFilter<"BudgetCategory"> | string
    budgetId?: UuidFilter<"BudgetCategory"> | string
    categoryId?: UuidFilter<"BudgetCategory"> | string
    allocatedAmountCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    spentAmountCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    carryOverCents?: BigIntFilter<"BudgetCategory"> | bigint | number
    createdAt?: DateTimeFilter<"BudgetCategory"> | Date | string
    updatedAt?: DateTimeFilter<"BudgetCategory"> | Date | string
  }

  export type RecurringTransactionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: RecurringTransactionWhereUniqueInput
    update: XOR<RecurringTransactionUpdateWithoutCategoryInput, RecurringTransactionUncheckedUpdateWithoutCategoryInput>
    create: XOR<RecurringTransactionCreateWithoutCategoryInput, RecurringTransactionUncheckedCreateWithoutCategoryInput>
  }

  export type RecurringTransactionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: RecurringTransactionWhereUniqueInput
    data: XOR<RecurringTransactionUpdateWithoutCategoryInput, RecurringTransactionUncheckedUpdateWithoutCategoryInput>
  }

  export type RecurringTransactionUpdateManyWithWhereWithoutCategoryInput = {
    where: RecurringTransactionScalarWhereInput
    data: XOR<RecurringTransactionUpdateManyMutationInput, RecurringTransactionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type GratitudeEntryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: GratitudeEntryWhereUniqueInput
    update: XOR<GratitudeEntryUpdateWithoutCategoryInput, GratitudeEntryUncheckedUpdateWithoutCategoryInput>
    create: XOR<GratitudeEntryCreateWithoutCategoryInput, GratitudeEntryUncheckedCreateWithoutCategoryInput>
  }

  export type GratitudeEntryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: GratitudeEntryWhereUniqueInput
    data: XOR<GratitudeEntryUpdateWithoutCategoryInput, GratitudeEntryUncheckedUpdateWithoutCategoryInput>
  }

  export type GratitudeEntryUpdateManyWithWhereWithoutCategoryInput = {
    where: GratitudeEntryScalarWhereInput
    data: XOR<GratitudeEntryUpdateManyMutationInput, GratitudeEntryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TransactionSuggestionUpsertWithWhereUniqueWithoutSuggestedCategoryInput = {
    where: TransactionSuggestionWhereUniqueInput
    update: XOR<TransactionSuggestionUpdateWithoutSuggestedCategoryInput, TransactionSuggestionUncheckedUpdateWithoutSuggestedCategoryInput>
    create: XOR<TransactionSuggestionCreateWithoutSuggestedCategoryInput, TransactionSuggestionUncheckedCreateWithoutSuggestedCategoryInput>
  }

  export type TransactionSuggestionUpdateWithWhereUniqueWithoutSuggestedCategoryInput = {
    where: TransactionSuggestionWhereUniqueInput
    data: XOR<TransactionSuggestionUpdateWithoutSuggestedCategoryInput, TransactionSuggestionUncheckedUpdateWithoutSuggestedCategoryInput>
  }

  export type TransactionSuggestionUpdateManyWithWhereWithoutSuggestedCategoryInput = {
    where: TransactionSuggestionScalarWhereInput
    data: XOR<TransactionSuggestionUpdateManyMutationInput, TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryInput>
  }

  export type TransactionSuggestionScalarWhereInput = {
    AND?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
    OR?: TransactionSuggestionScalarWhereInput[]
    NOT?: TransactionSuggestionScalarWhereInput | TransactionSuggestionScalarWhereInput[]
    id?: UuidFilter<"TransactionSuggestion"> | string
    documentId?: UuidFilter<"TransactionSuggestion"> | string
    ocrResultId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    description?: StringFilter<"TransactionSuggestion"> | string
    amountCents?: BigIntFilter<"TransactionSuggestion"> | bigint | number
    currency?: StringFilter<"TransactionSuggestion"> | string
    date?: DateTimeFilter<"TransactionSuggestion"> | Date | string
    merchant?: StringNullableFilter<"TransactionSuggestion"> | string | null
    suggestedCategoryId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    suggestedCategoryName?: StringNullableFilter<"TransactionSuggestion"> | string | null
    confidence?: DecimalFilter<"TransactionSuggestion"> | Decimal | DecimalJsLike | number | string
    source?: StringFilter<"TransactionSuggestion"> | string
    status?: StringFilter<"TransactionSuggestion"> | string
    isApproved?: BoolFilter<"TransactionSuggestion"> | boolean
    approvedAt?: DateTimeNullableFilter<"TransactionSuggestion"> | Date | string | null
    metadata?: JsonFilter<"TransactionSuggestion">
    createdTransactionId?: UuidNullableFilter<"TransactionSuggestion"> | string | null
    createdAt?: DateTimeFilter<"TransactionSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionSuggestion"> | Date | string
  }

  export type HouseholdCreateWithoutTransactionsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutTransactionsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutTransactionsInput, HouseholdUncheckedCreateWithoutTransactionsInput>
  }

  export type AccountCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
  }

  export type AccountCreateWithoutTransferTransactionsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutTransferTransactionsInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutTransferTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTransferTransactionsInput, AccountUncheckedCreateWithoutTransferTransactionsInput>
  }

  export type CategoryCreateWithoutTransactionsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTransactionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
  }

  export type MerchantCreateWithoutTransactionsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    color?: string | null
    createdAt?: Date | string
  }

  export type MerchantUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    color?: string | null
    createdAt?: Date | string
  }

  export type MerchantCreateOrConnectWithoutTransactionsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutTransactionsInput, MerchantUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutCreatedTransactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTransactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
  }

  export type TransactionTagCreateWithoutTransactionInput = {
    tag: string
  }

  export type TransactionTagUncheckedCreateWithoutTransactionInput = {
    tag: string
  }

  export type TransactionTagCreateOrConnectWithoutTransactionInput = {
    where: TransactionTagWhereUniqueInput
    create: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionTagCreateManyTransactionInputEnvelope = {
    data: TransactionTagCreateManyTransactionInput | TransactionTagCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type TransactionSplitCreateWithoutTransactionInput = {
    id?: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
    category: CategoryCreateNestedOneWithoutTransactionSplitsInput
  }

  export type TransactionSplitUncheckedCreateWithoutTransactionInput = {
    id?: string
    categoryId: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionSplitCreateOrConnectWithoutTransactionInput = {
    where: TransactionSplitWhereUniqueInput
    create: XOR<TransactionSplitCreateWithoutTransactionInput, TransactionSplitUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionSplitCreateManyTransactionInputEnvelope = {
    data: TransactionSplitCreateManyTransactionInput | TransactionSplitCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutTransactionInput = {
    id?: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutTransactionInput = {
    id?: string
    accountId: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerEntryCreateManyTransactionInputEnvelope = {
    data: LedgerEntryCreateManyTransactionInput | LedgerEntryCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type RecurringTransactionExecutionCreateWithoutTransactionInput = {
    id?: string
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    recurringTransaction: RecurringTransactionCreateNestedOneWithoutExecutionsInput
  }

  export type RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput = {
    id?: string
    recurringTransactionId: string
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionExecutionCreateOrConnectWithoutTransactionInput = {
    where: RecurringTransactionExecutionWhereUniqueInput
    create: XOR<RecurringTransactionExecutionCreateWithoutTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput>
  }

  export type RecurringTransactionExecutionCreateManyTransactionInputEnvelope = {
    data: RecurringTransactionExecutionCreateManyTransactionInput | RecurringTransactionExecutionCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type GratitudeEntryCreateWithoutTransactionInput = {
    id?: string
    giver: string
    type: $Enums.GratitudeType
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdAt?: Date | string
    household: HouseholdCreateNestedOneWithoutGratitudeEntriesInput
    category?: CategoryCreateNestedOneWithoutGratitudeEntriesInput
    creator: UserCreateNestedOneWithoutCreatedGratitudeEntriesInput
  }

  export type GratitudeEntryUncheckedCreateWithoutTransactionInput = {
    id?: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    categoryId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdBy: string
    createdAt?: Date | string
  }

  export type GratitudeEntryCreateOrConnectWithoutTransactionInput = {
    where: GratitudeEntryWhereUniqueInput
    create: XOR<GratitudeEntryCreateWithoutTransactionInput, GratitudeEntryUncheckedCreateWithoutTransactionInput>
  }

  export type GratitudeEntryCreateManyTransactionInputEnvelope = {
    data: GratitudeEntryCreateManyTransactionInput | GratitudeEntryCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type TransactionSuggestionCreateWithoutCreatedTransactionInput = {
    id?: string
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentUploadCreateNestedOneWithoutTransactionSuggestionsInput
    ocrResult?: OcrResultCreateNestedOneWithoutTransactionSuggestionsInput
    suggestedCategory?: CategoryCreateNestedOneWithoutTransactionSuggestionsInput
  }

  export type TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput = {
    id?: string
    documentId: string
    ocrResultId?: string | null
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryId?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionSuggestionCreateOrConnectWithoutCreatedTransactionInput = {
    where: TransactionSuggestionWhereUniqueInput
    create: XOR<TransactionSuggestionCreateWithoutCreatedTransactionInput, TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput>
  }

  export type TransactionSuggestionCreateManyCreatedTransactionInputEnvelope = {
    data: TransactionSuggestionCreateManyCreatedTransactionInput | TransactionSuggestionCreateManyCreatedTransactionInput[]
    skipDuplicates?: boolean
  }

  export type ZakatPaymentCreateWithoutTransactionInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    zakatCalculation?: ZakatCalculationCreateNestedOneWithoutZakatPaymentsInput
    household: HouseholdCreateNestedOneWithoutZakatPaymentsInput
  }

  export type ZakatPaymentUncheckedCreateWithoutTransactionInput = {
    id?: string
    zakatCalculationId?: string | null
    householdId: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatPaymentCreateOrConnectWithoutTransactionInput = {
    where: ZakatPaymentWhereUniqueInput
    create: XOR<ZakatPaymentCreateWithoutTransactionInput, ZakatPaymentUncheckedCreateWithoutTransactionInput>
  }

  export type ZakatPaymentCreateManyTransactionInputEnvelope = {
    data: ZakatPaymentCreateManyTransactionInput | ZakatPaymentCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutTransactionsInput = {
    update: XOR<HouseholdUpdateWithoutTransactionsInput, HouseholdUncheckedUpdateWithoutTransactionsInput>
    create: XOR<HouseholdCreateWithoutTransactionsInput, HouseholdUncheckedCreateWithoutTransactionsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutTransactionsInput, HouseholdUncheckedUpdateWithoutTransactionsInput>
  }

  export type HouseholdUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type AccountUpsertWithoutTransactionsInput = {
    update: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountUpsertWithoutTransferTransactionsInput = {
    update: XOR<AccountUpdateWithoutTransferTransactionsInput, AccountUncheckedUpdateWithoutTransferTransactionsInput>
    create: XOR<AccountCreateWithoutTransferTransactionsInput, AccountUncheckedCreateWithoutTransferTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTransferTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTransferTransactionsInput, AccountUncheckedUpdateWithoutTransferTransactionsInput>
  }

  export type AccountUpdateWithoutTransferTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutTransferTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type CategoryUpsertWithoutTransactionsInput = {
    update: XOR<CategoryUpdateWithoutTransactionsInput, CategoryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTransactionsInput, CategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type CategoryUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type MerchantUpsertWithoutTransactionsInput = {
    update: XOR<MerchantUpdateWithoutTransactionsInput, MerchantUncheckedUpdateWithoutTransactionsInput>
    create: XOR<MerchantCreateWithoutTransactionsInput, MerchantUncheckedCreateWithoutTransactionsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutTransactionsInput, MerchantUncheckedUpdateWithoutTransactionsInput>
  }

  export type MerchantUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedTransactionsInput = {
    update: XOR<UserUpdateWithoutCreatedTransactionsInput, UserUncheckedUpdateWithoutCreatedTransactionsInput>
    create: XOR<UserCreateWithoutCreatedTransactionsInput, UserUncheckedCreateWithoutCreatedTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTransactionsInput, UserUncheckedUpdateWithoutCreatedTransactionsInput>
  }

  export type UserUpdateWithoutCreatedTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionTagUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionTagWhereUniqueInput
    update: XOR<TransactionTagUpdateWithoutTransactionInput, TransactionTagUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionTagCreateWithoutTransactionInput, TransactionTagUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionTagUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionTagWhereUniqueInput
    data: XOR<TransactionTagUpdateWithoutTransactionInput, TransactionTagUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionTagUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionTagScalarWhereInput
    data: XOR<TransactionTagUpdateManyMutationInput, TransactionTagUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionTagScalarWhereInput = {
    AND?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
    OR?: TransactionTagScalarWhereInput[]
    NOT?: TransactionTagScalarWhereInput | TransactionTagScalarWhereInput[]
    transactionId?: UuidFilter<"TransactionTag"> | string
    tag?: StringFilter<"TransactionTag"> | string
  }

  export type TransactionSplitUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionSplitWhereUniqueInput
    update: XOR<TransactionSplitUpdateWithoutTransactionInput, TransactionSplitUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionSplitCreateWithoutTransactionInput, TransactionSplitUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionSplitUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionSplitWhereUniqueInput
    data: XOR<TransactionSplitUpdateWithoutTransactionInput, TransactionSplitUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionSplitUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionSplitScalarWhereInput
    data: XOR<TransactionSplitUpdateManyMutationInput, TransactionSplitUncheckedUpdateManyWithoutTransactionInput>
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutTransactionInput, LedgerEntryUncheckedUpdateWithoutTransactionInput>
    create: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutTransactionInput, LedgerEntryUncheckedUpdateWithoutTransactionInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutTransactionInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutTransactionInput>
  }

  export type RecurringTransactionExecutionUpsertWithWhereUniqueWithoutTransactionInput = {
    where: RecurringTransactionExecutionWhereUniqueInput
    update: XOR<RecurringTransactionExecutionUpdateWithoutTransactionInput, RecurringTransactionExecutionUncheckedUpdateWithoutTransactionInput>
    create: XOR<RecurringTransactionExecutionCreateWithoutTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutTransactionInput>
  }

  export type RecurringTransactionExecutionUpdateWithWhereUniqueWithoutTransactionInput = {
    where: RecurringTransactionExecutionWhereUniqueInput
    data: XOR<RecurringTransactionExecutionUpdateWithoutTransactionInput, RecurringTransactionExecutionUncheckedUpdateWithoutTransactionInput>
  }

  export type RecurringTransactionExecutionUpdateManyWithWhereWithoutTransactionInput = {
    where: RecurringTransactionExecutionScalarWhereInput
    data: XOR<RecurringTransactionExecutionUpdateManyMutationInput, RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type RecurringTransactionExecutionScalarWhereInput = {
    AND?: RecurringTransactionExecutionScalarWhereInput | RecurringTransactionExecutionScalarWhereInput[]
    OR?: RecurringTransactionExecutionScalarWhereInput[]
    NOT?: RecurringTransactionExecutionScalarWhereInput | RecurringTransactionExecutionScalarWhereInput[]
    id?: UuidFilter<"RecurringTransactionExecution"> | string
    recurringTransactionId?: UuidFilter<"RecurringTransactionExecution"> | string
    transactionId?: UuidNullableFilter<"RecurringTransactionExecution"> | string | null
    scheduledDate?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
    executedDate?: DateTimeNullableFilter<"RecurringTransactionExecution"> | Date | string | null
    status?: StringFilter<"RecurringTransactionExecution"> | string
    errorMessage?: StringNullableFilter<"RecurringTransactionExecution"> | string | null
    retryCount?: IntFilter<"RecurringTransactionExecution"> | number
    createdAt?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringTransactionExecution"> | Date | string
  }

  export type GratitudeEntryUpsertWithWhereUniqueWithoutTransactionInput = {
    where: GratitudeEntryWhereUniqueInput
    update: XOR<GratitudeEntryUpdateWithoutTransactionInput, GratitudeEntryUncheckedUpdateWithoutTransactionInput>
    create: XOR<GratitudeEntryCreateWithoutTransactionInput, GratitudeEntryUncheckedCreateWithoutTransactionInput>
  }

  export type GratitudeEntryUpdateWithWhereUniqueWithoutTransactionInput = {
    where: GratitudeEntryWhereUniqueInput
    data: XOR<GratitudeEntryUpdateWithoutTransactionInput, GratitudeEntryUncheckedUpdateWithoutTransactionInput>
  }

  export type GratitudeEntryUpdateManyWithWhereWithoutTransactionInput = {
    where: GratitudeEntryScalarWhereInput
    data: XOR<GratitudeEntryUpdateManyMutationInput, GratitudeEntryUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionSuggestionUpsertWithWhereUniqueWithoutCreatedTransactionInput = {
    where: TransactionSuggestionWhereUniqueInput
    update: XOR<TransactionSuggestionUpdateWithoutCreatedTransactionInput, TransactionSuggestionUncheckedUpdateWithoutCreatedTransactionInput>
    create: XOR<TransactionSuggestionCreateWithoutCreatedTransactionInput, TransactionSuggestionUncheckedCreateWithoutCreatedTransactionInput>
  }

  export type TransactionSuggestionUpdateWithWhereUniqueWithoutCreatedTransactionInput = {
    where: TransactionSuggestionWhereUniqueInput
    data: XOR<TransactionSuggestionUpdateWithoutCreatedTransactionInput, TransactionSuggestionUncheckedUpdateWithoutCreatedTransactionInput>
  }

  export type TransactionSuggestionUpdateManyWithWhereWithoutCreatedTransactionInput = {
    where: TransactionSuggestionScalarWhereInput
    data: XOR<TransactionSuggestionUpdateManyMutationInput, TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionInput>
  }

  export type ZakatPaymentUpsertWithWhereUniqueWithoutTransactionInput = {
    where: ZakatPaymentWhereUniqueInput
    update: XOR<ZakatPaymentUpdateWithoutTransactionInput, ZakatPaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<ZakatPaymentCreateWithoutTransactionInput, ZakatPaymentUncheckedCreateWithoutTransactionInput>
  }

  export type ZakatPaymentUpdateWithWhereUniqueWithoutTransactionInput = {
    where: ZakatPaymentWhereUniqueInput
    data: XOR<ZakatPaymentUpdateWithoutTransactionInput, ZakatPaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type ZakatPaymentUpdateManyWithWhereWithoutTransactionInput = {
    where: ZakatPaymentScalarWhereInput
    data: XOR<ZakatPaymentUpdateManyMutationInput, ZakatPaymentUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionCreateWithoutTagsInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutTagsInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutTagsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTagsInput, TransactionUncheckedCreateWithoutTagsInput>
  }

  export type TransactionUpsertWithoutTagsInput = {
    update: XOR<TransactionUpdateWithoutTagsInput, TransactionUncheckedUpdateWithoutTagsInput>
    create: XOR<TransactionCreateWithoutTagsInput, TransactionUncheckedCreateWithoutTagsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutTagsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutTagsInput, TransactionUncheckedUpdateWithoutTagsInput>
  }

  export type TransactionUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateWithoutSplitsInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutSplitsInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutSplitsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSplitsInput, TransactionUncheckedCreateWithoutSplitsInput>
  }

  export type CategoryCreateWithoutTransactionSplitsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTransactionSplitsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTransactionSplitsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTransactionSplitsInput, CategoryUncheckedCreateWithoutTransactionSplitsInput>
  }

  export type TransactionUpsertWithoutSplitsInput = {
    update: XOR<TransactionUpdateWithoutSplitsInput, TransactionUncheckedUpdateWithoutSplitsInput>
    create: XOR<TransactionCreateWithoutSplitsInput, TransactionUncheckedCreateWithoutSplitsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutSplitsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutSplitsInput, TransactionUncheckedUpdateWithoutSplitsInput>
  }

  export type TransactionUpdateWithoutSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type CategoryUpsertWithoutTransactionSplitsInput = {
    update: XOR<CategoryUpdateWithoutTransactionSplitsInput, CategoryUncheckedUpdateWithoutTransactionSplitsInput>
    create: XOR<CategoryCreateWithoutTransactionSplitsInput, CategoryUncheckedCreateWithoutTransactionSplitsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTransactionSplitsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTransactionSplitsInput, CategoryUncheckedUpdateWithoutTransactionSplitsInput>
  }

  export type CategoryUpdateWithoutTransactionSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTransactionSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type TransactionCreateWithoutLedgerEntriesInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutLedgerEntriesInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutLedgerEntriesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type AccountCreateWithoutLedgerEntriesInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutLedgerEntriesInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutLedgerEntriesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutLedgerEntriesInput, AccountUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type TransactionUpsertWithoutLedgerEntriesInput = {
    update: XOR<TransactionUpdateWithoutLedgerEntriesInput, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutLedgerEntriesInput, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type TransactionUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type AccountUpsertWithoutLedgerEntriesInput = {
    update: XOR<AccountUpdateWithoutLedgerEntriesInput, AccountUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<AccountCreateWithoutLedgerEntriesInput, AccountUncheckedCreateWithoutLedgerEntriesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutLedgerEntriesInput, AccountUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type AccountUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type HouseholdCreateWithoutDebtsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutDebtsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutDebtsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutDebtsInput, HouseholdUncheckedCreateWithoutDebtsInput>
  }

  export type DebtPaymentCreateWithoutDebtInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    principalAmountCents: bigint | number
    interestAmountCents?: bigint | number
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type DebtPaymentUncheckedCreateWithoutDebtInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    principalAmountCents: bigint | number
    interestAmountCents?: bigint | number
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type DebtPaymentCreateOrConnectWithoutDebtInput = {
    where: DebtPaymentWhereUniqueInput
    create: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput>
  }

  export type DebtPaymentCreateManyDebtInputEnvelope = {
    data: DebtPaymentCreateManyDebtInput | DebtPaymentCreateManyDebtInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutDebtsInput = {
    update: XOR<HouseholdUpdateWithoutDebtsInput, HouseholdUncheckedUpdateWithoutDebtsInput>
    create: XOR<HouseholdCreateWithoutDebtsInput, HouseholdUncheckedCreateWithoutDebtsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutDebtsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutDebtsInput, HouseholdUncheckedUpdateWithoutDebtsInput>
  }

  export type HouseholdUpdateWithoutDebtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutDebtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type DebtPaymentUpsertWithWhereUniqueWithoutDebtInput = {
    where: DebtPaymentWhereUniqueInput
    update: XOR<DebtPaymentUpdateWithoutDebtInput, DebtPaymentUncheckedUpdateWithoutDebtInput>
    create: XOR<DebtPaymentCreateWithoutDebtInput, DebtPaymentUncheckedCreateWithoutDebtInput>
  }

  export type DebtPaymentUpdateWithWhereUniqueWithoutDebtInput = {
    where: DebtPaymentWhereUniqueInput
    data: XOR<DebtPaymentUpdateWithoutDebtInput, DebtPaymentUncheckedUpdateWithoutDebtInput>
  }

  export type DebtPaymentUpdateManyWithWhereWithoutDebtInput = {
    where: DebtPaymentScalarWhereInput
    data: XOR<DebtPaymentUpdateManyMutationInput, DebtPaymentUncheckedUpdateManyWithoutDebtInput>
  }

  export type DebtPaymentScalarWhereInput = {
    AND?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
    OR?: DebtPaymentScalarWhereInput[]
    NOT?: DebtPaymentScalarWhereInput | DebtPaymentScalarWhereInput[]
    id?: UuidFilter<"DebtPayment"> | string
    debtId?: UuidFilter<"DebtPayment"> | string
    amountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    currency?: StringFilter<"DebtPayment"> | string
    paymentDate?: DateTimeFilter<"DebtPayment"> | Date | string
    principalAmountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    interestAmountCents?: BigIntFilter<"DebtPayment"> | bigint | number
    transactionId?: UuidNullableFilter<"DebtPayment"> | string | null
    createdAt?: DateTimeFilter<"DebtPayment"> | Date | string
  }

  export type DebtCreateWithoutPaymentsInput = {
    id?: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint | number
    currentBalanceCents: bigint | number
    currency?: string
    interestRate?: Decimal | DecimalJsLike | number | string | null
    marginRate?: Decimal | DecimalJsLike | number | string | null
    startDate: Date | string
    maturityDate?: Date | string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutDebtsInput
  }

  export type DebtUncheckedCreateWithoutPaymentsInput = {
    id?: string
    householdId: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint | number
    currentBalanceCents: bigint | number
    currency?: string
    interestRate?: Decimal | DecimalJsLike | number | string | null
    marginRate?: Decimal | DecimalJsLike | number | string | null
    startDate: Date | string
    maturityDate?: Date | string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtCreateOrConnectWithoutPaymentsInput = {
    where: DebtWhereUniqueInput
    create: XOR<DebtCreateWithoutPaymentsInput, DebtUncheckedCreateWithoutPaymentsInput>
  }

  export type DebtUpsertWithoutPaymentsInput = {
    update: XOR<DebtUpdateWithoutPaymentsInput, DebtUncheckedUpdateWithoutPaymentsInput>
    create: XOR<DebtCreateWithoutPaymentsInput, DebtUncheckedCreateWithoutPaymentsInput>
    where?: DebtWhereInput
  }

  export type DebtUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: DebtWhereInput
    data: XOR<DebtUpdateWithoutPaymentsInput, DebtUncheckedUpdateWithoutPaymentsInput>
  }

  export type DebtUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutDebtsNestedInput
  }

  export type DebtUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdCreateWithoutBudgetsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutBudgetsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutBudgetsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutBudgetsInput, HouseholdUncheckedCreateWithoutBudgetsInput>
  }

  export type BudgetCategoryCreateWithoutBudgetInput = {
    id?: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutBudgetCategoriesInput
  }

  export type BudgetCategoryUncheckedCreateWithoutBudgetInput = {
    id?: string
    categoryId: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCategoryCreateOrConnectWithoutBudgetInput = {
    where: BudgetCategoryWhereUniqueInput
    create: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetCategoryCreateManyBudgetInputEnvelope = {
    data: BudgetCategoryCreateManyBudgetInput | BudgetCategoryCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutBudgetsInput = {
    update: XOR<HouseholdUpdateWithoutBudgetsInput, HouseholdUncheckedUpdateWithoutBudgetsInput>
    create: XOR<HouseholdCreateWithoutBudgetsInput, HouseholdUncheckedCreateWithoutBudgetsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutBudgetsInput, HouseholdUncheckedUpdateWithoutBudgetsInput>
  }

  export type HouseholdUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetCategoryWhereUniqueInput
    update: XOR<BudgetCategoryUpdateWithoutBudgetInput, BudgetCategoryUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetCategoryWhereUniqueInput
    data: XOR<BudgetCategoryUpdateWithoutBudgetInput, BudgetCategoryUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetCategoryUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetCategoryScalarWhereInput
    data: XOR<BudgetCategoryUpdateManyMutationInput, BudgetCategoryUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetCreateWithoutCategoriesInput = {
    id?: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint | number
    currency?: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutCategoriesInput = {
    id?: string
    householdId: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint | number
    currency?: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutCategoriesInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutCategoriesInput, BudgetUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutBudgetCategoriesInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateWithoutBudgetCategoriesInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryCreateOrConnectWithoutBudgetCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBudgetCategoriesInput, CategoryUncheckedCreateWithoutBudgetCategoriesInput>
  }

  export type BudgetUpsertWithoutCategoriesInput = {
    update: XOR<BudgetUpdateWithoutCategoriesInput, BudgetUncheckedUpdateWithoutCategoriesInput>
    create: XOR<BudgetCreateWithoutCategoriesInput, BudgetUncheckedCreateWithoutCategoriesInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutCategoriesInput, BudgetUncheckedUpdateWithoutCategoriesInput>
  }

  export type BudgetUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutBudgetCategoriesInput = {
    update: XOR<CategoryUpdateWithoutBudgetCategoriesInput, CategoryUncheckedUpdateWithoutBudgetCategoriesInput>
    create: XOR<CategoryCreateWithoutBudgetCategoriesInput, CategoryUncheckedCreateWithoutBudgetCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutBudgetCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutBudgetCategoriesInput, CategoryUncheckedUpdateWithoutBudgetCategoriesInput>
  }

  export type CategoryUpdateWithoutBudgetCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutBudgetCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type HouseholdCreateWithoutWishlistItemsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutWishlistItemsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutWishlistItemsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutWishlistItemsInput, HouseholdUncheckedCreateWithoutWishlistItemsInput>
  }

  export type UserCreateWithoutCreatedWishlistItemsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedWishlistItemsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedWishlistItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedWishlistItemsInput, UserUncheckedCreateWithoutCreatedWishlistItemsInput>
  }

  export type PriceHistoryCreateWithoutWishlistItemInput = {
    id?: string
    priceCents: bigint | number
    currency?: string
    recordedAt?: Date | string
  }

  export type PriceHistoryUncheckedCreateWithoutWishlistItemInput = {
    id?: string
    priceCents: bigint | number
    currency?: string
    recordedAt?: Date | string
  }

  export type PriceHistoryCreateOrConnectWithoutWishlistItemInput = {
    where: PriceHistoryWhereUniqueInput
    create: XOR<PriceHistoryCreateWithoutWishlistItemInput, PriceHistoryUncheckedCreateWithoutWishlistItemInput>
  }

  export type PriceHistoryCreateManyWishlistItemInputEnvelope = {
    data: PriceHistoryCreateManyWishlistItemInput | PriceHistoryCreateManyWishlistItemInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutWishlistItemsInput = {
    update: XOR<HouseholdUpdateWithoutWishlistItemsInput, HouseholdUncheckedUpdateWithoutWishlistItemsInput>
    create: XOR<HouseholdCreateWithoutWishlistItemsInput, HouseholdUncheckedCreateWithoutWishlistItemsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutWishlistItemsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutWishlistItemsInput, HouseholdUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type HouseholdUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type UserUpsertWithoutCreatedWishlistItemsInput = {
    update: XOR<UserUpdateWithoutCreatedWishlistItemsInput, UserUncheckedUpdateWithoutCreatedWishlistItemsInput>
    create: XOR<UserCreateWithoutCreatedWishlistItemsInput, UserUncheckedCreateWithoutCreatedWishlistItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedWishlistItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedWishlistItemsInput, UserUncheckedUpdateWithoutCreatedWishlistItemsInput>
  }

  export type UserUpdateWithoutCreatedWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PriceHistoryUpsertWithWhereUniqueWithoutWishlistItemInput = {
    where: PriceHistoryWhereUniqueInput
    update: XOR<PriceHistoryUpdateWithoutWishlistItemInput, PriceHistoryUncheckedUpdateWithoutWishlistItemInput>
    create: XOR<PriceHistoryCreateWithoutWishlistItemInput, PriceHistoryUncheckedCreateWithoutWishlistItemInput>
  }

  export type PriceHistoryUpdateWithWhereUniqueWithoutWishlistItemInput = {
    where: PriceHistoryWhereUniqueInput
    data: XOR<PriceHistoryUpdateWithoutWishlistItemInput, PriceHistoryUncheckedUpdateWithoutWishlistItemInput>
  }

  export type PriceHistoryUpdateManyWithWhereWithoutWishlistItemInput = {
    where: PriceHistoryScalarWhereInput
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyWithoutWishlistItemInput>
  }

  export type PriceHistoryScalarWhereInput = {
    AND?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    OR?: PriceHistoryScalarWhereInput[]
    NOT?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    id?: UuidFilter<"PriceHistory"> | string
    wishlistItemId?: UuidFilter<"PriceHistory"> | string
    priceCents?: BigIntFilter<"PriceHistory"> | bigint | number
    currency?: StringFilter<"PriceHistory"> | string
    recordedAt?: DateTimeFilter<"PriceHistory"> | Date | string
  }

  export type WishlistItemCreateWithoutPriceHistoryInput = {
    id?: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutWishlistItemsInput
    creator: UserCreateNestedOneWithoutCreatedWishlistItemsInput
  }

  export type WishlistItemUncheckedCreateWithoutPriceHistoryInput = {
    id?: string
    householdId: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutPriceHistoryInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutPriceHistoryInput, WishlistItemUncheckedCreateWithoutPriceHistoryInput>
  }

  export type WishlistItemUpsertWithoutPriceHistoryInput = {
    update: XOR<WishlistItemUpdateWithoutPriceHistoryInput, WishlistItemUncheckedUpdateWithoutPriceHistoryInput>
    create: XOR<WishlistItemCreateWithoutPriceHistoryInput, WishlistItemUncheckedCreateWithoutPriceHistoryInput>
    where?: WishlistItemWhereInput
  }

  export type WishlistItemUpdateToOneWithWhereWithoutPriceHistoryInput = {
    where?: WishlistItemWhereInput
    data: XOR<WishlistItemUpdateWithoutPriceHistoryInput, WishlistItemUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type WishlistItemUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutWishlistItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWishlistItemsNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdCreateWithoutGratitudeEntriesInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutGratitudeEntriesInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutGratitudeEntriesInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutGratitudeEntriesInput, HouseholdUncheckedCreateWithoutGratitudeEntriesInput>
  }

  export type CategoryCreateWithoutGratitudeEntriesInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateWithoutGratitudeEntriesInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryCreateOrConnectWithoutGratitudeEntriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutGratitudeEntriesInput, CategoryUncheckedCreateWithoutGratitudeEntriesInput>
  }

  export type TransactionCreateWithoutGratitudeEntriesInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutGratitudeEntriesInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutGratitudeEntriesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutGratitudeEntriesInput, TransactionUncheckedCreateWithoutGratitudeEntriesInput>
  }

  export type UserCreateWithoutCreatedGratitudeEntriesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedGratitudeEntriesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedGratitudeEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGratitudeEntriesInput, UserUncheckedCreateWithoutCreatedGratitudeEntriesInput>
  }

  export type HouseholdUpsertWithoutGratitudeEntriesInput = {
    update: XOR<HouseholdUpdateWithoutGratitudeEntriesInput, HouseholdUncheckedUpdateWithoutGratitudeEntriesInput>
    create: XOR<HouseholdCreateWithoutGratitudeEntriesInput, HouseholdUncheckedCreateWithoutGratitudeEntriesInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutGratitudeEntriesInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutGratitudeEntriesInput, HouseholdUncheckedUpdateWithoutGratitudeEntriesInput>
  }

  export type HouseholdUpdateWithoutGratitudeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutGratitudeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type CategoryUpsertWithoutGratitudeEntriesInput = {
    update: XOR<CategoryUpdateWithoutGratitudeEntriesInput, CategoryUncheckedUpdateWithoutGratitudeEntriesInput>
    create: XOR<CategoryCreateWithoutGratitudeEntriesInput, CategoryUncheckedCreateWithoutGratitudeEntriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutGratitudeEntriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutGratitudeEntriesInput, CategoryUncheckedUpdateWithoutGratitudeEntriesInput>
  }

  export type CategoryUpdateWithoutGratitudeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutGratitudeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type TransactionUpsertWithoutGratitudeEntriesInput = {
    update: XOR<TransactionUpdateWithoutGratitudeEntriesInput, TransactionUncheckedUpdateWithoutGratitudeEntriesInput>
    create: XOR<TransactionCreateWithoutGratitudeEntriesInput, TransactionUncheckedCreateWithoutGratitudeEntriesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutGratitudeEntriesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutGratitudeEntriesInput, TransactionUncheckedUpdateWithoutGratitudeEntriesInput>
  }

  export type TransactionUpdateWithoutGratitudeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutGratitudeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserUpsertWithoutCreatedGratitudeEntriesInput = {
    update: XOR<UserUpdateWithoutCreatedGratitudeEntriesInput, UserUncheckedUpdateWithoutCreatedGratitudeEntriesInput>
    create: XOR<UserCreateWithoutCreatedGratitudeEntriesInput, UserUncheckedCreateWithoutCreatedGratitudeEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedGratitudeEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedGratitudeEntriesInput, UserUncheckedUpdateWithoutCreatedGratitudeEntriesInput>
  }

  export type UserUpdateWithoutCreatedGratitudeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGratitudeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasskeysInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasskeysInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasskeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasskeysInput, UserUncheckedCreateWithoutPasskeysInput>
  }

  export type UserUpsertWithoutPasskeysInput = {
    update: XOR<UserUpdateWithoutPasskeysInput, UserUncheckedUpdateWithoutPasskeysInput>
    create: XOR<UserCreateWithoutPasskeysInput, UserUncheckedCreateWithoutPasskeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasskeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasskeysInput, UserUncheckedUpdateWithoutPasskeysInput>
  }

  export type UserUpdateWithoutPasskeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasskeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserEventsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserEventsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserEventsInput, UserUncheckedCreateWithoutUserEventsInput>
  }

  export type HouseholdCreateWithoutUserEventsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutUserEventsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutUserEventsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutUserEventsInput, HouseholdUncheckedCreateWithoutUserEventsInput>
  }

  export type UserUpsertWithoutUserEventsInput = {
    update: XOR<UserUpdateWithoutUserEventsInput, UserUncheckedUpdateWithoutUserEventsInput>
    create: XOR<UserCreateWithoutUserEventsInput, UserUncheckedCreateWithoutUserEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserEventsInput, UserUncheckedUpdateWithoutUserEventsInput>
  }

  export type UserUpdateWithoutUserEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdUpsertWithoutUserEventsInput = {
    update: XOR<HouseholdUpdateWithoutUserEventsInput, HouseholdUncheckedUpdateWithoutUserEventsInput>
    create: XOR<HouseholdCreateWithoutUserEventsInput, HouseholdUncheckedCreateWithoutUserEventsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutUserEventsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutUserEventsInput, HouseholdUncheckedUpdateWithoutUserEventsInput>
  }

  export type HouseholdUpdateWithoutUserEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutUserEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdCreateWithoutSpendingPatternsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutSpendingPatternsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutSpendingPatternsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutSpendingPatternsInput, HouseholdUncheckedCreateWithoutSpendingPatternsInput>
  }

  export type HouseholdUpsertWithoutSpendingPatternsInput = {
    update: XOR<HouseholdUpdateWithoutSpendingPatternsInput, HouseholdUncheckedUpdateWithoutSpendingPatternsInput>
    create: XOR<HouseholdCreateWithoutSpendingPatternsInput, HouseholdUncheckedCreateWithoutSpendingPatternsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutSpendingPatternsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutSpendingPatternsInput, HouseholdUncheckedUpdateWithoutSpendingPatternsInput>
  }

  export type HouseholdUpdateWithoutSpendingPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutSpendingPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdCreateWithoutFinancialInsightsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutFinancialInsightsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutFinancialInsightsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutFinancialInsightsInput, HouseholdUncheckedCreateWithoutFinancialInsightsInput>
  }

  export type HouseholdUpsertWithoutFinancialInsightsInput = {
    update: XOR<HouseholdUpdateWithoutFinancialInsightsInput, HouseholdUncheckedUpdateWithoutFinancialInsightsInput>
    create: XOR<HouseholdCreateWithoutFinancialInsightsInput, HouseholdUncheckedCreateWithoutFinancialInsightsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutFinancialInsightsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutFinancialInsightsInput, HouseholdUncheckedUpdateWithoutFinancialInsightsInput>
  }

  export type HouseholdUpdateWithoutFinancialInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutFinancialInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdCreateWithoutRecurringTransactionsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutRecurringTransactionsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutRecurringTransactionsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutRecurringTransactionsInput, HouseholdUncheckedCreateWithoutRecurringTransactionsInput>
  }

  export type AccountCreateWithoutRecurringTransactionsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutRecurringTransactionsInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutRecurringTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutRecurringTransactionsInput, AccountUncheckedCreateWithoutRecurringTransactionsInput>
  }

  export type AccountCreateWithoutRecurringTransferTransactionsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutRecurringTransferTransactionsInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutRecurringTransferTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutRecurringTransferTransactionsInput, AccountUncheckedCreateWithoutRecurringTransferTransactionsInput>
  }

  export type CategoryCreateWithoutRecurringTransactionsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryUncheckedCreateWithoutRecurringTransactionsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutSuggestedCategoryInput
  }

  export type CategoryCreateOrConnectWithoutRecurringTransactionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutRecurringTransactionsInput, CategoryUncheckedCreateWithoutRecurringTransactionsInput>
  }

  export type UserCreateWithoutCreatedRecurringTransactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedRecurringTransactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedRecurringTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRecurringTransactionsInput, UserUncheckedCreateWithoutCreatedRecurringTransactionsInput>
  }

  export type RecurringTransactionExecutionCreateWithoutRecurringTransactionInput = {
    id?: string
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction?: TransactionCreateNestedOneWithoutRecurringTransactionExecutionsInput
  }

  export type RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput = {
    id?: string
    transactionId?: string | null
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionExecutionCreateOrConnectWithoutRecurringTransactionInput = {
    where: RecurringTransactionExecutionWhereUniqueInput
    create: XOR<RecurringTransactionExecutionCreateWithoutRecurringTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput>
  }

  export type RecurringTransactionExecutionCreateManyRecurringTransactionInputEnvelope = {
    data: RecurringTransactionExecutionCreateManyRecurringTransactionInput | RecurringTransactionExecutionCreateManyRecurringTransactionInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutRecurringTransactionsInput = {
    update: XOR<HouseholdUpdateWithoutRecurringTransactionsInput, HouseholdUncheckedUpdateWithoutRecurringTransactionsInput>
    create: XOR<HouseholdCreateWithoutRecurringTransactionsInput, HouseholdUncheckedCreateWithoutRecurringTransactionsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutRecurringTransactionsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutRecurringTransactionsInput, HouseholdUncheckedUpdateWithoutRecurringTransactionsInput>
  }

  export type HouseholdUpdateWithoutRecurringTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutRecurringTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type AccountUpsertWithoutRecurringTransactionsInput = {
    update: XOR<AccountUpdateWithoutRecurringTransactionsInput, AccountUncheckedUpdateWithoutRecurringTransactionsInput>
    create: XOR<AccountCreateWithoutRecurringTransactionsInput, AccountUncheckedCreateWithoutRecurringTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutRecurringTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutRecurringTransactionsInput, AccountUncheckedUpdateWithoutRecurringTransactionsInput>
  }

  export type AccountUpdateWithoutRecurringTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutRecurringTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountUpsertWithoutRecurringTransferTransactionsInput = {
    update: XOR<AccountUpdateWithoutRecurringTransferTransactionsInput, AccountUncheckedUpdateWithoutRecurringTransferTransactionsInput>
    create: XOR<AccountCreateWithoutRecurringTransferTransactionsInput, AccountUncheckedCreateWithoutRecurringTransferTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutRecurringTransferTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutRecurringTransferTransactionsInput, AccountUncheckedUpdateWithoutRecurringTransferTransactionsInput>
  }

  export type AccountUpdateWithoutRecurringTransferTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutRecurringTransferTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type CategoryUpsertWithoutRecurringTransactionsInput = {
    update: XOR<CategoryUpdateWithoutRecurringTransactionsInput, CategoryUncheckedUpdateWithoutRecurringTransactionsInput>
    create: XOR<CategoryCreateWithoutRecurringTransactionsInput, CategoryUncheckedCreateWithoutRecurringTransactionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutRecurringTransactionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutRecurringTransactionsInput, CategoryUncheckedUpdateWithoutRecurringTransactionsInput>
  }

  export type CategoryUpdateWithoutRecurringTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutRecurringTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type UserUpsertWithoutCreatedRecurringTransactionsInput = {
    update: XOR<UserUpdateWithoutCreatedRecurringTransactionsInput, UserUncheckedUpdateWithoutCreatedRecurringTransactionsInput>
    create: XOR<UserCreateWithoutCreatedRecurringTransactionsInput, UserUncheckedCreateWithoutCreatedRecurringTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRecurringTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRecurringTransactionsInput, UserUncheckedUpdateWithoutCreatedRecurringTransactionsInput>
  }

  export type UserUpdateWithoutCreatedRecurringTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRecurringTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecurringTransactionExecutionUpsertWithWhereUniqueWithoutRecurringTransactionInput = {
    where: RecurringTransactionExecutionWhereUniqueInput
    update: XOR<RecurringTransactionExecutionUpdateWithoutRecurringTransactionInput, RecurringTransactionExecutionUncheckedUpdateWithoutRecurringTransactionInput>
    create: XOR<RecurringTransactionExecutionCreateWithoutRecurringTransactionInput, RecurringTransactionExecutionUncheckedCreateWithoutRecurringTransactionInput>
  }

  export type RecurringTransactionExecutionUpdateWithWhereUniqueWithoutRecurringTransactionInput = {
    where: RecurringTransactionExecutionWhereUniqueInput
    data: XOR<RecurringTransactionExecutionUpdateWithoutRecurringTransactionInput, RecurringTransactionExecutionUncheckedUpdateWithoutRecurringTransactionInput>
  }

  export type RecurringTransactionExecutionUpdateManyWithWhereWithoutRecurringTransactionInput = {
    where: RecurringTransactionExecutionScalarWhereInput
    data: XOR<RecurringTransactionExecutionUpdateManyMutationInput, RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionInput>
  }

  export type RecurringTransactionCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutRecurringTransactionsInput
    account: AccountCreateNestedOneWithoutRecurringTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutRecurringTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutRecurringTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedRecurringTransactionsInput
  }

  export type RecurringTransactionUncheckedCreateWithoutExecutionsInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionCreateOrConnectWithoutExecutionsInput = {
    where: RecurringTransactionWhereUniqueInput
    create: XOR<RecurringTransactionCreateWithoutExecutionsInput, RecurringTransactionUncheckedCreateWithoutExecutionsInput>
  }

  export type TransactionCreateWithoutRecurringTransactionExecutionsInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutRecurringTransactionExecutionsInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutRecurringTransactionExecutionsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutRecurringTransactionExecutionsInput, TransactionUncheckedCreateWithoutRecurringTransactionExecutionsInput>
  }

  export type RecurringTransactionUpsertWithoutExecutionsInput = {
    update: XOR<RecurringTransactionUpdateWithoutExecutionsInput, RecurringTransactionUncheckedUpdateWithoutExecutionsInput>
    create: XOR<RecurringTransactionCreateWithoutExecutionsInput, RecurringTransactionUncheckedCreateWithoutExecutionsInput>
    where?: RecurringTransactionWhereInput
  }

  export type RecurringTransactionUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: RecurringTransactionWhereInput
    data: XOR<RecurringTransactionUpdateWithoutExecutionsInput, RecurringTransactionUncheckedUpdateWithoutExecutionsInput>
  }

  export type RecurringTransactionUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutRecurringTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutRecurringTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringTransactionsNestedInput
  }

  export type RecurringTransactionUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithoutRecurringTransactionExecutionsInput = {
    update: XOR<TransactionUpdateWithoutRecurringTransactionExecutionsInput, TransactionUncheckedUpdateWithoutRecurringTransactionExecutionsInput>
    create: XOR<TransactionCreateWithoutRecurringTransactionExecutionsInput, TransactionUncheckedCreateWithoutRecurringTransactionExecutionsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutRecurringTransactionExecutionsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutRecurringTransactionExecutionsInput, TransactionUncheckedUpdateWithoutRecurringTransactionExecutionsInput>
  }

  export type TransactionUpdateWithoutRecurringTransactionExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutRecurringTransactionExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type HouseholdCreateWithoutDocumentUploadsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutDocumentUploadsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutDocumentUploadsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutDocumentUploadsInput, HouseholdUncheckedCreateWithoutDocumentUploadsInput>
  }

  export type UserCreateWithoutUploadedDocumentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedDocumentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
  }

  export type OcrResultCreateWithoutDocumentInput = {
    id?: string
    documentType: $Enums.DocumentType
    confidence: Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText: string
    processedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutOcrResultInput
  }

  export type OcrResultUncheckedCreateWithoutDocumentInput = {
    id?: string
    documentType: $Enums.DocumentType
    confidence: Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText: string
    processedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutOcrResultInput
  }

  export type OcrResultCreateOrConnectWithoutDocumentInput = {
    where: OcrResultWhereUniqueInput
    create: XOR<OcrResultCreateWithoutDocumentInput, OcrResultUncheckedCreateWithoutDocumentInput>
  }

  export type OcrResultCreateManyDocumentInputEnvelope = {
    data: OcrResultCreateManyDocumentInput | OcrResultCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type TransactionSuggestionCreateWithoutDocumentInput = {
    id?: string
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ocrResult?: OcrResultCreateNestedOneWithoutTransactionSuggestionsInput
    suggestedCategory?: CategoryCreateNestedOneWithoutTransactionSuggestionsInput
    createdTransaction?: TransactionCreateNestedOneWithoutCreatedFromSuggestionInput
  }

  export type TransactionSuggestionUncheckedCreateWithoutDocumentInput = {
    id?: string
    ocrResultId?: string | null
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryId?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionSuggestionCreateOrConnectWithoutDocumentInput = {
    where: TransactionSuggestionWhereUniqueInput
    create: XOR<TransactionSuggestionCreateWithoutDocumentInput, TransactionSuggestionUncheckedCreateWithoutDocumentInput>
  }

  export type TransactionSuggestionCreateManyDocumentInputEnvelope = {
    data: TransactionSuggestionCreateManyDocumentInput | TransactionSuggestionCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutDocumentUploadsInput = {
    update: XOR<HouseholdUpdateWithoutDocumentUploadsInput, HouseholdUncheckedUpdateWithoutDocumentUploadsInput>
    create: XOR<HouseholdCreateWithoutDocumentUploadsInput, HouseholdUncheckedCreateWithoutDocumentUploadsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutDocumentUploadsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutDocumentUploadsInput, HouseholdUncheckedUpdateWithoutDocumentUploadsInput>
  }

  export type HouseholdUpdateWithoutDocumentUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutDocumentUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type UserUpsertWithoutUploadedDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type UserUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OcrResultUpsertWithWhereUniqueWithoutDocumentInput = {
    where: OcrResultWhereUniqueInput
    update: XOR<OcrResultUpdateWithoutDocumentInput, OcrResultUncheckedUpdateWithoutDocumentInput>
    create: XOR<OcrResultCreateWithoutDocumentInput, OcrResultUncheckedCreateWithoutDocumentInput>
  }

  export type OcrResultUpdateWithWhereUniqueWithoutDocumentInput = {
    where: OcrResultWhereUniqueInput
    data: XOR<OcrResultUpdateWithoutDocumentInput, OcrResultUncheckedUpdateWithoutDocumentInput>
  }

  export type OcrResultUpdateManyWithWhereWithoutDocumentInput = {
    where: OcrResultScalarWhereInput
    data: XOR<OcrResultUpdateManyMutationInput, OcrResultUncheckedUpdateManyWithoutDocumentInput>
  }

  export type OcrResultScalarWhereInput = {
    AND?: OcrResultScalarWhereInput | OcrResultScalarWhereInput[]
    OR?: OcrResultScalarWhereInput[]
    NOT?: OcrResultScalarWhereInput | OcrResultScalarWhereInput[]
    id?: UuidFilter<"OcrResult"> | string
    documentId?: UuidFilter<"OcrResult"> | string
    documentType?: EnumDocumentTypeFilter<"OcrResult"> | $Enums.DocumentType
    confidence?: DecimalFilter<"OcrResult"> | Decimal | DecimalJsLike | number | string
    extractedData?: JsonFilter<"OcrResult">
    rawText?: StringFilter<"OcrResult"> | string
    processedAt?: DateTimeFilter<"OcrResult"> | Date | string
    metadata?: JsonFilter<"OcrResult">
    createdAt?: DateTimeFilter<"OcrResult"> | Date | string
  }

  export type TransactionSuggestionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: TransactionSuggestionWhereUniqueInput
    update: XOR<TransactionSuggestionUpdateWithoutDocumentInput, TransactionSuggestionUncheckedUpdateWithoutDocumentInput>
    create: XOR<TransactionSuggestionCreateWithoutDocumentInput, TransactionSuggestionUncheckedCreateWithoutDocumentInput>
  }

  export type TransactionSuggestionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: TransactionSuggestionWhereUniqueInput
    data: XOR<TransactionSuggestionUpdateWithoutDocumentInput, TransactionSuggestionUncheckedUpdateWithoutDocumentInput>
  }

  export type TransactionSuggestionUpdateManyWithWhereWithoutDocumentInput = {
    where: TransactionSuggestionScalarWhereInput
    data: XOR<TransactionSuggestionUpdateManyMutationInput, TransactionSuggestionUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentUploadCreateWithoutOcrResultsInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutDocumentUploadsInput
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
    transactionSuggestions?: TransactionSuggestionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadUncheckedCreateWithoutOcrResultsInput = {
    id?: string
    householdId: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedBy: string
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionSuggestions?: TransactionSuggestionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadCreateOrConnectWithoutOcrResultsInput = {
    where: DocumentUploadWhereUniqueInput
    create: XOR<DocumentUploadCreateWithoutOcrResultsInput, DocumentUploadUncheckedCreateWithoutOcrResultsInput>
  }

  export type TransactionSuggestionCreateWithoutOcrResultInput = {
    id?: string
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentUploadCreateNestedOneWithoutTransactionSuggestionsInput
    suggestedCategory?: CategoryCreateNestedOneWithoutTransactionSuggestionsInput
    createdTransaction?: TransactionCreateNestedOneWithoutCreatedFromSuggestionInput
  }

  export type TransactionSuggestionUncheckedCreateWithoutOcrResultInput = {
    id?: string
    documentId: string
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryId?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionSuggestionCreateOrConnectWithoutOcrResultInput = {
    where: TransactionSuggestionWhereUniqueInput
    create: XOR<TransactionSuggestionCreateWithoutOcrResultInput, TransactionSuggestionUncheckedCreateWithoutOcrResultInput>
  }

  export type TransactionSuggestionCreateManyOcrResultInputEnvelope = {
    data: TransactionSuggestionCreateManyOcrResultInput | TransactionSuggestionCreateManyOcrResultInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUploadUpsertWithoutOcrResultsInput = {
    update: XOR<DocumentUploadUpdateWithoutOcrResultsInput, DocumentUploadUncheckedUpdateWithoutOcrResultsInput>
    create: XOR<DocumentUploadCreateWithoutOcrResultsInput, DocumentUploadUncheckedCreateWithoutOcrResultsInput>
    where?: DocumentUploadWhereInput
  }

  export type DocumentUploadUpdateToOneWithWhereWithoutOcrResultsInput = {
    where?: DocumentUploadWhereInput
    data: XOR<DocumentUploadUpdateWithoutOcrResultsInput, DocumentUploadUncheckedUpdateWithoutOcrResultsInput>
  }

  export type DocumentUploadUpdateWithoutOcrResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutDocumentUploadsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUploadUncheckedUpdateWithoutOcrResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type TransactionSuggestionUpsertWithWhereUniqueWithoutOcrResultInput = {
    where: TransactionSuggestionWhereUniqueInput
    update: XOR<TransactionSuggestionUpdateWithoutOcrResultInput, TransactionSuggestionUncheckedUpdateWithoutOcrResultInput>
    create: XOR<TransactionSuggestionCreateWithoutOcrResultInput, TransactionSuggestionUncheckedCreateWithoutOcrResultInput>
  }

  export type TransactionSuggestionUpdateWithWhereUniqueWithoutOcrResultInput = {
    where: TransactionSuggestionWhereUniqueInput
    data: XOR<TransactionSuggestionUpdateWithoutOcrResultInput, TransactionSuggestionUncheckedUpdateWithoutOcrResultInput>
  }

  export type TransactionSuggestionUpdateManyWithWhereWithoutOcrResultInput = {
    where: TransactionSuggestionScalarWhereInput
    data: XOR<TransactionSuggestionUpdateManyMutationInput, TransactionSuggestionUncheckedUpdateManyWithoutOcrResultInput>
  }

  export type DocumentUploadCreateWithoutTransactionSuggestionsInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutDocumentUploadsInput
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
    ocrResults?: OcrResultCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadUncheckedCreateWithoutTransactionSuggestionsInput = {
    id?: string
    householdId: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedBy: string
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ocrResults?: OcrResultUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUploadCreateOrConnectWithoutTransactionSuggestionsInput = {
    where: DocumentUploadWhereUniqueInput
    create: XOR<DocumentUploadCreateWithoutTransactionSuggestionsInput, DocumentUploadUncheckedCreateWithoutTransactionSuggestionsInput>
  }

  export type OcrResultCreateWithoutTransactionSuggestionsInput = {
    id?: string
    documentType: $Enums.DocumentType
    confidence: Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText: string
    processedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    document: DocumentUploadCreateNestedOneWithoutOcrResultsInput
  }

  export type OcrResultUncheckedCreateWithoutTransactionSuggestionsInput = {
    id?: string
    documentId: string
    documentType: $Enums.DocumentType
    confidence: Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText: string
    processedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OcrResultCreateOrConnectWithoutTransactionSuggestionsInput = {
    where: OcrResultWhereUniqueInput
    create: XOR<OcrResultCreateWithoutTransactionSuggestionsInput, OcrResultUncheckedCreateWithoutTransactionSuggestionsInput>
  }

  export type CategoryCreateWithoutTransactionSuggestionsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    household?: HouseholdCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTransactionSuggestionsInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    transactionSplits?: TransactionSplitUncheckedCreateNestedManyWithoutCategoryInput
    budgetCategories?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCategoryInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTransactionSuggestionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTransactionSuggestionsInput, CategoryUncheckedCreateWithoutTransactionSuggestionsInput>
  }

  export type TransactionCreateWithoutCreatedFromSuggestionInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCreatedFromSuggestionInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCreatedFromSuggestionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreatedFromSuggestionInput, TransactionUncheckedCreateWithoutCreatedFromSuggestionInput>
  }

  export type DocumentUploadUpsertWithoutTransactionSuggestionsInput = {
    update: XOR<DocumentUploadUpdateWithoutTransactionSuggestionsInput, DocumentUploadUncheckedUpdateWithoutTransactionSuggestionsInput>
    create: XOR<DocumentUploadCreateWithoutTransactionSuggestionsInput, DocumentUploadUncheckedCreateWithoutTransactionSuggestionsInput>
    where?: DocumentUploadWhereInput
  }

  export type DocumentUploadUpdateToOneWithWhereWithoutTransactionSuggestionsInput = {
    where?: DocumentUploadWhereInput
    data: XOR<DocumentUploadUpdateWithoutTransactionSuggestionsInput, DocumentUploadUncheckedUpdateWithoutTransactionSuggestionsInput>
  }

  export type DocumentUploadUpdateWithoutTransactionSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutDocumentUploadsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
    ocrResults?: OcrResultUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUploadUncheckedUpdateWithoutTransactionSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ocrResults?: OcrResultUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type OcrResultUpsertWithoutTransactionSuggestionsInput = {
    update: XOR<OcrResultUpdateWithoutTransactionSuggestionsInput, OcrResultUncheckedUpdateWithoutTransactionSuggestionsInput>
    create: XOR<OcrResultCreateWithoutTransactionSuggestionsInput, OcrResultUncheckedCreateWithoutTransactionSuggestionsInput>
    where?: OcrResultWhereInput
  }

  export type OcrResultUpdateToOneWithWhereWithoutTransactionSuggestionsInput = {
    where?: OcrResultWhereInput
    data: XOR<OcrResultUpdateWithoutTransactionSuggestionsInput, OcrResultUncheckedUpdateWithoutTransactionSuggestionsInput>
  }

  export type OcrResultUpdateWithoutTransactionSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUploadUpdateOneRequiredWithoutOcrResultsNestedInput
  }

  export type OcrResultUncheckedUpdateWithoutTransactionSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutTransactionSuggestionsInput = {
    update: XOR<CategoryUpdateWithoutTransactionSuggestionsInput, CategoryUncheckedUpdateWithoutTransactionSuggestionsInput>
    create: XOR<CategoryCreateWithoutTransactionSuggestionsInput, CategoryUncheckedCreateWithoutTransactionSuggestionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTransactionSuggestionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTransactionSuggestionsInput, CategoryUncheckedUpdateWithoutTransactionSuggestionsInput>
  }

  export type CategoryUpdateWithoutTransactionSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTransactionSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TransactionUpsertWithoutCreatedFromSuggestionInput = {
    update: XOR<TransactionUpdateWithoutCreatedFromSuggestionInput, TransactionUncheckedUpdateWithoutCreatedFromSuggestionInput>
    create: XOR<TransactionCreateWithoutCreatedFromSuggestionInput, TransactionUncheckedCreateWithoutCreatedFromSuggestionInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutCreatedFromSuggestionInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutCreatedFromSuggestionInput, TransactionUncheckedUpdateWithoutCreatedFromSuggestionInput>
  }

  export type TransactionUpdateWithoutCreatedFromSuggestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCreatedFromSuggestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type HouseholdCreateWithoutZakatCalculationsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutZakatCalculationsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutZakatCalculationsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutZakatCalculationsInput, HouseholdUncheckedCreateWithoutZakatCalculationsInput>
  }

  export type ZakatAssetBreakdownCreateWithoutZakatCalculationInput = {
    id?: string
    assetType: $Enums.ZakatAssetType
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutZakatAssetBreakdownInput
  }

  export type ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput = {
    id?: string
    assetType: $Enums.ZakatAssetType
    accountId?: string | null
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatAssetBreakdownCreateOrConnectWithoutZakatCalculationInput = {
    where: ZakatAssetBreakdownWhereUniqueInput
    create: XOR<ZakatAssetBreakdownCreateWithoutZakatCalculationInput, ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput>
  }

  export type ZakatAssetBreakdownCreateManyZakatCalculationInputEnvelope = {
    data: ZakatAssetBreakdownCreateManyZakatCalculationInput | ZakatAssetBreakdownCreateManyZakatCalculationInput[]
    skipDuplicates?: boolean
  }

  export type ZakatPaymentCreateWithoutZakatCalculationInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    household: HouseholdCreateNestedOneWithoutZakatPaymentsInput
    transaction?: TransactionCreateNestedOneWithoutZakatPaymentsInput
  }

  export type ZakatPaymentUncheckedCreateWithoutZakatCalculationInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    transactionId?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatPaymentCreateOrConnectWithoutZakatCalculationInput = {
    where: ZakatPaymentWhereUniqueInput
    create: XOR<ZakatPaymentCreateWithoutZakatCalculationInput, ZakatPaymentUncheckedCreateWithoutZakatCalculationInput>
  }

  export type ZakatPaymentCreateManyZakatCalculationInputEnvelope = {
    data: ZakatPaymentCreateManyZakatCalculationInput | ZakatPaymentCreateManyZakatCalculationInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutZakatCalculationsInput = {
    update: XOR<HouseholdUpdateWithoutZakatCalculationsInput, HouseholdUncheckedUpdateWithoutZakatCalculationsInput>
    create: XOR<HouseholdCreateWithoutZakatCalculationsInput, HouseholdUncheckedCreateWithoutZakatCalculationsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutZakatCalculationsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutZakatCalculationsInput, HouseholdUncheckedUpdateWithoutZakatCalculationsInput>
  }

  export type HouseholdUpdateWithoutZakatCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutZakatCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type ZakatAssetBreakdownUpsertWithWhereUniqueWithoutZakatCalculationInput = {
    where: ZakatAssetBreakdownWhereUniqueInput
    update: XOR<ZakatAssetBreakdownUpdateWithoutZakatCalculationInput, ZakatAssetBreakdownUncheckedUpdateWithoutZakatCalculationInput>
    create: XOR<ZakatAssetBreakdownCreateWithoutZakatCalculationInput, ZakatAssetBreakdownUncheckedCreateWithoutZakatCalculationInput>
  }

  export type ZakatAssetBreakdownUpdateWithWhereUniqueWithoutZakatCalculationInput = {
    where: ZakatAssetBreakdownWhereUniqueInput
    data: XOR<ZakatAssetBreakdownUpdateWithoutZakatCalculationInput, ZakatAssetBreakdownUncheckedUpdateWithoutZakatCalculationInput>
  }

  export type ZakatAssetBreakdownUpdateManyWithWhereWithoutZakatCalculationInput = {
    where: ZakatAssetBreakdownScalarWhereInput
    data: XOR<ZakatAssetBreakdownUpdateManyMutationInput, ZakatAssetBreakdownUncheckedUpdateManyWithoutZakatCalculationInput>
  }

  export type ZakatPaymentUpsertWithWhereUniqueWithoutZakatCalculationInput = {
    where: ZakatPaymentWhereUniqueInput
    update: XOR<ZakatPaymentUpdateWithoutZakatCalculationInput, ZakatPaymentUncheckedUpdateWithoutZakatCalculationInput>
    create: XOR<ZakatPaymentCreateWithoutZakatCalculationInput, ZakatPaymentUncheckedCreateWithoutZakatCalculationInput>
  }

  export type ZakatPaymentUpdateWithWhereUniqueWithoutZakatCalculationInput = {
    where: ZakatPaymentWhereUniqueInput
    data: XOR<ZakatPaymentUpdateWithoutZakatCalculationInput, ZakatPaymentUncheckedUpdateWithoutZakatCalculationInput>
  }

  export type ZakatPaymentUpdateManyWithWhereWithoutZakatCalculationInput = {
    where: ZakatPaymentScalarWhereInput
    data: XOR<ZakatPaymentUpdateManyMutationInput, ZakatPaymentUncheckedUpdateManyWithoutZakatCalculationInput>
  }

  export type ZakatCalculationCreateWithoutAssetBreakdownInput = {
    id?: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutZakatCalculationsInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutZakatCalculationInput
  }

  export type ZakatCalculationUncheckedCreateWithoutAssetBreakdownInput = {
    id?: string
    householdId: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutZakatCalculationInput
  }

  export type ZakatCalculationCreateOrConnectWithoutAssetBreakdownInput = {
    where: ZakatCalculationWhereUniqueInput
    create: XOR<ZakatCalculationCreateWithoutAssetBreakdownInput, ZakatCalculationUncheckedCreateWithoutAssetBreakdownInput>
  }

  export type AccountCreateWithoutZakatAssetBreakdownInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutZakatAssetBreakdownInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    shariaCompliance?: ShariaCompliantAccountUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutZakatAssetBreakdownInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutZakatAssetBreakdownInput, AccountUncheckedCreateWithoutZakatAssetBreakdownInput>
  }

  export type ZakatCalculationUpsertWithoutAssetBreakdownInput = {
    update: XOR<ZakatCalculationUpdateWithoutAssetBreakdownInput, ZakatCalculationUncheckedUpdateWithoutAssetBreakdownInput>
    create: XOR<ZakatCalculationCreateWithoutAssetBreakdownInput, ZakatCalculationUncheckedCreateWithoutAssetBreakdownInput>
    where?: ZakatCalculationWhereInput
  }

  export type ZakatCalculationUpdateToOneWithWhereWithoutAssetBreakdownInput = {
    where?: ZakatCalculationWhereInput
    data: XOR<ZakatCalculationUpdateWithoutAssetBreakdownInput, ZakatCalculationUncheckedUpdateWithoutAssetBreakdownInput>
  }

  export type ZakatCalculationUpdateWithoutAssetBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutZakatCalculationsNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutZakatCalculationNestedInput
  }

  export type ZakatCalculationUncheckedUpdateWithoutAssetBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutZakatCalculationNestedInput
  }

  export type AccountUpsertWithoutZakatAssetBreakdownInput = {
    update: XOR<AccountUpdateWithoutZakatAssetBreakdownInput, AccountUncheckedUpdateWithoutZakatAssetBreakdownInput>
    create: XOR<AccountCreateWithoutZakatAssetBreakdownInput, AccountUncheckedCreateWithoutZakatAssetBreakdownInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutZakatAssetBreakdownInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutZakatAssetBreakdownInput, AccountUncheckedUpdateWithoutZakatAssetBreakdownInput>
  }

  export type AccountUpdateWithoutZakatAssetBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutZakatAssetBreakdownInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type HouseholdCreateWithoutZakatRemindersInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutZakatRemindersInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutZakatRemindersInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutZakatRemindersInput, HouseholdUncheckedCreateWithoutZakatRemindersInput>
  }

  export type HouseholdUpsertWithoutZakatRemindersInput = {
    update: XOR<HouseholdUpdateWithoutZakatRemindersInput, HouseholdUncheckedUpdateWithoutZakatRemindersInput>
    create: XOR<HouseholdCreateWithoutZakatRemindersInput, HouseholdUncheckedCreateWithoutZakatRemindersInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutZakatRemindersInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutZakatRemindersInput, HouseholdUncheckedUpdateWithoutZakatRemindersInput>
  }

  export type HouseholdUpdateWithoutZakatRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutZakatRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type ZakatCalculationCreateWithoutZakatPaymentsInput = {
    id?: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutZakatCalculationsInput
    assetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutZakatCalculationInput
  }

  export type ZakatCalculationUncheckedCreateWithoutZakatPaymentsInput = {
    id?: string
    householdId: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutZakatCalculationInput
  }

  export type ZakatCalculationCreateOrConnectWithoutZakatPaymentsInput = {
    where: ZakatCalculationWhereUniqueInput
    create: XOR<ZakatCalculationCreateWithoutZakatPaymentsInput, ZakatCalculationUncheckedCreateWithoutZakatPaymentsInput>
  }

  export type HouseholdCreateWithoutZakatPaymentsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutZakatPaymentsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutZakatPaymentsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutZakatPaymentsInput, HouseholdUncheckedCreateWithoutZakatPaymentsInput>
  }

  export type TransactionCreateWithoutZakatPaymentsInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutTransactionsInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    transferAccount?: AccountCreateNestedOneWithoutTransferTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
    merchantData?: MerchantCreateNestedOneWithoutTransactionsInput
    creator: UserCreateNestedOneWithoutCreatedTransactionsInput
    tags?: TransactionTagCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionCreateNestedManyWithoutCreatedTransactionInput
  }

  export type TransactionUncheckedCreateWithoutZakatPaymentsInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: TransactionTagUncheckedCreateNestedManyWithoutTransactionInput
    splits?: TransactionSplitUncheckedCreateNestedManyWithoutTransactionInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedCreateNestedManyWithoutTransactionInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutTransactionInput
    createdFromSuggestion?: TransactionSuggestionUncheckedCreateNestedManyWithoutCreatedTransactionInput
  }

  export type TransactionCreateOrConnectWithoutZakatPaymentsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutZakatPaymentsInput, TransactionUncheckedCreateWithoutZakatPaymentsInput>
  }

  export type ZakatCalculationUpsertWithoutZakatPaymentsInput = {
    update: XOR<ZakatCalculationUpdateWithoutZakatPaymentsInput, ZakatCalculationUncheckedUpdateWithoutZakatPaymentsInput>
    create: XOR<ZakatCalculationCreateWithoutZakatPaymentsInput, ZakatCalculationUncheckedCreateWithoutZakatPaymentsInput>
    where?: ZakatCalculationWhereInput
  }

  export type ZakatCalculationUpdateToOneWithWhereWithoutZakatPaymentsInput = {
    where?: ZakatCalculationWhereInput
    data: XOR<ZakatCalculationUpdateWithoutZakatPaymentsInput, ZakatCalculationUncheckedUpdateWithoutZakatPaymentsInput>
  }

  export type ZakatCalculationUpdateWithoutZakatPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutZakatCalculationsNestedInput
    assetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutZakatCalculationNestedInput
  }

  export type ZakatCalculationUncheckedUpdateWithoutZakatPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutZakatCalculationNestedInput
  }

  export type HouseholdUpsertWithoutZakatPaymentsInput = {
    update: XOR<HouseholdUpdateWithoutZakatPaymentsInput, HouseholdUncheckedUpdateWithoutZakatPaymentsInput>
    create: XOR<HouseholdCreateWithoutZakatPaymentsInput, HouseholdUncheckedCreateWithoutZakatPaymentsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutZakatPaymentsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutZakatPaymentsInput, HouseholdUncheckedUpdateWithoutZakatPaymentsInput>
  }

  export type HouseholdUpdateWithoutZakatPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutZakatPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type TransactionUpsertWithoutZakatPaymentsInput = {
    update: XOR<TransactionUpdateWithoutZakatPaymentsInput, TransactionUncheckedUpdateWithoutZakatPaymentsInput>
    create: XOR<TransactionCreateWithoutZakatPaymentsInput, TransactionUncheckedCreateWithoutZakatPaymentsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutZakatPaymentsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutZakatPaymentsInput, TransactionUncheckedUpdateWithoutZakatPaymentsInput>
  }

  export type TransactionUpdateWithoutZakatPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutZakatPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
  }

  export type AccountCreateWithoutShariaComplianceInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutAccountsInput
    institution?: InstitutionCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutShariaComplianceInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transferTransactions?: TransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutAccountInput
    recurringTransferTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutTransferAccountInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutAccountInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutShariaComplianceInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutShariaComplianceInput, AccountUncheckedCreateWithoutShariaComplianceInput>
  }

  export type UserCreateWithoutShariaReviewsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShariaReviewsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShariaReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShariaReviewsInput, UserUncheckedCreateWithoutShariaReviewsInput>
  }

  export type AccountUpsertWithoutShariaComplianceInput = {
    update: XOR<AccountUpdateWithoutShariaComplianceInput, AccountUncheckedUpdateWithoutShariaComplianceInput>
    create: XOR<AccountCreateWithoutShariaComplianceInput, AccountUncheckedCreateWithoutShariaComplianceInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutShariaComplianceInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutShariaComplianceInput, AccountUncheckedUpdateWithoutShariaComplianceInput>
  }

  export type AccountUpdateWithoutShariaComplianceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutShariaComplianceInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserUpsertWithoutShariaReviewsInput = {
    update: XOR<UserUpdateWithoutShariaReviewsInput, UserUncheckedUpdateWithoutShariaReviewsInput>
    create: XOR<UserCreateWithoutShariaReviewsInput, UserUncheckedCreateWithoutShariaReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShariaReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShariaReviewsInput, UserUncheckedUpdateWithoutShariaReviewsInput>
  }

  export type UserUpdateWithoutShariaReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShariaReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdCreateWithoutIslamicFinanceReportsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutIslamicFinanceReportsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutIslamicFinanceReportsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutIslamicFinanceReportsInput, HouseholdUncheckedCreateWithoutIslamicFinanceReportsInput>
  }

  export type UserCreateWithoutGeneratedIslamicReportsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGeneratedIslamicReportsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGeneratedIslamicReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeneratedIslamicReportsInput, UserUncheckedCreateWithoutGeneratedIslamicReportsInput>
  }

  export type HouseholdUpsertWithoutIslamicFinanceReportsInput = {
    update: XOR<HouseholdUpdateWithoutIslamicFinanceReportsInput, HouseholdUncheckedUpdateWithoutIslamicFinanceReportsInput>
    create: XOR<HouseholdCreateWithoutIslamicFinanceReportsInput, HouseholdUncheckedCreateWithoutIslamicFinanceReportsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutIslamicFinanceReportsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutIslamicFinanceReportsInput, HouseholdUncheckedUpdateWithoutIslamicFinanceReportsInput>
  }

  export type HouseholdUpdateWithoutIslamicFinanceReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutIslamicFinanceReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type UserUpsertWithoutGeneratedIslamicReportsInput = {
    update: XOR<UserUpdateWithoutGeneratedIslamicReportsInput, UserUncheckedUpdateWithoutGeneratedIslamicReportsInput>
    create: XOR<UserCreateWithoutGeneratedIslamicReportsInput, UserUncheckedCreateWithoutGeneratedIslamicReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeneratedIslamicReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeneratedIslamicReportsInput, UserUncheckedUpdateWithoutGeneratedIslamicReportsInput>
  }

  export type UserUpdateWithoutGeneratedIslamicReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGeneratedIslamicReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type HouseholdCreateWithoutNotificationsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    accounts?: AccountCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionCreateNestedManyWithoutHouseholdInput
    debts?: DebtCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryCreateNestedManyWithoutHouseholdInput
    categories?: CategoryCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    baseCurrency?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    accounts?: AccountUncheckedCreateNestedManyWithoutHouseholdInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutHouseholdInput
    debts?: DebtUncheckedCreateNestedManyWithoutHouseholdInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutHouseholdInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutHouseholdInput
    gratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutHouseholdInput
    categories?: CategoryUncheckedCreateNestedManyWithoutHouseholdInput
    recurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutHouseholdInput
    documentUploads?: DocumentUploadUncheckedCreateNestedManyWithoutHouseholdInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutHouseholdInput
    spendingPatterns?: SpendingPatternUncheckedCreateNestedManyWithoutHouseholdInput
    financialInsights?: FinancialInsightUncheckedCreateNestedManyWithoutHouseholdInput
    zakatCalculations?: ZakatCalculationUncheckedCreateNestedManyWithoutHouseholdInput
    zakatReminders?: ZakatReminderUncheckedCreateNestedManyWithoutHouseholdInput
    zakatPayments?: ZakatPaymentUncheckedCreateNestedManyWithoutHouseholdInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutNotificationsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutNotificationsInput, HouseholdUncheckedCreateWithoutNotificationsInput>
  }

  export type NotificationDeliveryCreateWithoutNotificationInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    deliveredAt?: Date | string | null
    failureReason?: string | null
    retryCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationDeliveryUncheckedCreateWithoutNotificationInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    deliveredAt?: Date | string | null
    failureReason?: string | null
    retryCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationDeliveryCreateOrConnectWithoutNotificationInput = {
    where: NotificationDeliveryWhereUniqueInput
    create: XOR<NotificationDeliveryCreateWithoutNotificationInput, NotificationDeliveryUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationDeliveryCreateManyNotificationInputEnvelope = {
    data: NotificationDeliveryCreateManyNotificationInput | NotificationDeliveryCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdUpsertWithoutNotificationsInput = {
    update: XOR<HouseholdUpdateWithoutNotificationsInput, HouseholdUncheckedUpdateWithoutNotificationsInput>
    create: XOR<HouseholdCreateWithoutNotificationsInput, HouseholdUncheckedCreateWithoutNotificationsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutNotificationsInput, HouseholdUncheckedUpdateWithoutNotificationsInput>
  }

  export type HouseholdUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutHouseholdNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    debts?: DebtUncheckedUpdateManyWithoutHouseholdNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutHouseholdNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutHouseholdNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutHouseholdNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutHouseholdNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutHouseholdNestedInput
    documentUploads?: DocumentUploadUncheckedUpdateManyWithoutHouseholdNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutHouseholdNestedInput
    spendingPatterns?: SpendingPatternUncheckedUpdateManyWithoutHouseholdNestedInput
    financialInsights?: FinancialInsightUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatCalculations?: ZakatCalculationUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatReminders?: ZakatReminderUncheckedUpdateManyWithoutHouseholdNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutHouseholdNestedInput
    islamicFinanceReports?: IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type NotificationDeliveryUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationDeliveryWhereUniqueInput
    update: XOR<NotificationDeliveryUpdateWithoutNotificationInput, NotificationDeliveryUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationDeliveryCreateWithoutNotificationInput, NotificationDeliveryUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationDeliveryUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationDeliveryWhereUniqueInput
    data: XOR<NotificationDeliveryUpdateWithoutNotificationInput, NotificationDeliveryUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationDeliveryUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationDeliveryScalarWhereInput
    data: XOR<NotificationDeliveryUpdateManyMutationInput, NotificationDeliveryUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationDeliveryScalarWhereInput = {
    AND?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[]
    OR?: NotificationDeliveryScalarWhereInput[]
    NOT?: NotificationDeliveryScalarWhereInput | NotificationDeliveryScalarWhereInput[]
    id?: UuidFilter<"NotificationDelivery"> | string
    notificationId?: UuidFilter<"NotificationDelivery"> | string
    channel?: EnumNotificationChannelFilter<"NotificationDelivery"> | $Enums.NotificationChannel
    status?: EnumNotificationStatusFilter<"NotificationDelivery"> | $Enums.NotificationStatus
    deliveredAt?: DateTimeNullableFilter<"NotificationDelivery"> | Date | string | null
    failureReason?: StringNullableFilter<"NotificationDelivery"> | string | null
    retryCount?: IntFilter<"NotificationDelivery"> | number
    metadata?: JsonFilter<"NotificationDelivery">
    createdAt?: DateTimeFilter<"NotificationDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationDelivery"> | Date | string
  }

  export type NotificationCreateWithoutDeliveriesInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    household: HouseholdCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    userId: string
    householdId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutDeliveriesInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutDeliveriesInput, NotificationUncheckedCreateWithoutDeliveriesInput>
  }

  export type NotificationUpsertWithoutDeliveriesInput = {
    update: XOR<NotificationUpdateWithoutDeliveriesInput, NotificationUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<NotificationCreateWithoutDeliveriesInput, NotificationUncheckedCreateWithoutDeliveriesInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutDeliveriesInput, NotificationUncheckedUpdateWithoutDeliveriesInput>
  }

  export type NotificationUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    household?: HouseholdUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type UserUpsertWithoutNotificationPreferencesInput = {
    update: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type UserUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberCreateNestedManyWithoutUserInput
    passkeys?: PasskeyCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    householdMembers?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdTransactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    createdWishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutCreatorInput
    createdGratitudeEntries?: GratitudeEntryUncheckedCreateNestedManyWithoutCreatorInput
    createdRecurringTransactions?: RecurringTransactionUncheckedCreateNestedManyWithoutCreatorInput
    uploadedDocuments?: DocumentUploadUncheckedCreateNestedManyWithoutUploaderInput
    userEvents?: UserEventUncheckedCreateNestedManyWithoutUserInput
    shariaReviews?: ShariaCompliantAccountUncheckedCreateNestedManyWithoutReviewerInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedCreateNestedManyWithoutGeneratorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPushSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
  }

  export type UserUpsertWithoutPushSubscriptionsInput = {
    update: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type UserUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    householdMembers?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    passkeys?: PasskeyUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdTransactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    createdWishlistItems?: WishlistItemUncheckedUpdateManyWithoutCreatorNestedInput
    createdGratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCreatorNestedInput
    createdRecurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedDocuments?: DocumentUploadUncheckedUpdateManyWithoutUploaderNestedInput
    userEvents?: UserEventUncheckedUpdateManyWithoutUserNestedInput
    shariaReviews?: ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerNestedInput
    generatedIslamicReports?: IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type HouseholdMemberCreateManyUserInput = {
    id?: string
    householdId: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
  }

  export type PasskeyCreateManyUserInput = {
    id?: string
    name: string
    credentialId: string
    publicKey: string
    counter?: number
    transports?: PasskeyCreatetransportsInput | string[]
    createdAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyCreatorInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemCreateManyCreatorInput = {
    id?: string
    householdId: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GratitudeEntryCreateManyCreatorInput = {
    id?: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    categoryId?: string | null
    transactionId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdAt?: Date | string
  }

  export type RecurringTransactionCreateManyCreatorInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUploadCreateManyUploaderInput = {
    id?: string
    householdId: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEventCreateManyUserInput = {
    id?: string
    householdId: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type ShariaCompliantAccountCreateManyReviewerInput = {
    id?: string
    accountId: string
    complianceStatus: $Enums.ShariaComplianceStatus
    complianceNotes?: string | null
    lastReviewDate: Date | string
    nextReviewDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IslamicFinanceReportCreateManyGeneratorInput = {
    id?: string
    householdId: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    householdId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateManyUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HouseholdMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutMembersNestedInput
  }

  export type HouseholdMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: PasskeyUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasskeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: PasskeyUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasskeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: PasskeyUpdatetransportsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutWishlistItemsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutGratitudeEntriesNestedInput
    category?: CategoryUpdateOneWithoutGratitudeEntriesNestedInput
    transaction?: TransactionUpdateOneWithoutGratitudeEntriesNestedInput
  }

  export type GratitudeEntryUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutRecurringTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutRecurringTransactionsNestedInput
    executions?: RecurringTransactionExecutionUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUploadUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutDocumentUploadsNestedInput
    ocrResults?: OcrResultUpdateManyWithoutDocumentNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUploadUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ocrResults?: OcrResultUncheckedUpdateManyWithoutDocumentNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUploadUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutUserEventsNestedInput
  }

  export type UserEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShariaCompliantAccountUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutShariaComplianceNestedInput
  }

  export type ShariaCompliantAccountUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShariaCompliantAccountUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    complianceStatus?: EnumShariaComplianceStatusFieldUpdateOperationsInput | $Enums.ShariaComplianceStatus
    complianceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    lastReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextReviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IslamicFinanceReportUpdateWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutIslamicFinanceReportsNestedInput
  }

  export type IslamicFinanceReportUncheckedUpdateWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IslamicFinanceReportUncheckedUpdateManyWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutNotificationsNestedInput
    deliveries?: NotificationDeliveryUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdMemberCreateManyHouseholdInput = {
    id?: string
    userId: string
    role: $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
  }

  export type AccountCreateManyHouseholdInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    institutionId?: string | null
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyHouseholdInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtCreateManyHouseholdInput = {
    id?: string
    type: $Enums.DebtType
    name: string
    creditor: string
    principalAmountCents: bigint | number
    currentBalanceCents: bigint | number
    currency?: string
    interestRate?: Decimal | DecimalJsLike | number | string | null
    marginRate?: Decimal | DecimalJsLike | number | string | null
    startDate: Date | string
    maturityDate?: Date | string | null
    isActive?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyHouseholdInput = {
    id?: string
    name: string
    period: $Enums.BudgetPeriod
    totalAllocatedCents: bigint | number
    currency?: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WishlistItemCreateManyHouseholdInput = {
    id?: string
    name: string
    url: string
    currentPriceCents: bigint | number
    targetPriceCents?: bigint | number | null
    currency?: string
    imageUrl?: string | null
    merchant: string
    linkedGoalId?: string | null
    isPurchased?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GratitudeEntryCreateManyHouseholdInput = {
    id?: string
    giver: string
    type: $Enums.GratitudeType
    categoryId?: string | null
    transactionId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdBy: string
    createdAt?: Date | string
  }

  export type CategoryCreateManyHouseholdInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    parentId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type RecurringTransactionCreateManyHouseholdInput = {
    id?: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUploadCreateManyHouseholdInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    documentType: $Enums.DocumentType
    status?: $Enums.ProcessingStatus
    uploadedBy: string
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    storageUrl: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEventCreateManyHouseholdInput = {
    id?: string
    userId: string
    eventType: string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: string | null
    resourceId?: string | null
    sessionId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type SpendingPatternCreateManyHouseholdInput = {
    id?: string
    userId?: string | null
    patternType: string
    categoryId?: string | null
    merchant?: string | null
    dayOfWeek?: number | null
    hourOfDay?: number | null
    month?: number | null
    averageAmountCents: bigint | number
    frequency: number
    confidenceScore?: Decimal | DecimalJsLike | number | string
    lastUpdated?: Date | string
  }

  export type FinancialInsightCreateManyHouseholdInput = {
    id?: string
    insightType: string
    title: string
    description: string
    data?: JsonNullValueInput | InputJsonValue
    priority: $Enums.InsightPriority
    isActionable?: boolean
    isDismissed?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatCalculationCreateManyHouseholdInput = {
    id?: string
    calculationDate: Date | string
    hijriYear: number
    nisabThresholdCents: bigint | number
    totalZakatableAssetsCents: bigint | number
    zakatAmountCents: bigint | number
    currency?: string
    isZakatDue?: boolean
    nextCalculationDate: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatReminderCreateManyHouseholdInput = {
    id?: string
    reminderType: $Enums.ZakatReminderType
    scheduledDate: Date | string
    hijriDate: string
    zakatAmountCents?: bigint | number | null
    currency?: string | null
    message: string
    isActive?: boolean
    isSent?: boolean
    sentAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatPaymentCreateManyHouseholdInput = {
    id?: string
    zakatCalculationId?: string | null
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    transactionId?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type IslamicFinanceReportCreateManyHouseholdInput = {
    id?: string
    reportType: $Enums.IslamicReportType
    periodStartDate: Date | string
    periodEndDate: Date | string
    periodType?: string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    generatedBy?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateManyHouseholdInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    actionText?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HouseholdMemberUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHouseholdMembersNestedInput
  }

  export type HouseholdMemberUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    institutionId?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: DebtPaymentUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: DebtPaymentUncheckedUpdateManyWithoutDebtNestedInput
  }

  export type DebtUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDebtTypeFieldUpdateOperationsInput | $Enums.DebtType
    name?: StringFieldUpdateOperationsInput | string
    creditor?: StringFieldUpdateOperationsInput | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currentBalanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    interestRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marginRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maturityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: BudgetCategoryUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: BudgetCategoryUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    totalAllocatedCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedWishlistItemsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    currentPriceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    targetPriceCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: StringFieldUpdateOperationsInput | string
    linkedGoalId?: NullableStringFieldUpdateOperationsInput | string | null
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutGratitudeEntriesNestedInput
    transaction?: TransactionUpdateOneWithoutGratitudeEntriesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedGratitudeEntriesNestedInput
  }

  export type GratitudeEntryUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutRecurringTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutRecurringTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringTransactionsNestedInput
    executions?: RecurringTransactionExecutionUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUploadUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
    ocrResults?: OcrResultUpdateManyWithoutDocumentNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUploadUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ocrResults?: OcrResultUncheckedUpdateManyWithoutDocumentNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUploadUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEventUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserEventsNestedInput
  }

  export type UserEventUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEventUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendingPatternUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    patternType?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    hourOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    averageAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: IntFieldUpdateOperationsInput | number
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendingPatternUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    patternType?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    hourOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    averageAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: IntFieldUpdateOperationsInput | number
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendingPatternUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    patternType?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    hourOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    averageAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    frequency?: IntFieldUpdateOperationsInput | number
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialInsightUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActionable?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialInsightUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActionable?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialInsightUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    priority?: EnumInsightPriorityFieldUpdateOperationsInput | $Enums.InsightPriority
    isActionable?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatCalculationUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutZakatCalculationNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutZakatCalculationNestedInput
  }

  export type ZakatCalculationUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutZakatCalculationNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutZakatCalculationNestedInput
  }

  export type ZakatCalculationUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriYear?: IntFieldUpdateOperationsInput | number
    nisabThresholdCents?: BigIntFieldUpdateOperationsInput | bigint | number
    totalZakatableAssetsCents?: BigIntFieldUpdateOperationsInput | bigint | number
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    isZakatDue?: BoolFieldUpdateOperationsInput | boolean
    nextCalculationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatReminderUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumZakatReminderTypeFieldUpdateOperationsInput | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    zakatAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatReminderUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumZakatReminderTypeFieldUpdateOperationsInput | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    zakatAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatReminderUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumZakatReminderTypeFieldUpdateOperationsInput | $Enums.ZakatReminderType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    zakatAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zakatCalculation?: ZakatCalculationUpdateOneWithoutZakatPaymentsNestedInput
    transaction?: TransactionUpdateOneWithoutZakatPaymentsNestedInput
  }

  export type ZakatPaymentUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IslamicFinanceReportUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generator?: UserUpdateOneWithoutGeneratedIslamicReportsNestedInput
  }

  export type IslamicFinanceReportUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IslamicFinanceReportUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumIslamicReportTypeFieldUpdateOperationsInput | $Enums.IslamicReportType
    periodStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    deliveries?: NotificationDeliveryUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: NotificationDeliveryUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInstitutionInput = {
    id?: string
    householdId: string
    name: string
    type: $Enums.AccountType
    subtype: string
    currency?: string
    accountNumber?: string | null
    balanceCents?: bigint | number
    isActive?: boolean
    ownerId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transferTransactions?: TransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutAccountNestedInput
    recurringTransferTransactions?: RecurringTransactionUncheckedUpdateManyWithoutTransferAccountNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutAccountNestedInput
    zakatAssetBreakdown?: ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountNestedInput
    shariaCompliance?: ShariaCompliantAccountUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subtype?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    balanceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyAccountInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyTransferAccountInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionCreateManyAccountInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    transferAccountId?: string | null
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionCreateManyTransferAccountInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    categoryId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyAccountInput = {
    id?: string
    transactionId: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
  }

  export type ZakatAssetBreakdownCreateManyAccountInput = {
    id?: string
    zakatCalculationId: string
    assetType: $Enums.ZakatAssetType
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutTransferAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTransferAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutTransferAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutRecurringTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutRecurringTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringTransactionsNestedInput
    executions?: RecurringTransactionExecutionUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionUpdateWithoutTransferAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    category?: CategoryUpdateOneWithoutRecurringTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringTransactionsNestedInput
    executions?: RecurringTransactionExecutionUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateWithoutTransferAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutTransferAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatAssetBreakdownUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zakatCalculation?: ZakatCalculationUpdateOneRequiredWithoutAssetBreakdownNestedInput
  }

  export type ZakatAssetBreakdownUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatAssetBreakdownUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyMerchantDataInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    categoryId?: string | null
    merchant?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutMerchantDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutMerchantDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutMerchantDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    icon?: string | null
    color?: string | null
    type: $Enums.CategoryType
    householdId?: string | null
    isActive?: boolean
    isEditable?: boolean
    isArchived?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyCategoryInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    originalAmountCents?: bigint | number | null
    originalCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    description: string
    merchant?: string | null
    merchantId?: string | null
    merchantName?: string | null
    merchantLogoUrl?: string | null
    merchantColor?: string | null
    date: Date | string
    accountId: string
    transferAccountId?: string | null
    receiptUrl?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionSplitCreateManyCategoryInput = {
    id?: string
    transactionId: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type BudgetCategoryCreateManyCategoryInput = {
    id?: string
    budgetId: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionCreateManyCategoryInput = {
    id?: string
    householdId: string
    name: string
    description: string
    amountCents: bigint | number
    currency?: string
    accountId: string
    transferAccountId?: string | null
    merchant?: string | null
    frequency: $Enums.RecurrenceFrequency
    intervalValue?: number
    startDate: Date | string
    endDate?: Date | string | null
    nextExecutionDate: Date | string
    lastExecutionDate?: Date | string | null
    executionCount?: number
    maxExecutions?: number | null
    status?: $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GratitudeEntryCreateManyCategoryInput = {
    id?: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    transactionId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdBy: string
    createdAt?: Date | string
  }

  export type TransactionSuggestionCreateManySuggestedCategoryInput = {
    id?: string
    documentId: string
    ocrResultId?: string | null
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneWithoutCategoriesNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSplits?: TransactionSplitUncheckedUpdateManyWithoutCategoryNestedInput
    budgetCategories?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    recurringTransactions?: RecurringTransactionUncheckedUpdateManyWithoutCategoryNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutCategoryNestedInput
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutTransferTransactionsNestedInput
    merchantData?: MerchantUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedTransactionsNestedInput
    tags?: TransactionTagUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: TransactionTagUncheckedUpdateManyWithoutTransactionNestedInput
    splits?: TransactionSplitUncheckedUpdateManyWithoutTransactionNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
    recurringTransactionExecutions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionNestedInput
    gratitudeEntries?: GratitudeEntryUncheckedUpdateManyWithoutTransactionNestedInput
    createdFromSuggestion?: TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionNestedInput
    zakatPayments?: ZakatPaymentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    originalAmountCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    originalCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    merchantColor?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSplitUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutSplitsNestedInput
  }

  export type TransactionSplitUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSplitUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type BudgetCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    account?: AccountUpdateOneRequiredWithoutRecurringTransactionsNestedInput
    transferAccount?: AccountUpdateOneWithoutRecurringTransferTransactionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRecurringTransactionsNestedInput
    executions?: RecurringTransactionExecutionUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionNestedInput
  }

  export type RecurringTransactionUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    transferAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    intervalValue?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExecutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastExecutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    maxExecutions?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecurringTransactionStatusFieldUpdateOperationsInput | $Enums.RecurringTransactionStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutGratitudeEntriesNestedInput
    transaction?: TransactionUpdateOneWithoutGratitudeEntriesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedGratitudeEntriesNestedInput
  }

  export type GratitudeEntryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionUpdateWithoutSuggestedCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUploadUpdateOneRequiredWithoutTransactionSuggestionsNestedInput
    ocrResult?: OcrResultUpdateOneWithoutTransactionSuggestionsNestedInput
    createdTransaction?: TransactionUpdateOneWithoutCreatedFromSuggestionNestedInput
  }

  export type TransactionSuggestionUncheckedUpdateWithoutSuggestedCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    ocrResultId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionUncheckedUpdateManyWithoutSuggestedCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    ocrResultId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionTagCreateManyTransactionInput = {
    tag: string
  }

  export type TransactionSplitCreateManyTransactionInput = {
    id?: string
    categoryId: string
    amountCents: bigint | number
    description?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryCreateManyTransactionInput = {
    id?: string
    accountId: string
    type: $Enums.LedgerType
    amountCents: bigint | number
    currency?: string
    createdAt?: Date | string
  }

  export type RecurringTransactionExecutionCreateManyTransactionInput = {
    id?: string
    recurringTransactionId: string
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GratitudeEntryCreateManyTransactionInput = {
    id?: string
    householdId: string
    giver: string
    type: $Enums.GratitudeType
    categoryId?: string | null
    estimatedValueCents?: bigint | number | null
    currency?: string | null
    description: string
    date: Date | string
    createdBy: string
    createdAt?: Date | string
  }

  export type TransactionSuggestionCreateManyCreatedTransactionInput = {
    id?: string
    documentId: string
    ocrResultId?: string | null
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryId?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZakatPaymentCreateManyTransactionInput = {
    id?: string
    zakatCalculationId?: string | null
    householdId: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionTagUpdateWithoutTransactionInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionTagUncheckedUpdateWithoutTransactionInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionTagUncheckedUpdateManyWithoutTransactionInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionSplitUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutTransactionSplitsNestedInput
  }

  export type TransactionSplitUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSplitUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumLedgerTypeFieldUpdateOperationsInput | $Enums.LedgerType
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionExecutionUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recurringTransaction?: RecurringTransactionUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type RecurringTransactionExecutionUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recurringTransactionId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionExecutionUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recurringTransactionId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutGratitudeEntriesNestedInput
    category?: CategoryUpdateOneWithoutGratitudeEntriesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedGratitudeEntriesNestedInput
  }

  export type GratitudeEntryUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GratitudeEntryUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    giver?: StringFieldUpdateOperationsInput | string
    type?: EnumGratitudeTypeFieldUpdateOperationsInput | $Enums.GratitudeType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValueCents?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionUpdateWithoutCreatedTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUploadUpdateOneRequiredWithoutTransactionSuggestionsNestedInput
    ocrResult?: OcrResultUpdateOneWithoutTransactionSuggestionsNestedInput
    suggestedCategory?: CategoryUpdateOneWithoutTransactionSuggestionsNestedInput
  }

  export type TransactionSuggestionUncheckedUpdateWithoutCreatedTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    ocrResultId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionUncheckedUpdateManyWithoutCreatedTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    ocrResultId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zakatCalculation?: ZakatCalculationUpdateOneWithoutZakatPaymentsNestedInput
    household?: HouseholdUpdateOneRequiredWithoutZakatPaymentsNestedInput
  }

  export type ZakatPaymentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    zakatCalculationId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentCreateManyDebtInput = {
    id?: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    principalAmountCents: bigint | number
    interestAmountCents?: bigint | number
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type DebtPaymentUpdateWithoutDebtInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    interestAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentUncheckedUpdateWithoutDebtInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    interestAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtPaymentUncheckedUpdateManyWithoutDebtInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    interestAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryCreateManyBudgetInput = {
    id?: string
    categoryId: string
    allocatedAmountCents: bigint | number
    spentAmountCents?: bigint | number
    carryOverCents?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCategoryUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutBudgetCategoriesNestedInput
  }

  export type BudgetCategoryUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    allocatedAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    spentAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    carryOverCents?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateManyWishlistItemInput = {
    id?: string
    priceCents: bigint | number
    currency?: string
    recordedAt?: Date | string
  }

  export type PriceHistoryUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionExecutionCreateManyRecurringTransactionInput = {
    id?: string
    transactionId?: string | null
    scheduledDate: Date | string
    executedDate?: Date | string | null
    status?: string
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringTransactionExecutionUpdateWithoutRecurringTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneWithoutRecurringTransactionExecutionsNestedInput
  }

  export type RecurringTransactionExecutionUncheckedUpdateWithoutRecurringTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringTransactionExecutionUncheckedUpdateManyWithoutRecurringTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OcrResultCreateManyDocumentInput = {
    id?: string
    documentType: $Enums.DocumentType
    confidence: Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText: string
    processedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TransactionSuggestionCreateManyDocumentInput = {
    id?: string
    ocrResultId?: string | null
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryId?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OcrResultUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionSuggestions?: TransactionSuggestionUpdateManyWithoutOcrResultNestedInput
  }

  export type OcrResultUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionSuggestions?: TransactionSuggestionUncheckedUpdateManyWithoutOcrResultNestedInput
  }

  export type OcrResultUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extractedData?: JsonNullValueInput | InputJsonValue
    rawText?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ocrResult?: OcrResultUpdateOneWithoutTransactionSuggestionsNestedInput
    suggestedCategory?: CategoryUpdateOneWithoutTransactionSuggestionsNestedInput
    createdTransaction?: TransactionUpdateOneWithoutCreatedFromSuggestionNestedInput
  }

  export type TransactionSuggestionUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    ocrResultId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    ocrResultId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionCreateManyOcrResultInput = {
    id?: string
    documentId: string
    description: string
    amountCents: bigint | number
    currency?: string
    date: Date | string
    merchant?: string | null
    suggestedCategoryId?: string | null
    suggestedCategoryName?: string | null
    confidence: Decimal | DecimalJsLike | number | string
    source: string
    status?: string
    isApproved?: boolean
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionSuggestionUpdateWithoutOcrResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUploadUpdateOneRequiredWithoutTransactionSuggestionsNestedInput
    suggestedCategory?: CategoryUpdateOneWithoutTransactionSuggestionsNestedInput
    createdTransaction?: TransactionUpdateOneWithoutCreatedFromSuggestionNestedInput
  }

  export type TransactionSuggestionUncheckedUpdateWithoutOcrResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionSuggestionUncheckedUpdateManyWithoutOcrResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedCategoryName?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatAssetBreakdownCreateManyZakatCalculationInput = {
    id?: string
    assetType: $Enums.ZakatAssetType
    accountId?: string | null
    accountName?: string | null
    amountCents: bigint | number
    currency?: string
    zakatRate: Decimal | DecimalJsLike | number | string
    zakatAmountCents: bigint | number
    haulCompleted?: boolean
    haulStartDate?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatPaymentCreateManyZakatCalculationInput = {
    id?: string
    householdId: string
    amountCents: bigint | number
    currency?: string
    paymentDate: Date | string
    hijriDate: string
    transactionId?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ZakatAssetBreakdownUpdateWithoutZakatCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutZakatAssetBreakdownNestedInput
  }

  export type ZakatAssetBreakdownUncheckedUpdateWithoutZakatCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatAssetBreakdownUncheckedUpdateManyWithoutZakatCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumZakatAssetTypeFieldUpdateOperationsInput | $Enums.ZakatAssetType
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    zakatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    zakatAmountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    haulCompleted?: BoolFieldUpdateOperationsInput | boolean
    haulStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentUpdateWithoutZakatCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutZakatPaymentsNestedInput
    transaction?: TransactionUpdateOneWithoutZakatPaymentsNestedInput
  }

  export type ZakatPaymentUncheckedUpdateWithoutZakatCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZakatPaymentUncheckedUpdateManyWithoutZakatCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amountCents?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hijriDate?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDeliveryCreateManyNotificationInput = {
    id?: string
    channel: $Enums.NotificationChannel
    status?: $Enums.NotificationStatus
    deliveredAt?: Date | string | null
    failureReason?: string | null
    retryCount?: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationDeliveryUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDeliveryUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDeliveryUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}